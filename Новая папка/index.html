<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Clone</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Press Start 2P', 'Courier New', monospace;
            background:
                repeating-linear-gradient(0deg, #4c7a3f 0px, #4c7a3f 6px, #3b6131 6px, #3b6131 12px),
                repeating-linear-gradient(90deg, #3b6131 0px, #3b6131 6px, #284422 6px, #284422 12px);
            background-size: 32px 32px;
            background-color: #2a431f;
            color: #ffffff;
        }

        #hud {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            z-index: 140;
            pointer-events: none;
            font-family: 'Press Start 2P', 'Courier New', monospace;
        }

        .status-row {
            display: flex;
            gap: 2px;
            padding: 2px 4px;
            background: transparent;
            border: none;
            box-shadow: none;
            image-rendering: pixelated;
            pointer-events: none;
        }

        .heart-icon,
        .hunger-icon {
            width: 20px;
            height: 20px;
            background-size: 100% 100%;
            background-repeat: no-repeat;
            image-rendering: pixelated;
            filter: drop-shadow(0 2px 0 rgba(0, 0, 0, 0.45));
            transition: transform 0.2s ease;
        }

        .heart-icon {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' shape-rendering='crispEdges'%3E%3Cpath fill='%233b1118' d='M0 0h16v16H0z'/%3E%3Cpath fill='%23240b10' d='M2 4h12v10H2z'/%3E%3Cpath fill='%23ff2f4a' d='M4 3h2v2H4zM10 3h2v2h-2zM3 5h3v2H3zM10 5h3v2h-3zM2 7h4v2H2zM10 7h4v2h-4zM3 9h3v2H3zM10 9h3v2h-3zM4 11h2v2H4zM10 11h2v2h-2z'/%3E%3Cpath fill='%23ffd3dd' d='M4 3h1v1H4zM10 3h1v1h-1zM3 5h1v1H3z'/%3E%3C/svg%3E");
        }

        .heart-icon.inactive {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' shape-rendering='crispEdges'%3E%3Cpath fill='%23220b10' d='M0 0h16v16H0z'/%3E%3Cpath fill='%23160a0d' d='M2 4h12v10H2z'/%3E%3Cpath fill='%23442133' d='M4 3h2v2H4zM10 3h2v2h-2zM3 5h3v2H3zM10 5h3v2h-3zM2 7h4v2H2zM10 7h4v2h-4zM3 9h3v2H3zM10 9h3v2h-3zM4 11h2v2H4zM10 11h2v2h-2z'/%3E%3Cpath fill='%23946276' d='M4 3h1v1H4zM10 3h1v1h-1zM3 5h1v1H3z'/%3E%3C/svg%3E");
            opacity: 0.4;
        }

        .hunger-icon {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' shape-rendering='crispEdges'%3E%3Cpath fill='%2330120a' d='M0 0h16v16H0z'/%3E%3Cpath fill='%23271809' d='M7 2h2v2H7zM6 4h4v2H6zM5 6h6v2H5zM5 8h6v2H5zM6 10h4v2H6zM7 12h2v2H7z'/%3E%3Cpath fill='%23fcb052' d='M8 3h1v1H8zM7 5h2v1H7zM6 7h4v1H6zM6 9h4v1H6zM7 11h2v1H7z'/%3E%3Cpath fill='%23ffe4b0' d='M8 3h1v1H8zM7 5h1v1H7zM6 7h1v1H6z'/%3E%3C/svg%3E");
        }

        .hunger-icon.inactive {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' shape-rendering='crispEdges'%3E%3Cpath fill='%23190c06' d='M0 0h16v16H0z'/%3E%3Cpath fill='%23140f07' d='M7 2h2v2H7zM6 4h4v2H6zM5 6h6v2H5zM5 8h6v2H5zM6 10h4v2H6zM7 12h2v2H7z'/%3E%3Cpath fill='%235e4024' d='M8 3h1v1H8zM7 5h2v1H7zM6 7h4v1H6zM6 9h4v1H6zM7 11h2v1H7z'/%3E%3C/svg%3E");
            opacity: 0.45;
        }

        .hearts-row.damage {
            animation: heartsShake 0.4s ease;
        }

        @keyframes heartsShake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            50% { transform: translateX(2px); }
            75% { transform: translateX(-1px); }
            100% { transform: translateX(0); }
        }

        .hunger-row.critical .hunger-icon.active {
            animation: hungerPulse 0.8s ease-in-out infinite;
        }

        @keyframes hungerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.12); }
        }

        .hud-hotbar {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            pointer-events: auto;
        }

        .hotbar-status {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 12px;
            padding: 4px 10px;
            background: rgba(20, 20, 20, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.45);
            min-width: 320px;
        }

        .hotbar-shell {
            padding: 8px 10px;
            background: rgba(12, 12, 12, 0.65);
            border: 2px solid rgba(255, 255, 255, 0.18);
            box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.4), 0 6px 10px rgba(0, 0, 0, 0.55);
        }

        .hotbar-slots {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 4px;
            pointer-events: auto;
        }

        .hotbar-slot {
            width: 50px;
            height: 50px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.35);
            box-shadow: inset 0 2px 0 rgba(255, 255, 255, 0.2), inset 0 -2px 0 rgba(0, 0, 0, 0.45);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.12s ease;
        }

        .hotbar-slot::after {
            content: attr(data-hotbar-num);
            position: absolute;
            bottom: -14px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: rgba(255, 255, 255, 0.85);
            text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.7);
            pointer-events: none;
        }

        .hotbar-slot:hover {
            transform: translateY(-3px);
        }

        .hotbar-slot.selected {
            border-color: #ffe26d;
            box-shadow: inset 0 3px 0 rgba(255, 255, 255, 0.55), inset 0 -3px 0 rgba(0, 0, 0, 0.45);
            transform: translateY(-3px);
        }

        .slot-icon {
            width: 38px;
            height: 38px;
            image-rendering: pixelated;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .slot-icon canvas,
        .slot-icon img {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .slot-qty {
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 12px;
            color: #ffffff;
            text-shadow: 2px 2px 0 #000000;
            pointer-events: none;
        }

        .hotbar-meta {
            font-size: 12px;
            color: #8ae45a;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.6);
            letter-spacing: 0.08em;
            text-align: center;
        }

        #inventory {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.75);
            z-index: 200;
        }

        #inventory.visible {
            display: flex;
        }

        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #2b1e14;
            background-image:
                linear-gradient(45deg, rgba(255, 255, 255, 0.03) 25%, transparent 25%, transparent 75%, rgba(255, 255, 255, 0.03) 75%, rgba(255, 255, 255, 0.03)),
                linear-gradient(45deg, rgba(0, 0, 0, 0.12) 25%, transparent 25%, transparent 75%, rgba(0, 0, 0, 0.12) 75%, rgba(0, 0, 0, 0.12));
            background-size: 16px 16px;
            background-position: 0 0, 8px 8px;
            overflow: hidden;
            z-index: 500;
        }

        #menu::before,
        #menu::after {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        #menu::before {
            background: radial-gradient(120% 50% at 50% 0%, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0) 55%);
        }

        #menu::after {
            background: radial-gradient(90% 30% at 50% 105%, rgba(0, 0, 0, 0.35) 0%, rgba(0, 0, 0, 0) 70%);
        }

        #menu.hidden {
            display: none;
        }

        #worldSelectionScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #2b1e14;
            background-image:
                linear-gradient(45deg, rgba(255, 255, 255, 0.03) 25%, transparent 25%, transparent 75%, rgba(255, 255, 255, 0.03) 75%, rgba(255, 255, 255, 0.03)),
                linear-gradient(45deg, rgba(0, 0, 0, 0.12) 25%, transparent 25%, transparent 75%, rgba(0, 0, 0, 0.12) 75%, rgba(0, 0, 0, 0.12));
            background-size: 16px 16px;
            background-position: 0 0, 8px 8px;
            z-index: 500;
        }
        
        #worldSelectionScreen.hidden {
            display: none;
        }

        .world-list {
            width: 600px;
            max-height: 400px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #555;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .world-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #444;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .world-item:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #fff;
        }

        .world-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
            color: #ddd;
            text-align: left;
        }

        .world-name {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            text-shadow: 2px 2px 0 #000;
        }

        .world-date {
            font-size: 12px;
            color: #aaa;
        }

        .world-actions {
            display: flex;
            gap: 8px;
        }

        .world-action-btn {
            padding: 8px 12px;
            background: #444;
            border: 2px solid #222;
            color: #fff;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            box-shadow: inset 2px 2px 0 rgba(255,255,255,0.2), inset -2px -2px 0 rgba(0,0,0,0.4);
        }
        
        .world-action-btn:hover {
            background: #666;
        }
        
        .world-action-btn.delete {
            background: #800;
        }
        
        .world-action-btn.delete:hover {
            background: #a00;
        }

        .menu-panel {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 18px;
            padding: 28px 32px;
            background: transparent;
            border: none;
            box-shadow: none;
            text-align: center;
            z-index: 1;
        }

        .menu-panel::before { display: none; }

        .menu-title {
            font-size: 88px;
            color: #d8d8d8;
            letter-spacing: 8px;
            text-shadow:
                0 6px 0 #1a1a1a,
                0 10px 12px rgba(0, 0, 0, 0.75),
                0 0 18px rgba(0, 0, 0, 0.35);
            transform: translateY(-150px);
        }

        .menu-tagline {
            display: none;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            align-items: center;
        }

        .inventory-window {
            background: #c6c6c6;
            border: 4px solid #373737;
            box-shadow: inset 4px 4px 0 #ffffff, inset -4px -4px 0 #6b6b6b;
            padding: 16px;
            width: 840px;
            max-width: 92vw;
            color: #1b1b1b;
        }

        .inventory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            text-transform: uppercase;
            font-size: 18px;
        }

        .inventory-title {
            flex: 1;
            text-align: center;
        }

        .inventory-close {
            width: 32px;
            height: 32px;
            border: 3px solid #6b6b6b;
            background: #9c9c9c;
            font-family: inherit;
            font-size: 18px;
            cursor: pointer;
            box-shadow: inset 2px 2px 0 #ffffff, inset -2px -2px 0 #6b6b6b;
        }

        .inventory-close:hover {
            border-color: #ffffff;
            background: #cfcfcf;
        }

        .inventory-body {
            display: flex;
            gap: 18px;
            align-items: stretch;
        }

        .inventory-preview {
            width: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-frame {
            position: relative;
            width: 160px;
            height: 220px;
            background: #9c9c9c;
            border: 4px solid #363636;
            box-shadow: inset 4px 4px 0 #ffffff, inset -4px -4px 0 #6b6b6b;
            overflow: hidden;
        }

        .preview-frame::before {
            content: '';
            position: absolute;
            inset: 8px;
            border: 2px solid rgba(255, 255, 255, 0.35);
            pointer-events: none;
        }

        .preview-character {
            position: absolute;
            inset: 0;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .preview-character canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .preview-character::after {
            content: '';
            position: absolute;
            left: 50%;
            bottom: -8px;
            width: 60px;
            height: 12px;
            transform: translateX(-50%);
            background: radial-gradient(circle, rgba(0, 0, 0, 0.55) 0%, rgba(0, 0, 0, 0) 70%);
            filter: blur(2px);
            opacity: 0.75;
            animation: shadowPulse 4s ease-in-out infinite;
        }

        @keyframes previewIdle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }

        @keyframes shadowPulse {
            0%, 100% { transform: translateX(-50%) scale(1); opacity: 0.75; }
            50% { transform: translateX(-50%) scale(0.92); opacity: 0.55; }
        }

        .inventory-main {
            flex: 1;
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 18px;
        }

        .inventory-sidebar {
            background: #b2b2b2;
            border: 3px solid #6b6b6b;
            box-shadow: inset 3px 3px 0 #e4e4e4, inset -3px -3px 0 #6b6b6b;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            height: 100%;
        }

        .inventory-tab {
            padding: 6px 8px;
            border: 2px solid #6b6b6b;
            background: #9c9c9c;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }

        .inventory-tab:hover,
        .inventory-tab.active {
            border-color: #ffffff;
            background: #cfcfcf;
            color: #000000;
        }

        .inventory-content {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .inventory-grid,
        .inventory-hotbar {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 6px;
        }

        .inventory-slot,
        .inventory-hotbar .hotbar-slot {
            width: 64px;
            height: 64px;
            border: 3px solid #6b6b6b;
            background: #8c8c8c;
            box-shadow: inset 3px 3px 0 #ffffff, inset -3px -3px 0 #6b6b6b;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .inventory-slot:hover,
        .inventory-hotbar .hotbar-slot:hover {
            border-color: #ffffff;
        }

        .inventory-slot.drag-target,
        .inventory-hotbar .hotbar-slot.drag-target {
            border-color: #ffe26d;
            box-shadow: 0 0 8px rgba(255, 226, 109, 0.8);
        }

        #inventoryTooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(16, 16, 16, 0.95);
            color: #fff;
            padding: 8px 10px;
            border: 2px solid #3f3f3f;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.6);
            font-size: 12px;
            display: none;
            z-index: 300;
            max-width: 240px;
            line-height: 1.2;
        }

        #inventoryTooltip .tooltip-title {
            margin-bottom: 4px;
        }

        #dragGhost {
            position: fixed;
            pointer-events: none;
            z-index: 400;
            width: 52px;
            height: 52px;
            display: none;
        }
        
        .menu-button {
            display: block;
            width: 440px;
            margin: 0;
            padding: 16px 18px;
            background: linear-gradient(#bfbfbf, #8f8f8f);
            color: #111;
            border: 2px solid #2a2a2a;
            font-family: 'Press Start 2P', 'Courier New', monospace;
            text-transform: none;
            cursor: pointer;
            text-shadow: 0 -1px 0 rgba(255, 255, 255, 0.35);
            box-shadow:
                inset 1px 1px 0 rgba(255, 255, 255, 0.35),
                inset -1px -1px 0 rgba(0, 0, 0, 0.35),
                0 6px 0 rgba(0, 0, 0, 0.35),
                0 10px 18px rgba(0, 0, 0, 0.45);
            transition: transform 0.08s ease, box-shadow 0.08s ease;
        }

        .menu-button:hover {
            background: linear-gradient(#cfcfcf, #9b9b9b);
        }

        .menu-button:active {
            transform: translateY(3px);
            box-shadow:
                inset -1px -1px 0 rgba(0, 0, 0, 0.45),
                inset 1px 1px 0 rgba(255, 255, 255, 0.25),
                0 2px 0 rgba(0, 0, 0, 0.35),
                0 6px 10px rgba(0, 0, 0, 0.5);
        }

        #pauseMenu .menu-button + .menu-button,
        #mainSettings .menu-button + .menu-button {
            margin-top: 14px;
        }
        #gameCanvas {
            position: fixed;
            inset: 0;
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.9);
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #clickHint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, calc(-50% + 60px));
            color: white;
            font-size: 18px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 101;
            display: none;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        #waterOverlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            background:
                radial-gradient(circle at 50% 35%, rgba(30,70,160,0.55) 0%, rgba(20,45,120,0.65) 35%, rgba(10,25,70,0.75) 100%),
                linear-gradient(180deg, rgba(10,25,80,0.6) 0%, rgba(6,18,60,0.85) 100%);
            mix-blend-mode: screen;
            opacity: 0;
            transition: opacity 0.25s ease;
            z-index: 90;
        }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 10px;
            font-family: 'Press Start 2P', 'Courier New', monospace;
            text-shadow: 2px 2px 0px black;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 0;
            border: 2px solid rgba(255,255,255,0.2);
        }
        #fps {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #0f0;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        #debugPanel {
            position: fixed;
            top: 50px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 12px;
            border: 2px solid #0f0;
            z-index: 1000;
            pointer-events: none;
            min-width: 220px;
            border-radius: 3px;
        }
        #debugPanel div {
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
        }
        #debugPanel .label {
            color: #888;
        }
        #debugPanel .value {
            color: #0f0;
            font-weight: bold;
        }
        #breakProgress {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #fff;
            display: none;
            z-index: 150;
        }
        #breakProgress .bar {
            height: 100%;
            background: #fff;
            width: 0%;
            transition: width 0.1s;
        }
        #pauseMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        #pauseMenu.visible {
            display: flex;
        }
        #pauseMenu h2 {
            color: #fff;
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px black;
        }
        .pause-info {
            color: #fff;
            margin-bottom: 24px;
            font-size: 18px;
            text-align: center;
            max-width: 420px;
        }
        .settings-panel {
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border: 3px solid #888;
            margin-bottom: 20px;
        }
        .setting-item {
            margin: 15px 0;
            color: #fff;
        }
        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 18px;
        }
        .setting-item input[type="range"] {
            width: 300px;
            cursor: pointer;
        }
        .setting-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #0f0;
        }
        .setting-select {
            width: 300px;
            padding: 5px;
            font-size: 16px;
            background: rgba(50,50,50,0.9);
            color: #fff;
            border: 2px solid #888;
            cursor: pointer;
        }
        .setting-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        #mainSettings {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                linear-gradient(180deg, rgba(71, 134, 201, 0.95) 0%, rgba(38, 66, 122, 0.97) 100%),
                repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.05) 0px, rgba(255, 255, 255, 0.05) 6px, rgba(0, 0, 0, 0.1) 6px, rgba(0, 0, 0, 0.1) 12px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(3px);
            z-index: 1000;
        }
        #mainSettings::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, rgba(255,255,255,0.08) 0%, rgba(0,0,0,0.65) 120%);
            pointer-events: none;
        }
        #mainSettings.visible {
            display: flex;
        }
        #mainSettings h1 {
            font-size: 48px;
            color: #fff;
            text-shadow: 6px 6px 0px #3f3f3f;
            margin-bottom: 30px;
            letter-spacing: 2px;
            position: relative;
            z-index: 1;
        }
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                repeating-linear-gradient(0deg, #4c3a28 0px, #4c3a28 8px, #3b2c1f 8px, #3b2c1f 16px),
                repeating-linear-gradient(90deg, #3b2c1f 0px, #3b2c1f 8px, #2b1f15 8px, #2b1f15 16px);
            image-rendering: pixelated;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        #loadingScreen.visible {
            display: flex;
        }
        #loadingScreen h2 {
            color: #e0e0e0;
            font-size: 28px;
            margin-bottom: 24px;
            text-shadow: 3px 3px 0 #1a120c;
            font-family: 'Press Start 2P', 'Courier New', monospace;
        }
        .loading-bar {
            width: 420px;
            max-width: 92vw;
            height: 24px;
            background: #4a4a4a;
            border: 3px solid #000;
            box-shadow:
                inset 2px 2px 0 #6f6f6f,
                inset -2px -2px 0 #2a2a2a,
                0 4px 0 #1a1a1a;
            overflow: hidden;
            image-rendering: pixelated;
        }
        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #5fbf46 0%, #7ee25f 100%);
            width: 0%;
            transition: width 0.3s;
        }
        .loading-text {
            color: #d9d9d9;
            margin-top: 12px;
            font-size: 14px;
            text-shadow: 2px 2px 0 #1a120c;
        }
        #deathScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(139, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }
        #deathScreen.visible {
            display: flex;
        }
        #deathScreen h2 {
            color: #fff;
            font-size: 64px;
            margin-bottom: 40px;
            text-shadow: 4px 4px 8px black;
            font-family: 'Press Start 2P', 'Courier New', monospace;
        }

        /* Settings Tabs */
        .settings-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            width: 100%;
            justify-content: center;
        }
        .settings-tab {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #6b6b6b;
            color: #aaa;
            cursor: pointer;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            transition: all 0.2s;
        }
        .settings-tab:hover {
            background: rgba(50, 50, 50, 0.8);
            color: #fff;
        }
        .settings-tab.active {
            background: #4a4a4a;
            border-color: #fff;
            color: #fff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }
        .settings-content {
            display: none;
            width: 100%;
            flex-direction: column;
            align-items: center;
        }
        .settings-content.active {
            display: flex;
        }
    </style>
</head>
<body>
    <div id="menu">
        <div class="menu-panel">
            <h1 class="menu-title">MINECRAFT</h1>
            <p class="menu-tagline">–í–∞—à –∫—É–±–∏—á–µ—Å–∫–∏–π –º–∏—Ä –∂–¥—ë—Ç</p>
            <div class="menu-buttons">
                <button class="menu-button" onclick="showWorldSelection()">–ò–≥—Ä–∞—Ç—å</button>
                <button class="menu-button" onclick="openMainSettings()">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
                <button class="menu-button" onclick="window.close()">–í—ã—Ö–æ–¥</button>
            </div>
        </div>
    </div>

    <div id="worldSelectionScreen" class="hidden">
        <div class="menu-panel">
            <h1 class="menu-title" style="font-size: 48px; transform: none; margin-bottom: 30px;">–í–´–ë–û–† –ú–ò–†–ê</h1>
            <div id="worldList" class="world-list">
                <!-- World items will be injected here -->
            </div>
            <div class="menu-buttons" style="flex-direction: row; gap: 10px; margin-top: 20px;">
                <button class="menu-button" style="width: auto;" onclick="createNewWorld()">–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –º–∏—Ä</button>
                <button class="menu-button" style="width: auto;" onclick="backToMainMenu()">–ù–∞–∑–∞–¥</button>
            </div>
        </div>
    </div>
    
    <div id="mainSettings">
        <h1>–ù–ê–°–¢–†–û–ô–ö–ò</h1>
        
        <div class="settings-tabs">
            <div class="settings-tab active" onclick="switchSettingsTab('graphics')">–ì–†–ê–§–ò–ö–ê</div>
            <div class="settings-tab" onclick="switchSettingsTab('sound')">–ó–í–£–ö</div>
            <div class="settings-tab" onclick="switchSettingsTab('optimization')">–û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø</div>
        </div>

        <div class="settings-panel">
            <!-- Graphics Tab -->
            <div id="tab-graphics" class="settings-content active">
                <div class="setting-item">
                    <label>–£—Ä–æ–≤–µ–Ω—å –≥—Ä–∞—Ñ–∏–∫–∏: <span class="setting-value" id="mainGraphicsPresetValue">–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è</span></label>
                    <select id="mainGraphicsPreset" class="setting-select">
                        <option value="low">–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è</option>
                        <option value="medium" selected>–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è</option>
                        <option value="high">–í—ã—Å–æ–∫–∞—è</option>
                        <option value="ultra">–£–ª—å—Ç—Ä–∞</option>
                    </select>
                </div>
                <div class="setting-item" style="display: none;">
                    <label>–ö–∞—á–µ—Å—Ç–≤–æ —Ç–µ–∫—Å—Ç—É—Ä: <span class="setting-value" id="mainTextureValue">–°—Ä–µ–¥–Ω–µ–µ (16x16)</span></label>
                    <select id="mainTextureQuality" class="setting-select">
                        <option value="low">–ù–∏–∑–∫–æ–µ (8x8)</option>
                        <option value="medium" selected>–°—Ä–µ–¥–Ω–µ–µ (16x16)</option>
                        <option value="high">–í—ã—Å–æ–∫–æ–µ (32x32)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label>–î–∞–ª—å–Ω–æ—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏: <span class="setting-value" id="mainRenderDistanceValue">4</span> —á–∞–Ω–∫–æ–≤</label>
                    <input type="range" id="mainRenderDistance" min="1" max="32" value="4">
                </div>
                <div class="setting-item">
                    <label>–ü–æ–ª–µ –∑—Ä–µ–Ω–∏—è (FOV): <span class="setting-value" id="mainFovValue">75</span></label>
                    <input type="range" id="mainFov" min="30" max="110" value="75">
                </div>
                <div class="setting-item">
                    <label><input type="checkbox" id="mainFogEnabled" class="setting-checkbox" checked> –¢—É–º–∞–Ω</label>
                </div>
                <div class="setting-item">
                    <label><input type="checkbox" id="mainSSAOEnabled" class="setting-checkbox"> SSAO (–¢–µ–Ω–∏ –≤ —É–≥–ª–∞—Ö)</label>
                </div>
                <div class="setting-item">
                    <label><input type="checkbox" id="mainFrustumCulling" class="setting-checkbox" checked> Frustum Culling (–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è)</label>
                </div>
            </div>

            <!-- Sound Tab -->
            <div id="tab-sound" class="settings-content">
                <div class="setting-item">
                    <label>–û–±—â–∞—è –≥—Ä–æ–º–∫–æ—Å—Ç—å: <span class="setting-value" id="mainVolumeValue">50</span>%</label>
                    <input type="range" id="mainVolume" min="0" max="100" value="50">
                </div>
                <div class="setting-item">
                    <label>–ú—É–∑—ã–∫–∞: <span class="setting-value" id="mainMusicVolumeValue">50</span>%</label>
                    <input type="range" id="mainMusicVolume" min="0" max="100" value="50">
                </div>
                <div class="setting-item">
                    <label>–≠—Ñ—Ñ–µ–∫—Ç—ã: <span class="setting-value" id="mainEffectsVolumeValue">50</span>%</label>
                    <input type="range" id="mainEffectsVolume" min="0" max="100" value="50">
                </div>
            </div>

            <!-- Optimization Tab -->
            <div id="tab-optimization" class="settings-content">
                <div class="setting-item">
                    <label>–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –º—ã—à–∏: <span class="setting-value" id="mainSensitivityValue">50</span>%</label>
                    <input type="range" id="mainSensitivity" min="10" max="100" value="50">
                </div>
                <div class="setting-item">
                    <label><input type="checkbox" id="mainShowFPS" class="setting-checkbox"> –ü–æ–∫–∞–∑–∞—Ç—å FPS</label>
                </div>
                <div class="setting-item">
                    <label><input type="checkbox" id="mainFlatBlocks" class="setting-checkbox"> –ü–ª–æ—Å–∫–∏–µ –±–ª–æ–∫–∏ (2D)</label>
                </div>
            </div>
        </div>
        
        <button class="menu-button" onclick="saveMainSettings()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</button>
        <button class="menu-button" onclick="closeMainSettings()">–ù–∞–∑–∞–¥</button>
    </div>
    
    <div id="loadingScreen">
        <h2>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –º–∏—Ä–∞...</h2>
        <div class="loading-bar">
            <div class="loading-fill" id="loadingFill"></div>
        </div>
        <div class="loading-text" id="loadingText">–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...</div>
    </div>
    
    <div id="deathScreen">
        <h2>–í–´ –ü–û–ì–ò–ë–õ–ò</h2>
        <button class="menu-button" onclick="respawnPlayer()">–í–æ–∑—Ä–æ–¥–∏—Ç—å—Å—è</button>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="waterOverlay"></div>
    <div id="crosshair"></div>
    <div id="clickHint">üñ±Ô∏è –ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</div>
    <div id="fps">FPS: 0</div>
    <div id="debugPanel" style="display: none;">
        <div><span class="label">–ß–∞–Ω–∫–∏:</span><span class="value" id="chunksInfo">0/0</span></div>
        <div><span class="label">–ë–ª–æ–∫–∏:</span><span class="value" id="blocksInfo">0</span></div>
        <div><span class="label">–ó–æ–º–±–∏:</span><span class="value" id="zombiesInfo">0</span></div>
        <div><span class="label">–ñ–∏–≤–æ—Ç–Ω—ã–µ:</span><span class="value" id="animalsInfo">0</span></div>
        <div><span class="label">Draw Calls:</span><span class="value" id="drawCallsInfo">0</span></div>
        <div><span class="label">–ü–æ–∑–∏—Ü–∏—è:</span><span class="value" id="posInfo">0,0,0</span></div>
        <div><span class="label">LOD:</span><span class="value" id="lodInfo">-</span></div>
    </div>
    <div id="info">
        WASD - –¥–≤–∏–∂–µ–Ω–∏–µ | –ü—Ä–æ–±–µ–ª - –ø—Ä—ã–∂–æ–∫<br>
        –õ–ö–ú (–¥–µ—Ä–∂–∞—Ç—å) - –ª–æ–º–∞—Ç—å | –ü–ö–ú - —Å—Ç–∞–≤–∏—Ç—å<br>
        1-0 - –≤—ã–±–æ—Ä –±–ª–æ–∫–∞ | E - –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å<br>
        Shift - —Å–ø—Ä–∏–Ω—Ç / –Ω—ã—Ä–Ω—É—Ç—å<br>
        F1 - –º–µ–Ω—é | F2 - –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞
    </div>
    
    <div id="hud">
        <div class="hud-hotbar">
            <div class="hotbar-status">
                <div id="heartsRow" class="status-row hearts-row">
                    <div class="heart-icon inactive"></div>
                    <div class="heart-icon inactive"></div>
                    <div class="heart-icon inactive"></div>
                    <div class="heart-icon inactive"></div>
                    <div class="heart-icon inactive"></div>
                    <div class="heart-icon inactive"></div>
                    <div class="heart-icon inactive"></div>
                    <div class="heart-icon inactive"></div>
                    <div class="heart-icon inactive"></div>
                    <div class="heart-icon inactive"></div>
                </div>
                <div class="hotbar-meta" id="xpIndicator">LV 1</div>
                <div id="hungerRow" class="status-row hunger-row">
                    <div class="hunger-icon inactive"></div>
                    <div class="hunger-icon inactive"></div>
                    <div class="hunger-icon inactive"></div>
                    <div class="hunger-icon inactive"></div>
                    <div class="hunger-icon inactive"></div>
                    <div class="hunger-icon inactive"></div>
                    <div class="hunger-icon inactive"></div>
                    <div class="hunger-icon inactive"></div>
                    <div class="hunger-icon inactive"></div>
                    <div class="hunger-icon inactive"></div>
                </div>
            </div>
            <div class="hotbar-shell">
                <div class="hotbar-slots" id="hotbarSlots"></div>
            </div>
        </div>
    </div>
    
    <div id="inventory">
        <div class="inventory-window">
            <div class="inventory-header">
                <div class="inventory-title">–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</div>
                <button class="inventory-close" id="inventoryCloseBtn" aria-label="–ó–∞–∫—Ä—ã—Ç—å">‚úï</button>
            </div>
            <div class="inventory-body">
                <div class="inventory-preview">
                    <div class="preview-frame">
                        <div class="preview-character" id="playerPreview"></div>
                    </div>
                </div>
                <div class="inventory-main">
                    <div class="inventory-sidebar" id="inventoryTabs"></div>
                    <div class="inventory-content">
                        <div class="inventory-grid" id="inventoryGrid"></div>
                        <div class="inventory-hotbar" id="inventoryHotbar"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="inventoryTooltip" role="tooltip" hidden>
        <div class="tooltip-title" id="tooltipTitle"></div>
        <div class="tooltip-desc" id="tooltipDesc"></div>
    </div>
    <div id="dragGhost" hidden></div>
    
    <div id="breakProgress">
        <div class="bar"></div>
    </div>
    
    <div id="pauseMenu">
        <h2>–ü–ê–£–ó–ê</h2>
        <p class="pause-info">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∏ –¥–æ—Å—Ç—É–ø–Ω—ã –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é.</p>
        <button class="menu-button" onclick="saveWorld()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –º–∏—Ä</button>
        <button class="menu-button" onclick="resumeGame()" id="resumeBtn">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
        <button class="menu-button" onclick="backToMenu()" id="backToMenuBtn">–í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
    
    <!-- Post-processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/math/SimplexNoise.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/SSAOShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/SSAOPass.js"></script>

    <!-- –î–æ–±–∞–≤–ª—è–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É —à—É–º–∞ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ª–∞–Ω–¥—à–∞—Ñ—Ç–∞ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <!-- –î–æ–±–∞–≤–ª—è–µ–º Cannon.js –¥–ª—è —Ñ–∏–∑–∏–∫–∏ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- –î–æ–±–∞–≤–ª—è–µ–º Alea –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª -->
    <script src="https://cdn.jsdelivr.net/npm/alea@1.0.0/alea.min.js"></script>
    <!-- –î–æ–±–∞–≤–ª—è–µ–º PeerJS –¥–ª—è –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞ -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Three.js
        if (typeof THREE === 'undefined') {
            alert('–û–®–ò–ë–ö–ê: Three.js –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ.');
            console.error('Three.js –Ω–µ –Ω–∞–π–¥–µ–Ω!');
        } else {
            console.log('‚úì Three.js –∑–∞–≥—Ä—É–∂–µ–Ω, –≤–µ—Ä—Å–∏—è:', THREE.REVISION);
        }
        
        let scene, camera, renderer, canvas;
        let composer, bloomPass, ssaoPass; // Post-processing
        const waterOverlay = document.getElementById('waterOverlay');
        let player = {
            position: new THREE.Vector3(0, 50, 15), // –í—Ä–µ–º–µ–Ω–Ω–æ –≤—ã—Å–æ–∫–æ, –ø–æ—Ç–æ–º –æ–ø—É—Å—Ç–∏–º
            rotation: new THREE.Euler(-0.3, 0, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            onGround: false,
            selectedSlot: 0,
            inWater: false,
            fallStartY: null,
            wasOnGround: false,
            physicsBody: null // Cannon.js —Ç–µ–ª–æ
        };
        let controls = {};
        let mouse = { x: 0, y: 0 };
        let rightMouseHeld = false;
        let leftMouseHeld = false;
        let gameStarted = false;
        let pointerLocked = false;
        let inventoryOpen = false;
        const HOTBAR_SIZE = 9;
        const INVENTORY_COLUMNS = 9;
        const INVENTORY_ROWS = 4;
        const INVENTORY_SLOT_COUNT = INVENTORY_COLUMNS * INVENTORY_ROWS;
        const RARITY_COLORS = {
            common: '#d8d8d8',
            uncommon: '#6bd769',
            rare: '#4c74ff',
            epic: '#c84bff',
            legendary: '#f5a623',
            mythical: '#f24387'
        };
        const INVENTORY_CATEGORIES = [
            { id: 'blocks', name: '–ë–ª–æ–∫–∏' },
            { id: 'items', name: '–ü—Ä–µ–¥–º–µ—Ç—ã' },
            { id: 'food', name: '–ï–¥–∞' },
            { id: 'entities', name: '–°—É—â–µ—Å—Ç–≤–∞' },
            { id: 'biomes', name: '–ë–∏–æ–º—ã' },
            { id: 'effects', name: '–≠—Ñ—Ñ–µ–∫—Ç—ã' },
            { id: 'enchantments', name: '–ß–∞—Ä—ã' },
            { id: 'particles', name: '–ß–∞—Å—Ç–∏—Ü—ã' }
        ];
        const DEFAULT_ICON_COLORS = {
            blocks: '#6fae4f',
            items: '#d2a74f',
            food: '#ff976d',
            entities: '#a05bff',
            biomes: '#4bbac1',
            effects: '#ff5c8d',
            enchantments: '#4f7bff',
            particles: '#f0f36b'
        };
        const ITEM_DEFINITIONS = {
            grass: { id: 'grass', name: '–ë–ª–æ–∫ —Ç—Ä–∞–≤—ã', category: 'blocks', rarity: 'common', maxStack: 64, description: '–û—Å–Ω–æ–≤–Ω–æ–π –±–ª–æ–∫ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏.', textureKey: 'grass_top' },
            dirt: { id: 'dirt', name: '–ó–µ–º–ª—è', category: 'blocks', rarity: 'common', maxStack: 64, description: '–ü–æ–ª–µ–∑–Ω–∞ –¥–ª—è –ø–æ—Å–∞–¥–∫–∏ —Ä–∞—Å—Ç–µ–Ω–∏–π.', textureKey: 'dirt' },
            stone: { id: 'stone', name: '–ö–∞–º–µ–Ω—å', category: 'blocks', rarity: 'common', maxStack: 64, description: '–ü—Ä–æ—á–Ω—ã–π —Å—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã–π –±–ª–æ–∫.', textureKey: 'stone' },
            wood: { id: 'wood', name: '–î–æ—Å–∫–∏', category: 'blocks', rarity: 'common', maxStack: 64, description: '–î–µ—Ä–µ–≤—è–Ω–Ω—ã–µ –¥–æ—Å–∫–∏ –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–∫.', textureKey: 'wood_top' },
            leaves: { id: 'leaves', name: '–õ–∏—Å—Ç–≤–∞', category: 'blocks', rarity: 'common', maxStack: 64, description: '–î–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–π –±–ª–æ–∫ –∫—Ä–æ–Ω—ã.', textureKey: 'leaves' },
            sand: { id: 'sand', name: '–ü–µ—Å–æ–∫', category: 'blocks', rarity: 'common', maxStack: 64, description: '–°—ã–ø—É—á–∏–π –±–ª–æ–∫ –¥–ª—è —Å—Ç–µ–∫–ª–∞.', textureKey: 'sand' },
            cactus: { id: 'cactus', name: '–ö–∞–∫—Ç—É—Å', category: 'blocks', rarity: 'uncommon', maxStack: 64, description: '–û–ø–∞—Å–µ–Ω –Ω–∞ –æ—â—É–ø—å!', textureKey: 'cactus' },
            torch: { id: 'torch', name: '–§–∞–∫–µ–ª', category: 'items', rarity: 'common', maxStack: 64, description: '–û—Å–≤–µ—â–∞–µ—Ç —Ç—ë–º–Ω—ã–µ –º–µ—Å—Ç–∞.', iconColor: '#f1c40f' },
            stick: { id: 'stick', name: '–ü–∞–ª–∫–∞', category: 'items', rarity: 'common', maxStack: 64, description: '–ë–∞–∑–æ–≤—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –∫—Ä–∞—Ñ—Ç–∞.', iconColor: '#c49a6c' },
            pickaxe: { id: 'pickaxe', name: '–ö–∞–º–µ–Ω–Ω–∞—è –∫–∏—Ä–∫–∞', category: 'items', rarity: 'uncommon', maxStack: 1, description: '–î–ª—è –¥–æ–±—ã—á–∏ –∫–∞–º–Ω—è –∏ —Ä—É–¥—ã.', iconColor: '#b0b0b0' },
            sword: { id: 'sword', name: '–ö–∞–º–µ–Ω–Ω—ã–π –º–µ—á', category: 'items', rarity: 'uncommon', maxStack: 1, description: '–ë–ª–∏–∂–Ω–∏–π –±–æ–π.', iconColor: '#858585' },
            zombie_spawn: { id: 'zombie_spawn', name: '–Ø–π—Ü–æ –ø—Ä–∏–∑—ã–≤–∞: –∑–æ–º–±–∏', category: 'entities', rarity: 'rare', maxStack: 16, description: '–ü—Ä–∏–∑—ã–≤–∞–µ—Ç –∑–æ–º–±–∏.', iconColor: '#5c9c3c' },
            cow_spawn: { id: 'cow_spawn', name: '–Ø–π—Ü–æ –ø—Ä–∏–∑—ã–≤–∞: –∫–æ—Ä–æ–≤–∞', category: 'entities', rarity: 'rare', maxStack: 16, description: '–ü—Ä–∏–∑—ã–≤–∞–µ—Ç –∫–æ—Ä–æ–≤—É.', iconColor: '#b3a18a' },
            plains_map: { id: 'plains_map', name: '–ö–∞—Ä—Ç–∞ —Ä–∞–≤–Ω–∏–Ω', category: 'biomes', rarity: 'uncommon', maxStack: 1, description: '–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –±–∏–æ–º—É —Ä–∞–≤–Ω–∏–Ω.', iconColor: '#76c76e' },
            desert_map: { id: 'desert_map', name: '–ö–∞—Ä—Ç–∞ –ø—É—Å—Ç—ã–Ω–∏', category: 'biomes', rarity: 'uncommon', maxStack: 1, description: '–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –±–∏–æ–º—É –ø—É—Å—Ç—ã–Ω–∏.', iconColor: '#e0c071' },
            haste: { id: 'haste', name: '–≠—Ñ—Ñ–µ–∫—Ç: –£—Å–∫–æ—Ä–µ–Ω–∏–µ', category: 'effects', rarity: 'rare', maxStack: 1, description: '–ü–æ–≤—ã—à–∞–µ—Ç —Å–∫–æ—Ä–æ—Å—Ç—å –∫–æ–ø–∞–Ω–∏—è.', iconColor: '#ffe26d' },
            night_vision: { id: 'night_vision', name: '–≠—Ñ—Ñ–µ–∫—Ç: –ù–æ—á–Ω–æ–µ –∑—Ä–µ–Ω–∏–µ', category: 'effects', rarity: 'rare', maxStack: 1, description: '–î–µ–ª–∞–µ—Ç –Ω–æ—á—å —Å–≤–µ—Ç–ª–æ–π.', iconColor: '#4cc3ff' },
            sharpness: { id: 'sharpness', name: '–ß–∞—Ä—ã: –û—Å—Ç—Ä–æ—Ç–∞', category: 'enchantments', rarity: 'epic', maxStack: 1, description: '–î–æ–±–∞–≤–ª—è–µ—Ç —É—Ä–æ–Ω –æ—Ä—É–∂–∏—é.', iconColor: '#9c5cff' },
            efficiency: { id: 'efficiency', name: '–ß–∞—Ä—ã: –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å', category: 'enchantments', rarity: 'epic', maxStack: 1, description: '–£—Å–∫–æ—Ä—è–µ—Ç –¥–æ–±—ã—á—É.', iconColor: '#5e9cff' },
            flame_particle: { id: 'flame_particle', name: '–ß–∞—Å—Ç–∏—Ü–∞: –ü–ª–∞–º—è', category: 'particles', rarity: 'legendary', maxStack: 64, description: '–Ø—Ä–∫–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ –æ–≥–Ω—è.', iconColor: '#ff7043' },
            sparkle_particle: { id: 'sparkle_particle', name: '–ß–∞—Å—Ç–∏—Ü–∞: –ò—Å–∫—Ä—ã', category: 'particles', rarity: 'legendary', maxStack: 64, description: '–ó–∞–≥–∞–¥–æ—á–Ω—ã–µ —Å–∏—è–Ω–∏—è.', iconColor: '#ffd166' },
            porkchop_raw: { id: 'porkchop_raw', name: '–°—ã—Ä–∞—è —Å–≤–∏–Ω–∏–Ω–∞', category: 'food', rarity: 'common', maxStack: 16, description: '–°–æ—á–Ω–∞—è —Å–≤–∏–Ω–∏–Ω–∞. –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç 4 –µ–¥–∏–Ω–∏—Ü—ã —Å—ã—Ç–æ—Å—Ç–∏.', hungerRestore: 4, iconColor: '#ffb4a2' }
        };

        const inventoryState = {
            categories: {},
            hotbar: Array.from({ length: HOTBAR_SIZE }, () => null)
        };
        let activeInventoryCategory = 'blocks';
        const iconCache = new Map();
        const textures = {};
        const dragState = {
            active: false,
            source: null,
            stack: null,
            pointerId: null,
            highlightEl: null
        };
        const inventoryUIRefs = {
            hotbarSlots: null,
            inventoryGrid: null,
            inventoryHotbar: null,
            inventoryTabs: null,
            tooltip: null,
            tooltipTitle: null,
            tooltipDesc: null,
            dragGhost: null,
            inventoryRoot: null
        };
        let cursorStack = null;
        const cursorPosition = { x: 0, y: 0 };
        let tooltipTimer = null;

        const soundManager = (() => {
            const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
            let context = null;
            let unlocked = false;
            const pending = [];
            let musicTimer = null;
            let globalVolume = 0.5;
            let musicVolume = 0.5;
            let effectsVolume = 0.5;
            
            // C418-style Pentatonic Scale (C Major / A Minorish)
            // C3, D3, E3, G3, A3, C4, D4, E4
            const MUSIC_NOTES = [130.81, 146.83, 164.81, 196.00, 220.00, 261.63, 293.66, 329.63];

            function ensureContext() {
                if (!context && AudioContextCtor) {
                    context = new AudioContextCtor({ latencyHint: 'interactive' });
                    // Master Gain
                    const masterGain = context.createGain();
                    masterGain.gain.value = globalVolume;
                    masterGain.connect(context.destination);
                    context.masterGain = masterGain;
                }
            }

            function getContext() {
                ensureContext();
                return context;
            }

            function runWithContext(action) {
                const ctx = getContext();
                if (!ctx) return;
                if (!unlocked) {
                    pending.push(() => action(ctx));
                    return;
                }
                action(ctx);
            }

            function createEnvelopeGain(ctx, duration, peak = 0.6, attack = 0.005, release = 0.18) {
                const gainNode = ctx.createGain();
                const now = ctx.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(peak * effectsVolume, now + attack);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + attack + release);
                return { node: gainNode, stopTime: now + attack + release + 0.1 };
            }

            function getNoiseBuffer(ctx, duration = 0.35) {
                const length = Math.floor(ctx.sampleRate * duration);
                const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                return buffer;
            }

            function playMusicNote(ctx) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                // Soft sine wave for calm piano/pad feel
                osc.type = 'sine';
                const freq = MUSIC_NOTES[Math.floor(Math.random() * MUSIC_NOTES.length)];
                osc.frequency.value = freq;
                
                // Envelope: Very soft attack (2s), very long release (6s)
                const now = ctx.currentTime;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.15 * musicVolume, now + 2); 
                gain.gain.exponentialRampToValueAtTime(0.001, now + 8);
                
                // Simple Delay for Echo/Reverb feel
                const delay = ctx.createDelay();
                delay.delayTime.value = 0.4;
                const delayGain = ctx.createGain();
                delayGain.gain.value = 0.3;
                
                osc.connect(gain);
                gain.connect(ctx.masterGain);
                gain.connect(delay);
                delay.connect(delayGain);
                delayGain.connect(ctx.masterGain);
                delayGain.connect(delay); // Feedback loop
                
                osc.start();
                osc.stop(now + 9);
                
                // Schedule next note randomly between 2s and 6s
                const nextDelay = 2000 + Math.random() * 4000;
                musicTimer = setTimeout(() => playMusicNote(ctx), nextDelay);
            }

            const SOUND_LIBRARY = {
                ui_open(ctx) {
                    // Click sound
                    const osc = ctx.createOscillator();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(800, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.05);
                    const { node, stopTime } = createEnvelopeGain(ctx, 0.05, 0.2, 0.001, 0.04);
                    osc.connect(node);
                    node.connect(ctx.masterGain);
                    osc.start();
                    osc.stop(stopTime);
                },
                ui_close(ctx) {
                    const osc = ctx.createOscillator();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(600, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(300, ctx.currentTime + 0.05);
                    const { node, stopTime } = createEnvelopeGain(ctx, 0.05, 0.2, 0.001, 0.04);
                    osc.connect(node);
                    node.connect(ctx.masterGain);
                    osc.start();
                    osc.stop(stopTime);
                },
                ui_click(ctx) {
                    // Sharp click
                    const osc = ctx.createOscillator();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(1200, ctx.currentTime);
                    const { node, stopTime } = createEnvelopeGain(ctx, 0.03, 0.15, 0.001, 0.02);
                    osc.connect(node);
                    node.connect(ctx.masterGain);
                    osc.start();
                    osc.stop(stopTime);
                },
                block_break(ctx, options = {}) {
                    const source = ctx.createBufferSource();
                    source.buffer = getNoiseBuffer(ctx, 0.15);
                    const filter = ctx.createBiquadFilter();
                    
                    if (options.material === 'stone') {
                        filter.type = 'highpass';
                        filter.frequency.value = 800;
                        source.playbackRate.value = 1.2;
                    } else if (options.material === 'wood') {
                        filter.type = 'bandpass';
                        filter.frequency.value = 400;
                        source.playbackRate.value = 0.9;
                    } else { // Dirt/Grass
                        filter.type = 'lowpass';
                        filter.frequency.value = 600;
                        source.playbackRate.value = 0.8;
                    }
                    
                    const { node, stopTime } = createEnvelopeGain(ctx, 0.15, 0.4, 0.01, 0.1);
                    source.connect(filter);
                    filter.connect(node);
                    node.connect(ctx.masterGain);
                    source.start();
                    source.stop(stopTime);
                },
                block_place(ctx, options = {}) {
                    const source = ctx.createBufferSource();
                    source.buffer = getNoiseBuffer(ctx, 0.1);
                    const filter = ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = options.material === 'stone' ? 1200 : 600;
                    
                    const { node, stopTime } = createEnvelopeGain(ctx, 0.1, 0.5, 0.005, 0.05);
                    source.connect(filter);
                    filter.connect(node);
                    node.connect(ctx.masterGain);
                    source.start();
                    source.stop(stopTime);
                },
                footstep(ctx, options = {}) {
                    const source = ctx.createBufferSource();
                    source.buffer = getNoiseBuffer(ctx, 0.05);
                    const filter = ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = options.material === 'stone' ? 1000 : 500;
                    
                    const { node, stopTime } = createEnvelopeGain(ctx, 0.05, 0.15, 0.005, 0.03);
                    source.connect(filter);
                    filter.connect(node);
                    node.connect(ctx.masterGain);
                    source.start();
                    source.stop(stopTime);
                },
                item_pickup(ctx) {
                    // "Pop" sound
                    const osc = ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, ctx.currentTime);
                    osc.frequency.linearRampToValueAtTime(700, ctx.currentTime + 0.08);
                    const { node, stopTime } = createEnvelopeGain(ctx, 0.08, 0.3, 0.005, 0.05);
                    osc.connect(node);
                    node.connect(ctx.masterGain);
                    osc.start();
                    osc.stop(stopTime);
                },
                player_jump(ctx) {
                    // No sound for jump
                },
                player_hurt(ctx) {
                    // "Oof" sound - descending saw/lowpass
                    const osc = ctx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.25);
                    
                    const filter = ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(800, ctx.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(300, ctx.currentTime + 0.25);

                    const { node, stopTime } = createEnvelopeGain(ctx, 0.25, 0.5, 0.01, 0.1);
                    
                    osc.connect(filter);
                    filter.connect(node);
                    node.connect(ctx.masterGain);
                    
                    osc.start();
                    osc.stop(stopTime);
                },
                player_death(ctx) {
                    // Descending tone
                    const osc = ctx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.8);
                    const { node, stopTime } = createEnvelopeGain(ctx, 0.8, 0.5, 0.01, 0.6);
                    osc.connect(node);
                    node.connect(ctx.masterGain);
                    osc.start();
                    osc.stop(stopTime);
                },
                pig_say(ctx) {
                    const osc = ctx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.15);
                    const { node, stopTime } = createEnvelopeGain(ctx, 0.15, 0.3, 0.01, 0.1);
                    osc.connect(node);
                    node.connect(ctx.masterGain);
                    osc.start();
                    osc.stop(stopTime);
                },
                pig_death(ctx) {
                    const osc = ctx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(500, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.6);
                    const { node, stopTime } = createEnvelopeGain(ctx, 0.6, 0.4, 0.01, 0.5);
                    osc.connect(node);
                    node.connect(ctx.masterGain);
                    osc.start();
                    osc.stop(stopTime);
                },
                pig_hurt(ctx) {
                    const osc = ctx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(400, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.2);
                    const { node, stopTime } = createEnvelopeGain(ctx, 0.2, 0.4, 0.01, 0.15);
                    osc.connect(node);
                    node.connect(ctx.masterGain);
                    osc.start();
                    osc.stop(stopTime);
                }
            };

            function startAmbientLoop() {
                runWithContext((ctx) => {
                    if (musicTimer) return;
                    playMusicNote(ctx);
                });
            }

            function stopAmbientLoop() {
                if (musicTimer) {
                    clearTimeout(musicTimer);
                    musicTimer = null;
                }
            }

            return {
                unlock() {
                    const ctx = getContext();
                    if (!ctx) return;
                    if (ctx.state === 'suspended') ctx.resume();
                    unlocked = true;
                    while (pending.length) {
                        const action = pending.shift();
                        action?.();
                    }
                },
                play(name, options) {
                    if (!SOUND_LIBRARY[name]) return;
                    runWithContext((ctx) => SOUND_LIBRARY[name](ctx, options));
                },
                startAmbience() {
                    startAmbientLoop();
                },
                stopAmbience() {
                    stopAmbientLoop();
                },
                setVolume(value) {
                    globalVolume = Math.max(0, Math.min(1, value));
                    if (context && context.masterGain) {
                        context.masterGain.gain.setTargetAtTime(globalVolume, context.currentTime, 0.1);
                    }
                },
                setMusicVolume(vol) {
                    musicVolume = Math.max(0, Math.min(1, vol));
                },
                setEffectsVolume(vol) {
                    effectsVolume = Math.max(0, Math.min(1, vol));
                }
            };
        })();

        const STEP_DISTANCE_DEFAULT = 0.55;
        const STEP_DISTANCE_SPRINT = 0.38;
        const STEP_DISTANCE_SNEAK = 0.75;
        let stepAccumulator = 0;

        // === STEVE PREVIEW SYSTEM ===
        class StevePreview {
            constructor(containerId) {
                this.initialized = false;
                try {
                    this.container = document.getElementById(containerId);
                    if (!this.container) {
                        console.warn('StevePreview: Container not found:', containerId);
                        return;
                    }

                    this.scene = new THREE.Scene();
                    this.scene.background = new THREE.Color(0x9c9c9c);

                    const width = this.container.clientWidth || 160;
                    const height = this.container.clientHeight || 220;

                    this.camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 100);
                    this.camera.position.set(0, 0, 3.5);
                    this.camera.lookAt(0, 0, 0);

                    this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                    this.renderer.setSize(width, height);
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                    this.container.appendChild(this.renderer.domElement);

                    const ambient = new THREE.AmbientLight(0xffffff, 0.7);
                    this.scene.add(ambient);
                    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    dirLight.position.set(2, 5, 3);
                    this.scene.add(dirLight);

                    this.steve = new THREE.Group();
                    this.scene.add(this.steve);
                    this.buildSteve();

                    this.isAnimating = false;
                    this.time = 0;
                    
                    this.mouseX = 0;
                    this.targetRotation = 0;
                    this.container.addEventListener('mousemove', (e) => {
                        const rect = this.container.getBoundingClientRect();
                        if (rect.width > 0) {
                            this.mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                            this.targetRotation = this.mouseX * 0.5;
                        }
                    });
                    this.container.addEventListener('mouseleave', () => {
                        this.targetRotation = 0;
                    });

                    this.animate = this.animate.bind(this);
                    this.initialized = true;
                } catch (e) {
                    console.error('StevePreview init error:', e);
                }
            }

            buildSteve() {
                if (!this.steve) return;
                try {
                    const skinMat = new THREE.MeshLambertMaterial({ color: 0xeebb88 });
                    const shirtMat = new THREE.MeshLambertMaterial({ color: 0x00aaaa });
                    const pantsMat = new THREE.MeshLambertMaterial({ color: 0x3333cc });
                    const hairMat = new THREE.MeshLambertMaterial({ color: 0x2a1a0a });
                    const whiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const pupilMat = new THREE.MeshBasicMaterial({ color: 0x3333cc });

                    const headGroup = new THREE.Group();
                    const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                    const head = new THREE.Mesh(headGeo, skinMat);
                    headGroup.add(head);

                    const hairGeo = new THREE.BoxGeometry(0.52, 0.15, 0.52);
                    const hair = new THREE.Mesh(hairGeo, hairMat);
                    hair.position.y = 0.18;
                    headGroup.add(hair);

                    const eyeWhiteGeo = new THREE.PlaneGeometry(0.12, 0.06);
                    const eyePupilGeo = new THREE.PlaneGeometry(0.06, 0.06);
                    
                    const leftEye = new THREE.Mesh(eyeWhiteGeo, whiteMat);
                    leftEye.position.set(-0.12, 0.0, 0.251);
                    headGroup.add(leftEye);
                    const leftPupil = new THREE.Mesh(eyePupilGeo, pupilMat);
                    leftPupil.position.set(-0.09, 0.0, 0.252);
                    headGroup.add(leftPupil);

                    const rightEye = new THREE.Mesh(eyeWhiteGeo, whiteMat);
                    rightEye.position.set(0.12, 0.0, 0.251);
                    headGroup.add(rightEye);
                    const rightPupil = new THREE.Mesh(eyePupilGeo, pupilMat);
                    rightPupil.position.set(0.09, 0.0, 0.252);
                    headGroup.add(rightPupil);

                    headGroup.position.y = 0.75;
                    this.steve.add(headGroup);
                    this.head = headGroup;

                    const bodyGeo = new THREE.BoxGeometry(0.5, 0.75, 0.25);
                    const body = new THREE.Mesh(bodyGeo, shirtMat);
                    body.position.y = 0.125;
                    this.steve.add(body);

                    const armGeo = new THREE.BoxGeometry(0.25, 0.75, 0.25);
                    
                    this.leftArm = new THREE.Group();
                    const leftArmMesh = new THREE.Mesh(armGeo, skinMat);
                    leftArmMesh.position.y = -0.25;
                    const sleeveGeo = new THREE.BoxGeometry(0.26, 0.3, 0.26);
                    const leftSleeve = new THREE.Mesh(sleeveGeo, shirtMat);
                    leftSleeve.position.y = 0.2;
                    leftArmMesh.add(leftSleeve);
                    
                    this.leftArm.add(leftArmMesh);
                    this.leftArm.position.set(-0.38, 0.5, 0);
                    this.steve.add(this.leftArm);

                    this.rightArm = new THREE.Group();
                    const rightArmMesh = new THREE.Mesh(armGeo, skinMat);
                    rightArmMesh.position.y = -0.25;
                    const rightSleeve = new THREE.Mesh(sleeveGeo, shirtMat);
                    rightSleeve.position.y = 0.2;
                    rightArmMesh.add(rightSleeve);

                    this.rightArm.add(rightArmMesh);
                    this.rightArm.position.set(0.38, 0.5, 0);
                    this.steve.add(this.rightArm);

                    const legGeo = new THREE.BoxGeometry(0.25, 0.75, 0.25);
                    
                    this.leftLeg = new THREE.Mesh(legGeo, pantsMat);
                    this.leftLeg.position.set(-0.125, -0.625, 0);
                    this.steve.add(this.leftLeg);

                    this.rightLeg = new THREE.Mesh(legGeo, pantsMat);
                    this.rightLeg.position.set(0.125, -0.625, 0);
                    this.steve.add(this.rightLeg);
                } catch (e) {
                    console.error('StevePreview build error:', e);
                }
            }

            start() {
                if (!this.initialized || this.isAnimating) return;
                this.isAnimating = true;
                this.resize();
                this.animate();
            }

            stop() {
                this.isAnimating = false;
            }

            resize() {
                if (!this.initialized || !this.container) return;
                const width = this.container.clientWidth || 160;
                const height = this.container.clientHeight || 220;
                if (this.camera) {
                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                }
                if (this.renderer) {
                    this.renderer.setSize(width, height);
                }
            }

            animate() {
                if (!this.isAnimating || !this.initialized) return;
                requestAnimationFrame(this.animate);

                this.time += 0.05;

                if (this.steve) {
                    this.steve.rotation.y += (this.targetRotation - this.steve.rotation.y) * 0.1;
                    
                    const breath = Math.sin(this.time * 0.5) * 0.02;
                    this.steve.scale.set(1, 1 + breath * 0.5, 1);
                    this.steve.position.y = breath;

                    const sway = Math.sin(this.time * 0.5) * 0.05;
                    if (this.leftArm) {
                        this.leftArm.rotation.z = sway + 0.1;
                        this.leftArm.rotation.x = sway * 0.5;
                    }
                    if (this.rightArm) {
                        this.rightArm.rotation.z = -sway - 0.1;
                        this.rightArm.rotation.x = -sway * 0.5;
                    }

                    if (this.head) {
                        this.head.rotation.y = Math.sin(this.time * 0.3) * 0.1 + (this.mouseX * 0.5);
                        this.head.rotation.x = Math.sin(this.time * 0.2) * 0.05;
                    }
                }

                if (this.renderer && this.scene && this.camera) {
                    this.renderer.render(this.scene, this.camera);
                }
            }
        }
        let stevePreview = null;

        function getItemDefinition(itemId) {
            return ITEM_DEFINITIONS[itemId] || null;
        }

        function ensureCategoryStorage(categoryId) {
            if (!inventoryState.categories[categoryId]) {
                inventoryState.categories[categoryId] = Array.from({ length: INVENTORY_SLOT_COUNT }, () => null);
            }
            return inventoryState.categories[categoryId];
        }

        function createItemStack(itemId, quantity = 1) {
            const definition = getItemDefinition(itemId);
            if (!definition) {
                return null;
            }
            const maxStack = definition.maxStack || 64;
            const qty = Math.min(maxStack, Math.max(1, Math.floor(quantity)));
            return {
                id: definition.id,
                name: definition.name,
                qty,
                maxStack,
                icon: getIconDataUrl(definition.id)
            };
        }

        function cloneStack(stack) {
            if (!stack) {
                return null;
            }
            const definition = getItemDefinition(stack.id);
            return {
                id: stack.id,
                name: stack.name || definition?.name || stack.id,
                qty: stack.qty,
                maxStack: stack.maxStack ?? (definition ? definition.maxStack || 64 : 64),
                icon: stack.icon || getIconDataUrl(stack.id)
            };
        }

        function initializeInventoryState() {
            INVENTORY_CATEGORIES.forEach((category) => {
                const storage = ensureCategoryStorage(category.id);
                storage.fill(null);
            });

            inventoryState.hotbar.length = HOTBAR_SIZE;
            for (let i = 0; i < HOTBAR_SIZE; i++) {
                inventoryState.hotbar[i] = null;
            }
        }

        function initializeInventoryUI() {
            inventoryUIRefs.inventoryRoot = document.getElementById('inventory');
            inventoryUIRefs.hotbarSlots = document.getElementById('hotbarSlots');
            inventoryUIRefs.inventoryGrid = document.getElementById('inventoryGrid');
            inventoryUIRefs.inventoryHotbar = document.getElementById('inventoryHotbar');
            inventoryUIRefs.inventoryTabs = document.getElementById('inventoryTabs');
            inventoryUIRefs.tooltip = document.getElementById('inventoryTooltip');
            inventoryUIRefs.tooltipTitle = document.getElementById('tooltipTitle');
            inventoryUIRefs.tooltipDesc = document.getElementById('tooltipDesc');
            inventoryUIRefs.dragGhost = document.getElementById('dragGhost');

            // Initialize Steve Preview
            if (!stevePreview) {
                stevePreview = new StevePreview('playerPreview');
            }

            const closeBtn = document.getElementById('inventoryCloseBtn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => toggleInventory(false));
            }

            if (inventoryUIRefs.inventoryTabs) {
                inventoryUIRefs.inventoryTabs.innerHTML = '';
                INVENTORY_CATEGORIES.forEach((category) => {
                    const tab = document.createElement('button');
                    tab.type = 'button';
                    tab.className = 'inventory-tab';
                    tab.dataset.category = category.id;
                    tab.textContent = category.name;
                    tab.addEventListener('click', () => setActiveInventoryCategory(category.id));
                    inventoryUIRefs.inventoryTabs.appendChild(tab);
                });
            }

            setActiveInventoryCategory(activeInventoryCategory);
            renderHotbarTextures();
        }

        function setActiveInventoryCategory(categoryId) {
            if (!inventoryState.categories[categoryId]) {
                ensureCategoryStorage(categoryId);
            }
            activeInventoryCategory = categoryId;

            if (inventoryUIRefs.inventoryTabs) {
                Array.from(inventoryUIRefs.inventoryTabs.children).forEach((tab) => {
                    tab.classList.toggle('active', tab.dataset.category === categoryId);
                });
            }

            renderInventoryGrid();
            renderInventoryHotbarOverlay();
        }

        function refreshInventoryUI() {
            renderHotbarTextures();
            playerHand.updateItem();
            if (inventoryOpen) {
                renderInventoryGrid();
            }
        }

        function renderInventoryGrid() {
            const container = inventoryUIRefs.inventoryGrid;
            if (!container) {
                return;
            }
            const storage = ensureCategoryStorage(activeInventoryCategory);
            container.innerHTML = '';
            storage.forEach((_, index) => {
                container.appendChild(buildSlotElement('inventory', activeInventoryCategory, index, 'inventoryGrid'));
            });
        }

        function renderInventoryHotbarOverlay() {
            const container = inventoryUIRefs.inventoryHotbar;
            if (!container) {
                return;
            }
            container.innerHTML = '';
            inventoryState.hotbar.forEach((_, index) => {
                const slot = buildSlotElement('hotbar', null, index, 'inventoryHotbar');
                if (index === player.selectedSlot) {
                    slot.classList.add('selected');
                }
                container.appendChild(slot);
            });
        }

        function renderWorldHotbar() {
            const container = inventoryUIRefs.hotbarSlots;
            if (!container) {
                return;
            }
            container.innerHTML = '';
            inventoryState.hotbar.forEach((_, index) => {
                const slot = buildSlotElement('hotbar', null, index, 'worldHotbar');
                slot.dataset.hotbarNum = String(index + 1);
                if (index === player.selectedSlot) {
                    slot.classList.add('selected');
                }
                container.appendChild(slot);
            });
        }

        function buildSlotElement(storageType, categoryId, index, area) {
            const slot = document.createElement('div');
            slot.className = storageType === 'inventory' ? 'inventory-slot' : 'hotbar-slot';
            slot.dataset.storage = storageType;
            slot.dataset.index = String(index);
            slot.dataset.area = area || '';
            if (categoryId) {
                slot.dataset.category = categoryId;
            }

            if (storageType === 'hotbar') {
                slot.dataset.hotbarNum = String(index + 1);
            }

            renderStackInSlot(slot, getStorageSlot(storageType, categoryId, index));

            slot.addEventListener('pointerdown', handleSlotPointerDown);
            slot.addEventListener('contextmenu', handleSlotContextMenu);
            slot.addEventListener('pointerenter', handleSlotPointerEnter);
            slot.addEventListener('pointerleave', handleSlotPointerLeave);
            slot.addEventListener('pointermove', handleSlotPointerMove);

            return slot;
        }

        function renderStackInSlot(slot, stack) {
            slot.innerHTML = '';
            if (!stack) {
                return;
            }
            const icon = createIconElement(stack.id);
            if (icon) {
                slot.appendChild(icon);
            }
            if (stack.qty > 1) {
                const qty = document.createElement('span');
                qty.className = 'slot-qty';
                qty.textContent = stack.qty;
                slot.appendChild(qty);
            }
        }

        function createIconElement(itemId) {
            const url = getIconDataUrl(itemId);
            const wrapper = document.createElement('div');
            wrapper.className = 'slot-icon';
            if (url) {
                const img = document.createElement('img');
                img.alt = '';
                img.draggable = false;
                img.width = 32;
                img.height = 32;
                img.style.imageRendering = 'pixelated';
                img.src = url;
                wrapper.appendChild(img);
            }
            return wrapper;
        }

        function getIconDataUrl(itemId) {
            if (iconCache.has(itemId)) {
                return iconCache.get(itemId);
            }
            const definition = getItemDefinition(itemId);
            if (!definition) {
                return null;
            }
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            const preferredKeys = [definition.textureKey, definition.id];
            let sourceCanvas = null;
            for (const key of preferredKeys) {
                if (key && textures[key] && textures[key].image) {
                    sourceCanvas = textures[key].image;
                    break;
                }
            }

            if (sourceCanvas) {
                ctx.drawImage(sourceCanvas, 0, 0, 32, 32);
            } else {
                drawPlaceholderIcon(ctx, definition.iconColor || DEFAULT_ICON_COLORS[definition.category] || '#cfcfcf');
            }

            const dataUrl = canvas.toDataURL();
            iconCache.set(itemId, dataUrl);
            return dataUrl;
        }

        function drawPlaceholderIcon(ctx, color) {
            ctx.fillStyle = '#1b1b1b';
            ctx.fillRect(0, 0, 32, 32);
            ctx.fillStyle = color;
            for (let y = 2; y < 30; y += 4) {
                for (let x = 2; x < 30; x += 4) {
                    ctx.fillRect(x, y, 3, 3);
                }
            }
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.strokeRect(1.5, 1.5, 29, 29);
        }

        function handleSlotPointerDown(event) {
            const slot = event.currentTarget;
            const storage = slot.dataset.storage;
            const index = parseInt(slot.dataset.index, 10);
            const categoryId = slot.dataset.category || null;

            if (slot.dataset.area === 'worldHotbar' && !inventoryOpen) {
                if (event.button === 0) {
                    player.selectedSlot = index;
                    updateHotbar();
                }
                return;
            }

            if (event.button !== 0) {
                return;
            }

            if (event.shiftKey) {
                handleQuickTransfer(storage, categoryId, index);
                return;
            }

            startDraggingFromSlot(storage, categoryId, index, event);
        }

        function handleSlotContextMenu(event) {
            event.preventDefault();
            const slot = event.currentTarget;
            const storage = slot.dataset.storage;
            const index = parseInt(slot.dataset.index, 10);
            const categoryId = slot.dataset.category || null;
            splitStackIntoEmpty(storage, categoryId, index);
        }

        function handleSlotPointerEnter(event) {
            if (dragState.active) {
                return;
            }
            const slot = event.currentTarget;
            const stack = getStorageSlot(slot.dataset.storage, slot.dataset.category || null, parseInt(slot.dataset.index, 10));
            showTooltip(slot, stack, event);
        }

        function handleSlotPointerMove(event) {
            if (dragState.active) {
                return;
            }
            const tooltip = inventoryUIRefs.tooltip;
            if (!tooltip || tooltip.style.display !== 'block') {
                return;
            }
            tooltip.style.left = `${event.clientX + 16}px`;
            tooltip.style.top = `${event.clientY + 16}px`;
        }

        function handleSlotPointerLeave() {
            hideTooltip();
        }

        function startDraggingFromSlot(storage, categoryId, index, event) {
            const stack = getStorageSlot(storage, categoryId, index);
            if (!stack) {
                return;
            }

            dragState.active = true;
            dragState.source = { storage, categoryId, index };
            dragState.stack = cloneStack(stack);
            dragState.pointerId = event.pointerId;

            setStorageSlot(storage, categoryId, index, null);
            showDragGhost(event, dragState.stack);
            hideTooltip();

            window.addEventListener('pointermove', handlePointerMove);
            window.addEventListener('pointerup', handlePointerUp);
        }

        function handlePointerMove(event) {
            if (!dragState.active || event.pointerId !== dragState.pointerId) {
                return;
            }
            updateDragGhostPosition(event);
            const target = resolveDropTarget(event.clientX, event.clientY);
            updateHighlightedTarget(target ? target.element : null);
        }

        function handlePointerUp(event) {
            if (!dragState.active || event.pointerId !== dragState.pointerId) {
                return;
            }

            const target = resolveDropTarget(event.clientX, event.clientY);
            if (target) {
                applyDropToTarget(target);
            } else {
                dragState.stack = null;
            }

            endDrag();
            refreshInventoryUI();
        }

        function resolveDropTarget(clientX, clientY) {
            const element = document.elementFromPoint(clientX, clientY);
            if (!element) {
                return null;
            }
            if (element === inventoryUIRefs.dragGhost || element.closest('#dragGhost')) {
                return null;
            }
            const slot = element.closest('.inventory-slot, .hotbar-slot');
            if (!slot) {
                return null;
            }
            const storage = slot.dataset.storage;
            const index = parseInt(slot.dataset.index, 10);
            const categoryId = slot.dataset.category || null;
            return { element: slot, storage, index, categoryId };
        }

        function updateHighlightedTarget(element) {
            if (dragState.highlightEl === element) {
                return;
            }
            if (dragState.highlightEl) {
                dragState.highlightEl.classList.remove('drag-target');
            }
            dragState.highlightEl = element;
            if (dragState.highlightEl) {
                dragState.highlightEl.classList.add('drag-target');
            }
        }

        function applyDropToTarget(target) {
            if (!dragState.stack) {
                return;
            }

            const destinationStack = getStorageSlot(target.storage, target.categoryId, target.index);
            if (!destinationStack) {
                setStorageSlot(target.storage, target.categoryId, target.index, cloneStack(dragState.stack));
                dragState.stack = null;
                return;
            }

            if (destinationStack.id === dragState.stack.id) {
                const definition = getItemDefinition(destinationStack.id);
                const maxStack = definition ? definition.maxStack || 64 : 64;
                const space = maxStack - destinationStack.qty;
                if (space > 0) {
                    const moved = Math.min(space, dragState.stack.qty);
                    destinationStack.qty += moved;
                    dragState.stack.qty -= moved;
                    if (dragState.stack.qty <= 0) {
                        dragState.stack = null;
                    }
                    return;
                }
            }

            const temp = cloneStack(destinationStack);
            setStorageSlot(target.storage, target.categoryId, target.index, cloneStack(dragState.stack));
            dragState.stack = temp;
        }

        function endDrag() {
            updateHighlightedTarget(null);

            window.removeEventListener('pointermove', handlePointerMove);
            window.removeEventListener('pointerup', handlePointerUp);

            const ghost = inventoryUIRefs.dragGhost;
            if (ghost) {
                ghost.style.display = 'none';
                ghost.innerHTML = '';
            }

            if (dragState.stack && dragState.source) {
                const { storage, categoryId, index } = dragState.source;
                const array = getStorageArray(storage, categoryId);
                const remainder = placeStackIntoArray(dragState.stack, array);
                if (remainder) {
                    array[index] = cloneStack(remainder);
                }
            }

            dragState.active = false;
            dragState.source = null;
            dragState.stack = null;
            dragState.pointerId = null;
        }

        function showDragGhost(event, stack) {
            const ghost = inventoryUIRefs.dragGhost;
            if (!ghost) {
                return;
            }
            ghost.style.display = 'block';
            ghost.innerHTML = '';
            const icon = createIconElement(stack.id);
            if (icon) {
                ghost.appendChild(icon);
            }
            if (stack.qty > 1) {
                const qty = document.createElement('span');
                qty.className = 'slot-qty';
                qty.textContent = stack.qty;
                ghost.appendChild(qty);
            }
            updateDragGhostPosition(event);
        }

        function updateDragGhostPosition(event) {
            const ghost = inventoryUIRefs.dragGhost;
            if (!ghost) {
                return;
            }
            ghost.style.left = `${event.clientX + 12}px`;
            ghost.style.top = `${event.clientY + 12}px`;
        }

        function showTooltip(slot, stack, event) {
            const tooltip = inventoryUIRefs.tooltip;
            if (!tooltip || !stack) {
                hideTooltip();
                return;
            }
            const definition = getItemDefinition(stack.id);
            if (inventoryUIRefs.tooltipTitle) {
                inventoryUIRefs.tooltipTitle.textContent = definition ? definition.name : stack.id;
                inventoryUIRefs.tooltipTitle.style.color = definition ? (RARITY_COLORS[definition.rarity] || '#ffffff') : '#ffffff';
            }
            if (inventoryUIRefs.tooltipDesc) {
                inventoryUIRefs.tooltipDesc.textContent = definition ? (definition.description || '') : '';
            }
            tooltip.style.display = 'block';
            tooltip.hidden = false;
            tooltip.style.left = `${event.clientX + 16}px`;
            tooltip.style.top = `${event.clientY + 16}px`;
        }

        function hideTooltip() {
            if (inventoryUIRefs.tooltip) {
                inventoryUIRefs.tooltip.style.display = 'none';
                inventoryUIRefs.tooltip.hidden = true;
            }
        }

        function handleQuickTransfer(storage, categoryId, index) {
            const stack = getStorageSlot(storage, categoryId, index);
            if (!stack) {
                return;
            }
            hideTooltip();
            let remainder = cloneStack(stack);

            if (storage === 'inventory') {
                remainder = placeStackIntoArray(remainder, inventoryState.hotbar);
            } else {
                remainder = placeStackIntoArray(remainder, ensureCategoryStorage(activeInventoryCategory));
            }

            setStorageSlot(storage, categoryId, index, remainder);
            refreshInventoryUI();
        }

        function placeStackIntoArray(stack, array) {
            if (!stack) {
                return null;
            }
            const definition = getItemDefinition(stack.id);
            const maxStack = definition ? definition.maxStack || 64 : 64;

            for (let i = 0; i < array.length && stack.qty > 0; i++) {
                const slot = array[i];
                if (slot && slot.id === stack.id && slot.qty < maxStack) {
                    const space = maxStack - slot.qty;
                    const moved = Math.min(space, stack.qty);
                    slot.qty += moved;
                    stack.qty -= moved;
                }
            }

            for (let i = 0; i < array.length && stack.qty > 0; i++) {
                if (!array[i]) {
                    const moved = Math.min(maxStack, stack.qty);
                    array[i] = { id: stack.id, qty: moved };
                    stack.qty -= moved;
                }
            }

            return stack.qty > 0 ? stack : null;
        }

        function splitStackIntoEmpty(storage, categoryId, index) {
            const stack = getStorageSlot(storage, categoryId, index);
            if (!stack || stack.qty < 2) {
                return;
            }

            hideTooltip();

            const amountToMove = Math.ceil(stack.qty / 2);
            if (amountToMove <= 0) {
                return;
            }

            const targetArray = getStorageArray(storage, categoryId);
            const emptyIndex = targetArray.findIndex((slot, slotIndex) => !slot && slotIndex !== index);
            if (emptyIndex === -1) {
                return;
            }

            stack.qty -= amountToMove;
            targetArray[emptyIndex] = { id: stack.id, qty: amountToMove };
            refreshInventoryUI();
        }

        function setStorageSlot(storage, categoryId, index, stack) {
            const array = getStorageArray(storage, categoryId);
            array[index] = stack ? { id: stack.id, qty: stack.qty } : null;
        }

        function getStorageSlot(storage, categoryId, index) {
            const array = getStorageArray(storage, categoryId);
            return array[index];
        }

        function getStorageArray(storage, categoryId) {
            if (storage === 'inventory') {
                return ensureCategoryStorage(categoryId);
            }
            return inventoryState.hotbar;
        }

        function getSelectedHotbarStack() {
            return inventoryState.hotbar[player.selectedSlot] || null;
        }

        function getSurfaceMaterialUnderPlayer() {
            const groundY = Math.floor(player.position.y - PLAYER_HEIGHT - 0.1);
            const block = getBlock(player.position.x, groundY, player.position.z);
            return block && block.userData ? block.userData.type : 'dirt';
        }

        function findSurfaceHeight(x, z, startY = 120, endY = -32) {
            const ix = Math.round(x);
            const iz = Math.round(z);
            const maxY = Math.max(Math.round(startY), Math.round(endY));
            const minY = Math.min(Math.round(startY), Math.round(endY));
            for (let y = maxY; y >= minY; y--) {
                if (isSolidBlock(ix, y, iz)) {
                    return y + 0.5;
                }
            }
            return null;
        }

        initializeInventoryState();
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initializeInventoryUI();
                refreshInventoryUI();
                updateHealthBar();
                updateHungerBar();
                updateExperienceBar();
            });
        } else {
            initializeInventoryUI();
            refreshInventoryUI();
            updateHealthBar();
            updateHungerBar();
            updateExperienceBar();
        }
        let worldBlocks = new Map();
        let breakingBlock = null;
        let breakProgress = 0;
        let isBreaking = false;
        let highlightBox = null; // –û–±–≤–æ–¥–∫–∞ –±–ª–æ–∫–∞
        let isPaused = false;
        let renderDistance = 4; // –î–∞–ª—å–Ω–æ—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –≤ —á–∞–Ω–∫–∞—Ö
        let mouseSensitivity = 0.002; // –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –º—ã—à–∏
        const BREAK_TIME = 0.6; // –í—Ä–µ–º—è —Ä–∞–∑—Ä—É—à–µ–Ω–∏—è –±–ª–æ–∫–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
        const CHUNK_SIZE = 16; // –†–∞–∑–º–µ—Ä —á–∞–Ω–∫–∞ 16x16 –±–ª–æ–∫–æ–≤
        const CHUNK_HEIGHT = 64; // –ò—Å–ø–æ–ª—å–∑—É–µ–º–∞—è –≤—ã—Å–æ—Ç–∞ —á–∞–Ω–∫–∞ –ø–æ Y
        const PLAYER_HEIGHT = 1.8; // –í—ã—Å–æ—Ç–∞ –∏–≥—Ä–æ–∫–∞ –≤ –±–ª–æ–∫–∞—Ö
        const PLAYER_WIDTH = 0.6; // –ü–æ–ª–Ω—ã–π –±–ª–æ–∫ —à–∏—Ä–∏–Ω–æ–π
        const PLAYER_HALF_WIDTH = PLAYER_WIDTH / 2;
        const PLAYER_STEP_HEIGHT = 0.6; // –í—ã—Å–æ—Ç–∞ —à–∞–≥–∞ –±–µ–∑ –ø—Ä—ã–∂–∫–∞
        const COLLISION_EPSILON = 0.01; // –ó–∞–ø–∞—Å –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –∑–∞—Å—Ç—Ä–µ–≤–∞–Ω–∏–π
        const NON_SOLID_BLOCKS = new Set(['water']);
        const SPAWNABLE_BLOCK_TYPES = new Set(['grass', 'dirt', 'stone']);
        let chunks = new Map(); // –•—Ä–∞–Ω–∏–ª–∏—â–µ —á–∞–Ω–∫–æ–≤
        let lastPlayerChunk = { x: 0, z: 0 }; // –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–∑–∏—Ü–∏—è –∏–≥—Ä–æ–∫–∞ –≤ —á–∞–Ω–∫–∞—Ö
        let chunkUpdateTimer = 0; // –¢–∞–π–º–µ—Ä –¥–ª—è –¥–µ–±–∞—É–Ω—Å–∏–Ω–≥–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —á–∞–Ω–∫–æ–≤
        let timeOfDay = 6000; // –í—Ä–µ–º—è —Å—É—Ç–æ–∫ (6000 = —É—Ç—Ä–æ, 12000 = –ø–æ–ª–¥–µ–Ω—å)
        let sunLight = null;
        let moonLight = null;
        let sunMesh = null;
        let moonMesh = null;
        let ambientLight = null;
        let hemisphereLight = null;
        let clouds = [];
        let showFPS = true;
        let fpsTime = 0;
        let fpsCounter = 0;
        let textureQuality = 'medium'; // low, medium, high
        let flatBlocks = false; // 2D –±–ª–æ–∫–∏
        let worldChanges = {}; // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ—Å—Ç—Ä–æ–µ–∫
        let waterBlocks = new Map(); // –ê–∫—Ç–∏–≤–Ω—ã–µ –±–ª–æ–∫–∏ –≤–æ–¥—ã –¥–ª—è —Ñ–∏–∑–∏–∫–∏
        let currentWorldId = null; // ID —Ç–µ–∫—É—â–µ–≥–æ –º–∏—Ä–∞
        let worldSeed = 0; // –°–∏–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –º–∏—Ä–∞
        let simplex = null; // SimplexNoise –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä
        let rng = null; // Alea –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä
        let physicsWorld = null; // Cannon.js –º–∏—Ä
        let peer = null; // PeerJS
        let chunkWorker = null; // Web Worker –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —á–∞–Ω–∫–æ–≤
        let pendingChunks = new Map(); // –û—á–µ—Ä–µ–¥—å —á–∞–Ω–∫–æ–≤ –Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é
        let zombies = []; // –ú–∞—Å—Å–∏–≤ –∑–æ–º–±–∏
        let passiveAnimals = []; // –î—Ä—É–∂–µ–ª—é–±–Ω—ã–µ —Å—É—â–µ—Å—Ç–≤–∞
        let worldDecorations = new Map(); // –ù–µ—Å–æ–ª–∏–¥–Ω—ã–µ –¥–µ–∫–æ—Ä–∞—Ü–∏–∏ (—Ç—Ä–∞–≤–∞ –∏ —Ç.–ø.)
        const animalRaycaster = new THREE.Raycaster();
        animalRaycaster.layers.enable(1);
        const decorationRaycaster = new THREE.Raycaster();
        decorationRaycaster.layers.enable(1);
        const tempBox = new THREE.Box3();
        const tempVecA = new THREE.Vector3();
        const tempVecB = new THREE.Vector3();
        const screenCenter = new THREE.Vector2(0, 0);
        const PLAYER_MAX_HEALTH = 10;
        const PLAYER_MAX_HUNGER = 10;
        let playerHealth = PLAYER_MAX_HEALTH;
        let playerHunger = PLAYER_MAX_HUNGER;
        let experienceLevel = 1;
        let experienceProgress = 0;
        let isDead = false; // –§–ª–∞–≥ —Å–º–µ—Ä—Ç–∏ –∏–≥—Ä–æ–∫–∞
        let lastDamageTime = 0; // –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —É—Ä–æ–Ω–∞ (–¥–ª—è cooldown)
        const droppedItems = []; // –ü–æ–¥–æ–±–∏—è –ø—Ä–µ–¥–º–µ—Ç–æ–≤, –ª–µ–∂–∞—â–∏—Ö –≤ –º–∏—Ä–µ
        const DROP_SIZE = 0.6;
        const DROP_PICKUP_RADIUS = 1.4;
        const DROP_GRAVITY = 9.5;
        const DROP_FRICTION = 0.8;
        let dropGeometry = null;
        const SAFE_FALL_HEIGHT = 3;
        const FALL_DAMAGE_POWER = 1.35;
        const HUNGER_SPRINT_COST_INTERVAL = 0.9;
        const STARVATION_TICK_INTERVAL = 2.5;
        const MAX_PASSIVE_ANIMALS = 5;
        const PASSIVE_SPAWN_CHANCE = 0.001;
        const PASSIVE_SPAWN_RANGE_MIN = 12;
        const PASSIVE_SPAWN_RANGE_MAX = 32;
        const PASSIVE_DESPAWN_DISTANCE = 180;
        const EAT_COOLDOWN = 0.65;

        let lastUIHealth = PLAYER_MAX_HEALTH;
        let heartShakeTimeout = null;
        let sprintHungerTimer = 0;
        let starvationTimer = 0;
        let eatCooldown = 0;

        class QuadTreeNode {
            constructor(bounds, capacity, depth, maxDepth) {
                this.bounds = bounds;
                this.capacity = capacity;
                this.depth = depth;
                this.maxDepth = maxDepth;
                this.items = [];
                this.children = null;
            }

            contains(target) {
                return target.minX >= this.bounds.minX &&
                    target.maxX <= this.bounds.maxX &&
                    target.minZ >= this.bounds.minZ &&
                    target.maxZ <= this.bounds.maxZ;
            }

            intersects(range) {
                return !(range.minX > this.bounds.maxX ||
                    range.maxX < this.bounds.minX ||
                    range.minZ > this.bounds.maxZ ||
                    range.maxZ < this.bounds.minZ);
            }

            subdivide() {
                if (this.children) {
                    return;
                }
                const midX = (this.bounds.minX + this.bounds.maxX) * 0.5;
                const midZ = (this.bounds.minZ + this.bounds.maxZ) * 0.5;
                const depth = this.depth + 1;
                this.children = [
                    new QuadTreeNode({ minX: this.bounds.minX, minZ: this.bounds.minZ, maxX: midX, maxZ: midZ }, this.capacity, depth, this.maxDepth),
                    new QuadTreeNode({ minX: midX, minZ: this.bounds.minZ, maxX: this.bounds.maxX, maxZ: midZ }, this.capacity, depth, this.maxDepth),
                    new QuadTreeNode({ minX: this.bounds.minX, minZ: midZ, maxX: midX, maxZ: this.bounds.maxZ }, this.capacity, depth, this.maxDepth),
                    new QuadTreeNode({ minX: midX, minZ: midZ, maxX: this.bounds.maxX, maxZ: this.bounds.maxZ }, this.capacity, depth, this.maxDepth)
                ];
            }

            insert(item) {
                if (!this.contains(item)) {
                    return false;
                }

                if (this.items.length < this.capacity || this.depth >= this.maxDepth) {
                    this.items.push(item);
                    return true;
                }

                if (!this.children) {
                    this.subdivide();
                }

                for (const child of this.children) {
                    if (child.insert(item)) {
                        return true;
                    }
                }

                this.items.push(item);
                return true;
            }

            query(range, result) {
                if (!this.intersects(range)) {
                    return;
                }

                for (const item of this.items) {
                    if (!(item.minX > range.maxX || item.maxX < range.minX || item.minZ > range.maxZ || item.maxZ < range.minZ)) {
                        result.push(item);
                    }
                }

                if (!this.children) {
                    return;
                }

                for (const child of this.children) {
                    child.query(range, result);
                }
            }

            removeById(id) {
                let removed = false;
                for (let i = this.items.length - 1; i >= 0; i--) {
                    if (this.items[i].id === id) {
                        this.items.splice(i, 1);
                        removed = true;
                    }
                }

                if (this.children) {
                    for (const child of this.children) {
                        if (child.removeById(id)) {
                            removed = true;
                        }
                    }

                    const totalChildItems = this.children.reduce((sum, child) => sum + child.items.length + (child.children ? 1 : 0), 0);
                    if (totalChildItems === 0) {
                        this.children = null;
                    }
                }

                return removed;
            }

            clear() {
                this.items.length = 0;
                if (this.children) {
                    for (const child of this.children) {
                        child.clear();
                    }
                    this.children = null;
                }
            }
        }

        class QuadTree {
            constructor(bounds, capacity = 8, maxDepth = 6) {
                this.root = new QuadTreeNode(bounds, capacity, 0, maxDepth);
            }

            insert(item) {
                return this.root.insert(item);
            }

            query(range) {
                const result = [];
                this.root.query(range, result);
                return result;
            }

            removeById(id) {
                return this.root.removeById(id);
            }

            clear() {
                this.root.clear();
            }
        }

        const WORLD_BOUNDS = { minX: -8192, minZ: -8192, maxX: 8192, maxZ: 8192 };
        const chunkQuadTree = new QuadTree(WORLD_BOUNDS, 8, 6);
        const chunkQuadIndex = new Map();

        function getChunkBounds(chunkX, chunkZ) {
            const minX = chunkX * CHUNK_SIZE;
            const minZ = chunkZ * CHUNK_SIZE;
            return {
                minX,
                minZ,
                maxX: minX + CHUNK_SIZE,
                maxZ: minZ + CHUNK_SIZE
            };
        }

        function registerChunkSpatial(chunkX, chunkZ, chunkGroup) {
            const key = getChunkKey(chunkX, chunkZ);
            if (chunkQuadIndex.has(key)) {
                return;
            }
            const bounds = getChunkBounds(chunkX, chunkZ);
            const item = {
                id: key,
                minX: bounds.minX,
                minZ: bounds.minZ,
                maxX: bounds.maxX,
                maxZ: bounds.maxZ,
                data: chunkGroup
            };
            if (chunkQuadTree.insert(item)) {
                chunkQuadIndex.set(key, item);
            } else {
                console.warn('QuadTree insert failed for chunk', key, bounds);
            }
        }

        function unregisterChunkSpatial(chunkX, chunkZ) {
            const key = getChunkKey(chunkX, chunkZ);
            if (!chunkQuadIndex.has(key)) {
                return;
            }
            chunkQuadTree.removeById(key);
            chunkQuadIndex.delete(key);
        }
        
        // Debug –º–µ—Ç—Ä–∏–∫–∏
        let debugStats = {
            chunksRendered: 0,
            chunksTotal: 0,
            blocksRendered: 0,
            zombiesRendered: 0,
            animalsRendered: 0,
            drawCalls: 0,
            triangles: 0
        };
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∏
        let graphicsQuality = 'medium'; // low, medium, high, ultra
        let smoothLighting = true;
        let fancyClouds = true;
        let particlesEnabled = true;
        let shadowsEnabled = false;
        let fogEnabled = true;
        let frustumCullingEnabled = true;
        const frustum = new THREE.Frustum();
        const projScreenMatrix = new THREE.Matrix4();
        let fov = 75;

        const GRAPHICS_LABELS = {
            low: '–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è',
            medium: '–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è',
            high: '–í—ã—Å–æ–∫–∞—è',
            ultra: '–£–ª—å—Ç—Ä–∞'
        };

        const TEXTURE_LABELS = {
            low: '–ù–∏–∑–∫–æ–µ (8x8)',
            medium: '–°—Ä–µ–¥–Ω–µ–µ (16x16)',
            high: '–í—ã—Å–æ–∫–æ–µ (32x32)'
        };

        const DEFAULT_RENDER_DISTANCE_LIMITS = { min: 1, max: 32 };
        const RENDER_DISTANCE_LIMITS = {
            low: { min: 1, max: 32 },
            medium: { min: 1, max: 32 },
            high: { min: 1, max: 32 },
            ultra: { min: 1, max: 32 }
        };

        function getRenderDistanceLimits(quality = graphicsQuality) {
            return DEFAULT_RENDER_DISTANCE_LIMITS;
        }

        function clampRenderDistance(value, quality = graphicsQuality) {
            const limits = getRenderDistanceLimits(quality);
            const numeric = Number(value);
            const safeValue = Number.isFinite(numeric) ? Math.round(numeric) : limits.min;
            return Math.min(limits.max, Math.max(limits.min, safeValue));
        }

        function syncRenderDistanceUI(distance, quality = graphicsQuality) {
            const limits = getRenderDistanceLimits(quality);
            const applyToSlider = (sliderId, labelId) => {
                const slider = document.getElementById(sliderId);
                if (!slider) {
                    return;
                }
                slider.min = limits.min;
                slider.max = limits.max;
                slider.value = distance;
                if (!labelId) {
                    return;
                }
                const label = document.getElementById(labelId);
                if (label) {
                    label.textContent = distance;
                }
            };
            applyToSlider('renderDistance', 'renderDistanceValue');
            applyToSlider('mainRenderDistance', 'mainRenderDistanceValue');
        }

        function applyRenderDistanceSetting(value, quality = graphicsQuality) {
            const clamped = clampRenderDistance(value, quality);
            renderDistance = clamped;
            syncRenderDistanceUI(clamped, quality);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ç—É–º–∞–Ω –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –¥–∞–ª—å–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ä–∏—Å–æ–≤–∫–∏
            if (scene) {
                if (fogEnabled) {
                    if (!scene.fog) {
                        // –ï—Å–ª–∏ —Ç—É–º–∞–Ω –≤–∫–ª—é—á–µ–Ω, –Ω–æ –æ–±—ä–µ–∫—Ç–∞ –Ω–µ—Ç - —Å–æ–∑–¥–∞–µ–º
                        const color = activeSkyColors ? activeSkyColors.day : new THREE.Color(0x8fcbff);
                        scene.fog = new THREE.Fog(color, 10, 100);
                    }
                    // –¢—É–º–∞–Ω –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ä–∞–Ω—å—à–µ, —á—Ç–æ–±—ã —Å–∫—Ä—ã—Ç—å –∫—Ä–∞–π –º–∏—Ä–∞
                    const viewDistance = renderDistance * CHUNK_SIZE;
                    // –î–µ–ª–∞–µ–º —Ç—É–º–∞–Ω –≥—É—â–µ –∫ –∫—Ä–∞—é, —á—Ç–æ–±—ã –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–∫—Ä—ã—Ç—å –∑–∞–≥—Ä—É–∑–∫—É
                    scene.fog.far = viewDistance * 0.8; 
                    scene.fog.near = viewDistance * 0.25;
                    console.log(`‚úì –¢—É–º–∞–Ω –æ–±–Ω–æ–≤–ª–µ–Ω: near=${scene.fog.near}, far=${scene.fog.far}`);
                } else {
                    // –ï—Å–ª–∏ —Ç—É–º–∞–Ω –≤—ã–∫–ª—é—á–µ–Ω - —É–¥–∞–ª—è–µ–º –æ–±—ä–µ–∫—Ç
                    scene.fog = null;
                }
            }
            
            return clamped;
        }

        const UNDERWATER_FOG_COLOR = 0x0b1f7a;
        const UNDERWATER_FOG_NEAR = 0.6;
        const UNDERWATER_FOG_FAR = 32;

        const GRAPHICS_PRESETS = {
            low: {
                fogNear: 45,
                fogFar: 150,
                sunIntensity: 0.65,
                moonIntensity: 0.25,
                ambientIntensity: 0.35,
                hemisphereSkyColor: 0xaed3ff,
                hemisphereGroundColor: 0x2f2316,
                hemisphereIntensity: 0.3,
                fancyClouds: false,
                cloudOpacity: 0.45,
                cloudSpeedMultiplier: 0.7,
                smoothLighting: false,
                particles: false,
                shadows: false,
                leavesTransparent: false, // –ë—ã—Å—Ç—Ä–∞—è –ª–∏—Å—Ç–≤–∞ (—Å–ø–ª–æ—à–Ω–∞—è)
                toneMapping: 'none',
                exposure: 1.0,
                pixelRatio: 1.0,
                waterOpacity: 0.85, // –ú–µ–Ω–µ–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è
                waterColor: 0x8fc9ff,
                physicallyCorrectLights: false,
                sky: {
                    dawn: 0xf7a364,
                    day: 0x8fcbff,
                    noon: 0x7db8ff,
                    dusk: 0xf07a45,
                    night: 0x0d1c3a
                }
            },
            medium: {
                fogNear: 60,
                fogFar: 220,
                sunIntensity: 1.1, // –Ø—Ä—á–µ —Å–æ–ª–Ω—Ü–µ
                moonIntensity: 0.4,
                ambientIntensity: 0.6, // –°–≤–µ—Ç–ª–µ–µ —Ç–µ–Ω–∏
                hemisphereSkyColor: 0x9bcaff,
                hemisphereGroundColor: 0x4a3a2a, // –¢–µ–ø–ª–µ–µ –∑–µ–º–ª—è
                hemisphereIntensity: 0.6,
                fancyClouds: true,
                cloudOpacity: 0.8,
                cloudSpeedMultiplier: 1.0,
                smoothLighting: true,
                particles: true,
                shadows: true,
                leavesTransparent: true,
                toneMapping: 'reinhard',
                exposure: 1.1,
                pixelRatio: 1.0,
                waterOpacity: 0.75, // –ü—Ä–æ–∑—Ä–∞—á–Ω–µ–µ –≤–æ–¥–∞
                waterColor: 0x66b3ff, // –ì–æ–ª—É–±–µ–µ –≤–æ–¥–∞
                physicallyCorrectLights: false,
                sky: {
                    dawn: 0xffaa66, // –ù–∞—Å—ã—â–µ–Ω–Ω–µ–µ —Ä–∞—Å—Å–≤–µ—Ç
                    day: 0x66b3ff, // –ù–∞—Å—ã—â–µ–Ω–Ω–µ–µ –¥–µ–Ω—å
                    noon: 0x55aaff,
                    dusk: 0xff8855,
                    night: 0x0a1735
                }
            },
            high: {
                fogNear: 70, // –î–∞–ª—å—à–µ —Ç—É–º–∞–Ω
                fogFar: 280,
                sunIntensity: 1.2,
                moonIntensity: 0.5,
                ambientIntensity: 0.65,
                hemisphereSkyColor: 0x88c7ff,
                hemisphereGroundColor: 0x3a2a1a,
                hemisphereIntensity: 0.6,
                fancyClouds: true,
                cloudOpacity: 0.85,
                cloudSpeedMultiplier: 1.2,
                smoothLighting: true,
                particles: true,
                shadows: true,
                leavesTransparent: true, // –î–µ—Ç–∞–ª—å–Ω–∞—è –ª–∏—Å—Ç–≤–∞
                toneMapping: 'aces',
                exposure: 1.1,
                pixelRatio: 1.5,
                waterOpacity: 0.75, // –ú–µ–Ω–µ–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è
                waterColor: 0x75b8ff,
                physicallyCorrectLights: true,
                sky: {
                    dawn: 0xf29246,
                    day: 0x74baff,
                    noon: 0x63adff,
                    dusk: 0xe9644a,
                    night: 0x08112d
                }
            },
            ultra: {
                fogNear: 60,
                fogFar: 280,
                sunIntensity: 1.0,
                moonIntensity: 0.45,
                ambientIntensity: 0.4,
                hemisphereSkyColor: 0x7ec4ff,
                hemisphereGroundColor: 0x25170f,
                hemisphereIntensity: 0.4,
                fancyClouds: true,
                cloudOpacity: 0.85,
                cloudSpeedMultiplier: 1.35,
                smoothLighting: true,
                particles: true,
                shadows: true,
                leavesTransparent: true, // –î–µ—Ç–∞–ª—å–Ω–∞—è –ª–∏—Å—Ç–≤–∞
                toneMapping: 'aces',
                exposure: 1.0,
                pixelRatio: 2.0,
                waterOpacity: 0.7, // –ú–µ–Ω–µ–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è
                waterColor: 0x6cb0ff,
                physicallyCorrectLights: true,
                bloom: {
                    enabled: true,
                    strength: 0.6,
                    radius: 0.5,
                    threshold: 0.85
                },
                sky: {
                    dawn: 0xef8d3d,
                    day: 0x6fb5ff,
                    noon: 0x5aa7ff,
                    dusk: 0xe35c4e,
                    night: 0x060d24
                }
            }
        };

        let activeGraphicsPreset = GRAPHICS_PRESETS[graphicsQuality];
        let activeSkyColors = null;
        const tempSkyColor = new THREE.Color();

        // IEEE 754 float32 helper (1 sign bit, 8 exponent bits, 23 mantissa bits)
        const Float32Binary = (() => {
            const buffer = new ArrayBuffer(4);
            const view = new DataView(buffer);
            const bytes = new Uint8Array(buffer);

            const toBinaryString = (word) => word.toString(2).padStart(32, '0');
            const splitWord = (word) => ({
                sign: (word >>> 31) & 0x1,
                exponent: (word >>> 23) & 0xff,
                mantissa: word & 0x7fffff
            });

            return {
                toBits(value) {
                    view.setFloat32(0, value, true);
                    const word = view.getUint32(0, true);
                    const parts = splitWord(word);
                    return {
                        ...parts,
                        word,
                        binary: toBinaryString(word),
                        bytes: Uint8Array.from(bytes)
                    };
                },
                fromParts(sign, exponent, mantissa) {
                    const s = (sign ? 1 : 0) & 0x1;
                    const e = exponent & 0xff;
                    const m = mantissa & 0x7fffff;
                    const word = (s << 31) | (e << 23) | m;
                    view.setUint32(0, word, true);
                    return {
                        value: view.getFloat32(0, true),
                        sign: s,
                        exponent: e,
                        mantissa: m,
                        word,
                        binary: toBinaryString(word),
                        bytes: Uint8Array.from(bytes)
                    };
                },
                toBytes(value, littleEndian = true) {
                    view.setFloat32(0, value, littleEndian);
                    return Uint8Array.from(bytes);
                },
                fromBytes(byteArray, littleEndian = true) {
                    if (!byteArray || byteArray.length < 4) {
                        return null;
                    }
                    bytes.set(byteArray.slice(0, 4));
                    const word = view.getUint32(0, littleEndian);
                    const parts = splitWord(word);
                    return {
                        ...parts,
                        word,
                        binary: toBinaryString(word),
                        value: view.getFloat32(0, littleEndian)
                    };
                }
            };
        })();
        
        // LOD —Å–∏—Å—Ç–µ–º–∞ (Level of Detail) - 3 —É—Ä–æ–≤–Ω—è –∫–∞–∫ –≤ Minecraft
        const LOD_LEVELS = {
            FULL: { 
                chunkDistanceMin: 0,
                chunkDistanceMax: 4, // 0-4 —á–∞–Ω–∫–∞
                distanceMax: 64,
                distanceMaxHysteresis: 68,
                textureQuality: 'high',
                visible: true,
                simplify: false
            },
            MEDIUM: { 
                chunkDistanceMin: 5,
                chunkDistanceMax: 8, // 5-8 —á–∞–Ω–∫–æ–≤
                distanceMax: 128,
                distanceMaxHysteresis: 136,
                textureQuality: 'medium',
                visible: true,
                simplify: false
            },
            LOW: { 
                chunkDistanceMin: 9,
                chunkDistanceMax: 12, // 9-12 —á–∞–Ω–∫–æ–≤
                distanceMax: 192,
                distanceMaxHysteresis: 200,
                textureQuality: 'low',
                visible: true,
                simplify: true // —É–ø—Ä–æ—â–µ–Ω–Ω—ã–µ –º–æ–¥–µ–ª–∏
            },
            HIDDEN: { 
                chunkDistanceMin: 13,
                visible: false
            }
        };
        let lodUpdateTimer = 0;
        let chunkLODCache = new Map();
        
        const BLOCK_TYPES = {
            grass: { color: 0x228B22, name: '–¢—Ä–∞–≤–∞' },
            dirt: { color: 0x8B4513, name: '–ó–µ–º–ª—è' },
            stone: { color: 0x808080, name: '–ö–∞–º–µ–Ω—å' },
            wood: { color: 0x654321, name: '–î–µ—Ä–µ–≤–æ' },
            leaves: { color: 0x00AA00, name: '–õ–∏—Å—Ç–≤–∞' },
            water: { color: 0x1E90FF, name: '–í–æ–¥–∞' }
        };
        
        // === –¢–ï–ö–°–¢–£–† –ü–ê–ö ===
        let sharedGeometry = null; // –û–±—â–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—è –¥–ª—è –≤—Å–µ—Ö –±–ª–æ–∫–æ–≤
        let waterSurfaceGeometry = null;
        let waterSurfaceMaterial = null;
        let sharedMaterials = {}; // –ö—ç—à –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ –¥–ª—è –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        let tallGrassGeometry = null;
        let tallGrassMaterial = null;
        const textureLoader = new THREE.TextureLoader();
        
        function createPixelTexture(pattern, size = 16) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            pattern(ctx, size);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestMipmapNearestFilter; // –ü–∏–∫—Å–µ–ª—å–Ω—ã–π —Å—Ç–∏–ª—å —Å mipmaps
            texture.generateMipmaps = true;
            texture.anisotropy = 1; // –û—Ç–∫–ª—é—á–∞–µ–º –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–∏—é –¥–ª—è –ø–∏–∫—Å–µ–ª—å–Ω–æ–π –≥—Ä–∞—Ñ–∏–∫–∏
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º mipMapBias, —á—Ç–æ–±—ã —Ç–µ–∫—Å—Ç—É—Ä—ã –±—ã—Å—Ç—Ä–µ–µ —Ç–µ—Ä—è–ª–∏ –∫–∞—á–µ—Å—Ç–≤–æ —Å —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ–º (—ç—Ñ—Ñ–µ–∫—Ç "–ø–ª–æ—Ö–æ–π –≥—Ä–∞—Ñ–∏–∫–∏" –≤–¥–∞–ª–∏)
            texture.mipMapBias = 2.0; 
            return texture;
        }

        function applyNearestFilters(tex) {
            if (!tex) return tex;
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestMipmapNearestFilter;
            tex.generateMipmaps = true;
            tex.anisotropy = 1;
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º mipMapBias –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ —É—Ö—É–¥—à–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞ –≤–¥–∞–ª–∏
            tex.mipMapBias = 2.0;
            tex.needsUpdate = true;
            return tex;
        }

        function rebuildGrassMaterials() {
            if (!textures.grass_side || !textures.grass_top || !textures.dirt) {
                return;
            }
            sharedMaterials.grass = [
                new THREE.MeshLambertMaterial({ map: textures.grass_side }),
                new THREE.MeshLambertMaterial({ map: textures.grass_side }),
                new THREE.MeshLambertMaterial({ map: textures.grass_top }),
                new THREE.MeshLambertMaterial({ map: textures.dirt }),
                new THREE.MeshLambertMaterial({ map: textures.grass_side }),
                new THREE.MeshLambertMaterial({ map: textures.grass_side })
            ];
        }

        function refreshTallGrassMaterial() {
            if (!tallGrassMaterial || !textures.tall_grass) {
                return;
            }
            tallGrassMaterial.map = textures.tall_grass;
            tallGrassMaterial.needsUpdate = true;
            if (worldDecorations && worldDecorations.size) {
                worldDecorations.forEach((deco) => {
                    deco.traverse((child) => {
                        if (child.isMesh) {
                            child.material = tallGrassMaterial;
                        }
                    });
                });
            }
        }

        function loadTextureWithFallback(url, key, fallbackFactory) {
            const fallback = applyNearestFilters(fallbackFactory());
            textures[key] = fallback;
            textureLoader.load(
                url,
                (tex) => {
                    textures[key] = applyNearestFilters(tex);
                    if (key === 'grass_top' || key === 'grass_side') {
                        rebuildGrassMaterials();
                        refreshWorldMaterials();
                    } else if (key === 'tall_grass') {
                        refreshTallGrassMaterial();
                    }
                    iconCache.clear();
                    refreshInventoryUI();
                },
                undefined,
                () => {
                    /* –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: –æ—Å—Ç–∞—ë–º—Å—è –Ω–∞ fallback */
                }
            );
            return textures[key];
        }
        
        // === –®–ï–ô–î–ï–†–ù–ê–Ø –ê–ù–ò–ú–ê–¶–ò–Ø (–í–ï–¢–ï–†) ===
        const globalUniforms = {
            time: { value: 0 }
        };

        function applyWindShader(material, type = 'foliage') {
            material.onBeforeCompile = (shader) => {
                shader.uniforms.time = globalUniforms.time;
                
                shader.vertexShader = `
                    uniform float time;
                    ${shader.vertexShader}
                `;

                if (type === 'foliage') {
                    // –î–ª—è –ª–∏—Å—Ç–≤—ã –∏ —Ç—Ä–∞–≤—ã: –∫–∞—á–∞–Ω–∏–µ –≤–µ—Ä—Ö—É—à–µ–∫
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        `
                        #include <begin_vertex>
                        
                        float windStrength = 0.02; // –°–∏–ª–∞ –≤–µ—Ç—Ä–∞ (–µ—â–µ —É–º–µ–Ω—å—à–µ–Ω–æ)
                        float windSpeed = 1.0;     // –°–∫–æ—Ä–æ—Å—Ç—å –≤–µ—Ç—Ä–∞
                        
                        // –°–º–µ—â–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –≤—ã—Å–æ—Ç—ã (y) –∏ –ø–æ–∑–∏—Ü–∏–∏ (x, z)
                        // (transformed.y + 0.5) –¥–∞–µ—Ç 0 –≤–Ω–∏–∑—É –±–ª–æ–∫–∞ –∏ 1 –≤–≤–µ—Ä—Ö—É (–¥–ª—è BoxGeometry 1x1x1)
                        float heightFactor = max(0.0, transformed.y + 0.5); 
                        
                        float waveX = sin(time * windSpeed + position.x + position.z) * windStrength * heightFactor;
                        float waveZ = cos(time * windSpeed * 0.8 + position.x * 0.5 + position.z * 0.5) * windStrength * heightFactor;
                        
                        transformed.x += waveX;
                        transformed.z += waveZ;
                        `
                    );
                } else if (type === 'water') {
                    // –î–ª—è –≤–æ–¥—ã: –≤–æ–ª–Ω—ã –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        `
                        #include <begin_vertex>
                        
                        float waveHeight = 0.05;
                        float waveSpeed = 1.5;
                        
                        // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ (–≤–æ–ª–Ω—ã)
                        float waveY = sin(time * waveSpeed + position.x * 1.5 + position.z * 1.5) * waveHeight;
                        
                        transformed.y += waveY;
                        `
                    );
                }
            };
        }

        function initTextures() {
            // –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä –Ω–∞–ø—Ä—è–º—É—é –∏–∑ —Ñ–∞–π–ª–æ–≤ (–±–µ–∑ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏)
            const loadTex = (path) => {
                const tex = textureLoader.load(path);
                tex.magFilter = THREE.NearestFilter;
                tex.minFilter = THREE.NearestFilter;
                return tex;
            };

            textures.grass_top = loadTex('textures/grass_top.png');
            textures.grass_side = loadTex('textures/grass_side.png');
            textures.dirt = loadTex('textures/dirt.png');
            textures.stone = loadTex('textures/stone.png');
            textures.wood_top = loadTex('textures/wood_top.png');
            textures.wood_side = loadTex('textures/wood_side.png');
            textures.leaves = loadTex('textures/leaves.png');
            textures.water = loadTex('textures/water.png');
            textures.tall_grass = loadTex('textures/tall_grass.png');
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è –¥–ª—è –≤–æ–¥—ã
            textures.water.wrapS = THREE.RepeatWrapping;
            textures.water.wrapT = THREE.RepeatWrapping;

            console.log('‚úì –¢–µ–∫—Å—Ç—É—Ä—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –∏–∑ —Ñ–∞–π–ª–æ–≤...');

            iconCache.clear();
            refreshInventoryUI();
            
            // –¢–µ–∫—Å—Ç—É—Ä—ã —Ä–∞–∑—Ä—É—à–µ–Ω–∏—è (–æ—Å—Ç–∞–≤–ª—è–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–º–∏ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã)
            const size = 16;
            for (let stage = 0; stage < 5; stage++) {
                textures[`destroy_${stage}`] = createPixelTexture((ctx, s) => {
                    ctx.fillStyle = 'rgba(0,0,0,0)';
                    ctx.fillRect(0, 0, s, s);
                    const crackCount = (stage + 1) * 8;
                    for (let i = 0; i < crackCount; i++) {
                        const x = Math.random() * s;
                        const y = Math.random() * s;
                        const length = 2 + Math.random() * (stage + 2);
                        const angle = Math.random() * Math.PI * 2;
                        ctx.strokeStyle = 'rgba(0,0,0,' + (0.5 + stage * 0.1) + ')';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                    const darkSpots = (stage + 1) * 3;
                    for (let i = 0; i < darkSpots; i++) {
                        const x = Math.random() * s;
                        const y = Math.random() * s;
                        const size = 1 + Math.random() * 2;
                        ctx.fillStyle = 'rgba(0,0,0,' + (0.3 + stage * 0.1) + ')';
                        ctx.fillRect(x, y, size, size);
                    }
                }, size);
            }
            console.log('‚úì –¢–µ–∫—Å—Ç—É—Ä—ã —Ç—Ä–µ—â–∏–Ω —Å–æ–∑–¥–∞–Ω—ã!');
            
            // –°–æ–∑–¥–∞—ë–º –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã
            sharedMaterials.grass = [
                new THREE.MeshLambertMaterial({ map: textures.grass_side }),
                new THREE.MeshLambertMaterial({ map: textures.grass_side }),
                new THREE.MeshLambertMaterial({ map: textures.grass_top, color: 0x79C05A }), // –ó–µ–ª–µ–Ω—ã–π –æ—Ç—Ç–µ–Ω–æ–∫
                new THREE.MeshLambertMaterial({ map: textures.dirt }),
                new THREE.MeshLambertMaterial({ map: textures.grass_side }),
                new THREE.MeshLambertMaterial({ map: textures.grass_side })
            ];
            
            const dirtMat = new THREE.MeshLambertMaterial({ map: textures.dirt });
            sharedMaterials.dirt = [dirtMat, dirtMat, dirtMat, dirtMat, dirtMat, dirtMat];
            
            const stoneMat = new THREE.MeshLambertMaterial({ map: textures.stone });
            sharedMaterials.stone = [stoneMat, stoneMat, stoneMat, stoneMat, stoneMat, stoneMat];
            
            sharedMaterials.wood = [
                new THREE.MeshLambertMaterial({ map: textures.wood_side }),
                new THREE.MeshLambertMaterial({ map: textures.wood_side }),
                new THREE.MeshLambertMaterial({ map: textures.wood_top }),
                new THREE.MeshLambertMaterial({ map: textures.wood_top }),
                new THREE.MeshLambertMaterial({ map: textures.wood_side }),
                new THREE.MeshLambertMaterial({ map: textures.wood_side })
            ];
            
            const leavesMat = new THREE.MeshLambertMaterial({ 
                map: textures.leaves,
                transparent: true,
                alphaTest: 0.5,
                color: 0x79C05A // –ó–µ–ª–µ–Ω—ã–π –æ—Ç—Ç–µ–Ω–æ–∫
            });
            applyWindShader(leavesMat, 'foliage');
            sharedMaterials.leaves = [leavesMat, leavesMat, leavesMat, leavesMat, leavesMat, leavesMat];

            // –ü—Ä–æ—Å—Ç–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞ —Å–≤–∏–Ω–∏–Ω—ã (–µ—Å–ª–∏ —Ñ–∞–π–ª–∞ –Ω–µ—Ç)
            textures.porkchop_raw = createPixelTexture((ctx, s) => {
                ctx.fillStyle = '#F08080'; ctx.fillRect(2,2,12,12);
            }, 16);
            if (textures.porkchop_raw) {
                const porkMaterials = Array.from({ length: 6 }, () => new THREE.MeshLambertMaterial({ map: textures.porkchop_raw }));
                sharedMaterials.porkchop_raw = porkMaterials;
            }

            tallGrassMaterial = new THREE.MeshLambertMaterial({
                map: textures.tall_grass,
                transparent: true,
                alphaTest: 0.4,
                side: THREE.DoubleSide
            });
            applyWindShader(tallGrassMaterial, 'foliage');
            tallGrassGeometry = new THREE.PlaneGeometry(0.9, 0.9);
            tallGrassGeometry.translate(0, 0.3, 0);
            if (worldDecorations && worldDecorations.size) {
                worldDecorations.forEach((deco) => {
                    deco.traverse((child) => {
                        if (child.isMesh) {
                            child.material = tallGrassMaterial;
                        }
                    });
                });
            }
            
            waterSurfaceMaterial = new THREE.MeshLambertMaterial({
                map: textures.water,
                transparent: true,
                opacity: 0.8,
                depthWrite: false,
                side: THREE.DoubleSide
            });
            applyWindShader(waterSurfaceMaterial, 'water');
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ –≤–æ–¥—ã
            const updateWaterColor = (color, opacity) => {
                if (waterSurfaceMaterial) {
                    waterSurfaceMaterial.color.setHex(color);
                    waterSurfaceMaterial.opacity = opacity;
                }
            };
            updateWaterColor(0x9fd4ff, 0.8);
            waterSurfaceMaterial.needsUpdate = true;
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º BoxGeometry –¥–ª—è –≤–æ–¥—ã, —á—Ç–æ–±—ã –æ–Ω–∞ –∏–º–µ–ª–∞ –æ–±—ä–µ–º
            waterSurfaceGeometry = new THREE.BoxGeometry(1, 1, 1);
            
            // –û–±—â–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—è –¥–ª—è –≤—Å–µ—Ö –±–ª–æ–∫–æ–≤
            sharedGeometry = new THREE.BoxGeometry(1, 1, 1);
            
            console.log('‚úì –ú–∞—Ç–µ—Ä–∏–∞–ª—ã –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω—ã!');

            applyGraphicsPreset();
            refreshWorldMaterials();
        }
        
        function refreshWorldMaterials() {
            if (!worldBlocks || worldBlocks.size === 0) {
                return;
            }
            const enableShadows = !!(renderer?.shadowMap?.enabled && (activeGraphicsPreset?.shadows ?? false));
            worldBlocks.forEach((mesh) => {
                if (!mesh || !mesh.userData) {
                    return;
                }
                const type = mesh.userData.type;
                if (type === 'water') {
                    if (waterSurfaceMaterial) {
                        mesh.material = waterSurfaceMaterial;
                    }
                    mesh.castShadow = false;
                    mesh.receiveShadow = false;
                } else if (sharedMaterials[type]) {
                    mesh.material = sharedMaterials[type];
                    mesh.castShadow = enableShadows;
                    mesh.receiveShadow = enableShadows;
                }
            });
        }

        // –°–±–æ—Ä–∫–∞ —Ä–µ–Ω–¥–µ—Ä-–º–µ—à–µ–π —á–∞–Ω–∫–∞ –≤ –∫—Ä—É–ø–Ω—ã–µ –±–∞—Ç—á–∏ –ø–æ –º–∞—Ç–µ—Ä–∏–∞–ª—É (—Å–Ω–∏–∂–µ–Ω–∏–µ draw calls)
        // –î–∞–Ω–Ω—ã–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≥–µ–æ–º–µ—Ç—Ä–∏–∏ (Face Culling)
        const FACE_VERTICES = [
            [0.5, -0.5, 0.5,  0.5, -0.5, -0.5,  0.5, 0.5, -0.5,  0.5, 0.5, 0.5], // Right (+x)
            [-0.5, -0.5, -0.5,  -0.5, -0.5, 0.5,  -0.5, 0.5, 0.5,  -0.5, 0.5, -0.5], // Left (-x)
            [-0.5, 0.5, 0.5,  0.5, 0.5, 0.5,  0.5, 0.5, -0.5,  -0.5, 0.5, -0.5], // Top (+y)
            [-0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, 0.5,  -0.5, -0.5, 0.5], // Bottom (-y)
            [-0.5, -0.5, 0.5,  0.5, -0.5, 0.5,  0.5, 0.5, 0.5,  -0.5, 0.5, 0.5], // Front (+z)
            [0.5, -0.5, -0.5,  -0.5, -0.5, -0.5,  -0.5, 0.5, -0.5,  0.5, 0.5, -0.5]  // Back (-z)
        ];
        const FACE_NORMALS = [
            [1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]
        ];
        const FACE_UVS = [0, 0,  1, 0,  1, 1,  0, 1];
        const FACE_INDICES = [0, 1, 2, 0, 2, 3];

        // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Å Face Culling (—Å–∫—Ä—ã—Ç–∏–µ –Ω–µ–≤–∏–¥–∏–º—ã—Ö –≥—Ä–∞–Ω–µ–π)
        function optimizeChunkRendering(chunkGroup) {
            if (!chunkGroup) return;

            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–µ—à–∏
            const toRemove = [];
            chunkGroup.traverse(child => {
                if (child.userData.isOptimizedMesh) toRemove.push(child);
            });
            toRemove.forEach(child => chunkGroup.remove(child));

            // –°–æ–±–∏—Ä–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –±–ª–æ–∫–∏
            const blocks = [];
            chunkGroup.traverse((child) => {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç, —á—Ç–æ–±—ã –∏—Å–∫–ª—é—á–∏—Ç—å –¥–µ–∫–æ—Ä–∞—Ü–∏–∏ (—Ç—Ä–∞–≤—É –∏ —Ç.–¥.)
                if (child.isMesh && !child.userData.isOptimizedMesh && !child.userData.decoration && child.userData.x !== undefined) {
                    blocks.push(child);
                }
            });
            if (blocks.length === 0) return;

            // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º
            const batches = new Map();
            const getBatch = (mat) => {
                if (!batches.has(mat.uuid)) {
                    batches.set(mat.uuid, { material: mat, positions: [], normals: [], uvs: [], indices: [], vertCount: 0 });
                }
                return batches.get(mat.uuid);
            };

            blocks.forEach(block => {
                const bx = block.userData.x;
                const by = block.userData.y;
                const bz = block.userData.z;
                const type = block.userData.type;

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º 6 –≥—Ä–∞–Ω–µ–π
                const neighbors = [
                    { dx: 1, dy: 0, dz: 0, face: 0 }, // Right
                    { dx: -1, dy: 0, dz: 0, face: 1 }, // Left
                    { dx: 0, dy: 1, dz: 0, face: 2 }, // Top
                    { dx: 0, dy: -1, dz: 0, face: 3 }, // Bottom
                    { dx: 0, dy: 0, dz: 1, face: 4 }, // Front
                    { dx: 0, dy: 0, dz: -1, face: 5 }  // Back
                ];

                neighbors.forEach(n => {
                    const nx = bx + n.dx;
                    const ny = by + n.dy;
                    const nz = bz + n.dz;
                    const nk = `${nx},${ny},${nz}`;
                    
                    let visible = true;
                    // –ï—Å–ª–∏ —Å–æ—Å–µ–¥ –µ—Å—Ç—å
                    if (worldBlocks.has(nk)) {
                        const nb = worldBlocks.get(nk);
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–æ—Å–µ–¥ –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º
                        let isNeighborTransparent = false;
                        if (nb.userData.type === 'water' || nb.userData.type === 'glass') {
                            isNeighborTransparent = true;
                        } else if (nb.userData.type === 'leaves') {
                            // –õ–∏—Å—Ç–≤–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞
                            isNeighborTransparent = activeGraphicsPreset?.leavesTransparent ?? true;
                        }

                        // –ï—Å–ª–∏ —Å–æ—Å–µ–¥ —Ç–≤–µ—Ä–¥—ã–π –∏ –ù–ï –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π -> —Å–∫—Ä—ã–≤–∞–µ–º –≥—Ä–∞–Ω—å
                        if (nb.userData.solid && !isNeighborTransparent) {
                            visible = false;
                        }

                        // –í–æ–¥–∞ –≥—Ä–∞–Ω–∏—á–∏—Ç —Å –≤–æ–¥–æ–π -> —Å–∫—Ä—ã–≤–∞–µ–º
                        if (type === 'water' && nb.userData.type === 'water') visible = false;
                    }

                    if (visible) {
                        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª –≥—Ä–∞–Ω–∏
                        let mat = block.material;
                        if (Array.isArray(mat)) mat = mat[n.face];
                        if (!mat) return;

                        const batch = getBatch(mat);
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º –≤–µ—Ä—à–∏–Ω—ã
                        const verts = FACE_VERTICES[n.face];
                        for (let i = 0; i < 12; i += 3) {
                            batch.positions.push(verts[i] + bx, verts[i+1] + by, verts[i+2] + bz);
                        }
                        // –ù–æ—Ä–º–∞–ª–∏
                        const norm = FACE_NORMALS[n.face];
                        for (let i = 0; i < 4; i++) {
                            batch.normals.push(norm[0], norm[1], norm[2]);
                        }
                        // UV
                        batch.uvs.push(...FACE_UVS);
                        // –ò–Ω–¥–µ–∫—Å—ã
                        const vOffset = batch.vertCount;
                        FACE_INDICES.forEach(idx => batch.indices.push(vOffset + idx));
                        batch.vertCount += 4;
                    }
                });

                // –°–∫—Ä—ã–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª, –Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è —Ñ–∏–∑–∏–∫–∏
                block.visible = false;
                block.layers.set(1);
            });

            // –°–æ–∑–¥–∞–µ–º –º–µ—à–∏
            batches.forEach(batch => {
                if (batch.positions.length === 0) return;
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(batch.positions, 3));
                geo.setAttribute('normal', new THREE.Float32BufferAttribute(batch.normals, 3));
                geo.setAttribute('uv', new THREE.Float32BufferAttribute(batch.uvs, 2));
                geo.setIndex(batch.indices);
                
                const mesh = new THREE.Mesh(geo, batch.material);
                mesh.userData.isOptimizedMesh = true;
                mesh.userData.chunkGroup = chunkGroup;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                chunkGroup.add(mesh);
            });
        }

        function setSharedMaterialsShading(flat) {
            if (!sharedMaterials) {
                return;
            }
            Object.values(sharedMaterials).forEach((materialEntry) => {
                if (!materialEntry) {
                    return;
                }
                if (Array.isArray(materialEntry)) {
                    materialEntry.forEach((mat) => {
                        if (!mat) {
                            return;
                        }
                        if (mat.flatShading !== flat) {
                            mat.flatShading = flat;
                            mat.needsUpdate = true;
                        }
                    });
                } else if (materialEntry.flatShading !== flat) {
                    materialEntry.flatShading = flat;
                    materialEntry.needsUpdate = true;
                }
            });
        }

        function updateWorldShadowState(enableShadows) {
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–Ω–∏ –¥–ª—è –≤—Å–µ—Ö —á–∞–Ω–∫–æ–≤ (–≤–∫–ª—é—á–∞—è InstancedMesh)
            chunks.forEach(chunkGroup => {
                chunkGroup.traverse(child => {
                    if (child.isMesh) {
                        // –í–æ–¥–∞ –Ω–µ –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ—Ç —Ç–µ–Ω–∏
                        if (child.userData.type === 'water' || child.name.includes('water')) {
                            child.castShadow = false;
                            child.receiveShadow = enableShadows; // –í–æ–¥–∞ –º–æ–∂–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Ç–µ–Ω–∏
                        } else {
                            child.castShadow = enableShadows;
                            child.receiveShadow = enableShadows;
                        }
                    }
                });
            });
        }

        function createZombie(x, y, z) {
            const zombie = new THREE.Group();
            zombie.position.set(x, y, z);
            
            // –ì–æ–ª–æ–≤–∞ (8x10x8)
            const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const headMat = new THREE.MeshLambertMaterial({ color: 0x7CFC00 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.5;
            zombie.add(head);
            
            // –¢—É–ª–æ–≤–∏—â–µ (8x12x4)
            const bodyGeo = new THREE.BoxGeometry(0.5, 0.75, 0.25);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.875;
            zombie.add(body);
            
            // –†—É–∫–∏
            const armGeo = new THREE.BoxGeometry(0.25, 0.75, 0.25);
            const armMat = new THREE.MeshLambertMaterial({ color: 0x7CFC00 });
            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(-0.375, 0.875, 0);
            zombie.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(0.375, 0.875, 0);
            zombie.add(rightArm);
            
            // –ù–æ–≥–∏
            const legGeo = new THREE.BoxGeometry(0.25, 0.75, 0.25);
            const legMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.125, 0.125, 0);
            zombie.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.125, 0.125, 0);
            zombie.add(rightLeg);
            
            zombie.userData = {
                isZombie: true,
                velocity: new THREE.Vector3(0, 0, 0),
                walkTime: 0,
                health: 20,
                isBurning: false,
                burnDamage: 0,
                seekingShadow: false,
                parts: { head, body, leftArm, rightArm, leftLeg, rightLeg }
            };
            
            scene.add(zombie);
            zombies.push(zombie);
            return zombie;
        }

        function raycastPassiveAnimal(maxDistance = 4.5) {
            if (!passiveAnimals.length) {
                return null;
            }
            animalRaycaster.setFromCamera(screenCenter, camera);
            animalRaycaster.far = maxDistance;
            const origin = animalRaycaster.ray.origin;
            let closestAnimal = null;
            let closestDist = maxDistance;

            for (const animal of passiveAnimals) {
                if (!animal || !animal.visible) {
                    continue;
                }
                tempBox.setFromObject(animal);
                if (tempBox.isEmpty()) {
                    continue;
                }
                const hitPoint = animalRaycaster.ray.intersectBox(tempBox, tempVecA);
                if (!hitPoint) {
                    continue;
                }
                const dist = origin.distanceTo(hitPoint);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestAnimal = animal;
                }
            }

            return closestAnimal ? { animal: closestAnimal, distance: closestDist } : null;
        }

        function raycastDecoration(maxDistance = 4.5) {
            if (!worldDecorations.size) {
                return null;
            }
            decorationRaycaster.setFromCamera(screenCenter, camera);
            decorationRaycaster.far = maxDistance;
            const decorations = Array.from(worldDecorations.values());
            if (!decorations.length) {
                return null;
            }
            const hits = decorationRaycaster.intersectObjects(decorations, true);
            if (!hits.length) {
                return null;
            }
            for (const hit of hits) {
                const key = hit.object?.userData?.decorationKey;
                if (key) {
                    return { key, distance: hit.distance };
                }
            }
            return null;
        }

        function removePassiveAnimal(animal, dropLoot = false) {
            if (!animal) {
                return;
            }
            const index = passiveAnimals.indexOf(animal);
            if (index !== -1) {
                passiveAnimals.splice(index, 1);
            }
            const data = animal.userData;
            if (data && Array.isArray(data.materials)) {
                data.materials.forEach((mat) => {
                    if (!mat || !('emissive' in mat)) {
                        return;
                    }
                    mat.emissive.setHex(0x000000);
                    mat.emissiveIntensity = 0;
                });
            }
            if (animal.parent) {
                animal.parent.remove(animal);
            }
            if (dropLoot) {
                const drops = 1 + Math.floor(Math.random() * 2);
                for (let i = 0; i < drops; i++) {
                    const jitterX = (Math.random() - 0.5) * 0.6;
                    const jitterZ = (Math.random() - 0.5) * 0.6;
                    spawnItemDrop('porkchop_raw', animal.position.x + jitterX, animal.position.y + 0.35, animal.position.z + jitterZ, {
                        quantity: 1,
                        velocityJitter: 0.2,
                        initialVelocity: new THREE.Vector3((Math.random() - 0.5) * 1.2, 1 + Math.random() * 0.4, (Math.random() - 0.5) * 1.2)
                    });
                }
            }
        }

        function attackPassiveAnimal(animal, damage = 3) {
            if (!animal || !animal.userData) {
                return;
            }
            const data = animal.userData;
            if (typeof data.health !== 'number') {
                return;
            }
            if (data.hurtCooldown && data.hurtCooldown > 0) {
                return;
            }

            data.health -= damage;
            data.hurtCooldown = 0.35;
            data.flashTimer = 0.25;
            data.panicTimer = 5.0;

            tempVecB.set(animal.position.x - player.position.x, 0, animal.position.z - player.position.z);
            const len = tempVecB.length();
            if (len > 0.0001) {
                tempVecB.divideScalar(len).multiplyScalar(0.45);
                animal.position.x += tempVecB.x;
                animal.position.z += tempVecB.z;
            }

            soundManager.play('pig_hurt');

            if (data.health <= 0) {
                soundManager.play('pig_death');
                removePassiveAnimal(animal, true);
            }
        }

        function createPig(x, y, z) {
            const pig = new THREE.Group();
            pig.position.set(x, y, z);

            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xF1A7B3 });
            const accentMaterial = new THREE.MeshLambertMaterial({ color: 0xD9869E });
            const hoofMaterial = new THREE.MeshLambertMaterial({ color: 0x4A2C2E });
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });

            // –†–∞–∑–º–µ—Ä—ã –∫–∞–∫ –≤ Minecraft (–ø—Ä–∏–º–µ—Ä–Ω–æ)
            // 1 –±–ª–æ–∫ = 16 –ø–∏–∫—Å–µ–ª–µ–π
            // –ù–æ–≥–∏: 4x6x4 px -> 0.25 x 0.375 x 0.25
            // –¢–µ–ª–æ: 10x8x16 px (–ø–æ–≤–µ—Ä–Ω—É—Ç–æ) -> 0.625 x 0.5 x 1.0
            // –ì–æ–ª–æ–≤–∞: 8x8x8 px -> 0.5 x 0.5 x 0.5

            const legW = 0.25;
            const legH = 0.375;
            const bodyW = 0.625;
            const bodyH = 0.5;
            const bodyL = 1.0;
            const headS = 0.5;

            // –°–º–µ—â–µ–Ω–∏–µ –≤–Ω–∏–∑, —á—Ç–æ–±—ã –Ω–æ–≥–∏ —á—É—Ç—å —É—Ç–æ–ø–∞–ª–∏ –≤ —Ç—Ä–∞–≤–µ (—Ñ–∏–∫—Å "–ª–µ—Ç–∞–Ω–∏—è")
            const yOffset = 0;

            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyL), bodyMaterial);
            // –¢–µ–ª–æ –ª–µ–∂–∏—Ç –Ω–∞ –Ω–æ–≥–∞—Ö. –ù–æ–≥–∏ –≤—ã—Å–æ—Ç–æ–π 0.375. –¶–µ–Ω—Ç—Ä —Ç–µ–ª–∞ –Ω–∞ 0.375 + 0.25 = 0.625
            // –û–ø—É—Å–∫–∞–µ–º —Ç–µ–ª–æ —á—É—Ç—å –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ–Ω–æ –ø–ª–æ—Ç–Ω–µ–µ —Å–∏–¥–µ–ª–æ –Ω–∞ –Ω–æ–≥–∞—Ö
            body.position.set(0, 0.6 + yOffset, 0);
            pig.add(body);

            // Head Group (–¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è)
            const headGroup = new THREE.Group();
            // –ì–æ–ª–æ–≤–∞ –∫—Ä–µ–ø–∏—Ç—Å—è —Å–ø–µ—Ä–µ–¥–∏ —Ç–µ–ª–∞.
            // –¶–µ–Ω—Ç—Ä –≥–æ–ª–æ–≤—ã –ø–æ Y: 0.375 (–Ω–æ–≥–∏) + 0.5 (—Ç–µ–ª–æ) - 0.25 (–ø–æ–ª–æ–≤–∏–Ω–∞ –≥–æ–ª–æ–≤—ã?) 
            // –í –º–∞–π–Ω–µ –≥–æ–ª–æ–≤–∞ –Ω–∞ —É—Ä–æ–≤–Ω–µ 12px –æ—Ç –∑–µ–º–ª–∏ (0.75).
            // –û–ø—É—Å–∫–∞–µ–º –≥–æ–ª–æ–≤—É –≤–º–µ—Å—Ç–µ —Å —Ç–µ–ª–æ–º
            headGroup.position.set(0, 0.72 + yOffset, 0.55); // –ß—É—Ç—å –≤—ã–¥–≤–∏–Ω—É—Ç–∞ –≤–ø–µ—Ä–µ–¥
            pig.add(headGroup);

            // Head Mesh (–≤–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø—ã)
            const head = new THREE.Mesh(new THREE.BoxGeometry(headS, headS, headS), bodyMaterial.clone());
            head.position.set(0, 0, 0); // –¶–µ–Ω—Ç—Ä –≤ 0,0,0 –≥—Ä—É–ø–ø—ã
            headGroup.add(head);

            // Snout
            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.18, 0.06), accentMaterial);
            snout.position.set(0, -0.1, 0.28); // –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ü–µ–Ω—Ç—Ä–∞ –≥–æ–ª–æ–≤—ã
            headGroup.add(snout);

            // Eyes
            const eyeGeo = new THREE.BoxGeometry(0.08, 0.08, 0.02);
            const leftEye = new THREE.Mesh(eyeGeo, eyeMaterial);
            leftEye.position.set(-0.15, 0.05, 0.26);
            headGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMaterial);
            rightEye.position.set(0.15, 0.05, 0.26);
            headGroup.add(rightEye);

            // Legs
            const legGeometry = new THREE.BoxGeometry(legW, legH, legW);
            const legs = [];
            // –°–º–µ—â–µ–Ω–∏–µ –Ω–æ–≥ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞
            const lx = 0.2;
            const lz = 0.35;
            const legY = legH / 2 + yOffset; // –¶–µ–Ω—Ç—Ä –Ω–æ–≥–∏ –ø–æ Y

            const legOffsets = [
                [-lx, legY, lz],
                [lx, legY, lz],
                [-lx, legY, -lz],
                [lx, legY, -lz]
            ];
            legOffsets.forEach(([x, y, z]) => {
                const leg = new THREE.Mesh(legGeometry, bodyMaterial.clone());
                leg.position.set(x, y, z);
                pig.add(leg);
                legs.push(leg);
            });

            const materialRefs = [];
            pig.traverse((part) => {
                if (part.isMesh) {
                    part.castShadow = true;
                    part.receiveShadow = true;
                    if (part.material) {
                        materialRefs.push(part.material);
                    }
                }
            });

            const angle = Math.random() * Math.PI * 2;
            const direction = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));

            pig.userData = {
                type: 'pig',
                velocity: new THREE.Vector3(0, 0, 0),
                state: 'idle', // idle, wander, flee, look_at
                stateTimer: Math.random() * 3,
                direction: direction,
                baseSpeed: 1.5 + Math.random() * 0.5,
                runSpeed: 4.0,
                currentSpeed: 0,
                walkCycle: Math.random() * Math.PI * 2,
                parts: { legs, headGroup }, // –°—Å—ã–ª–∫–∞ –Ω–∞ –≥—Ä—É–ø–ø—É –≥–æ–ª–æ–≤—ã
                health: 5,
                maxHealth: 5,
                hurtCooldown: 0,
                flashTimer: 0,
                panicTimer: 0,
                soundTimer: Math.random() * 10 + 5,
                materials: materialRefs,
                onGround: false
            };
            pig.userData.currentSpeed = pig.userData.baseSpeed;
            pig.userData.speedTarget = pig.userData.baseSpeed;

            scene.add(pig);
            passiveAnimals.push(pig);
            return pig;
        }

        function spawnPigNearPlayer() {
            for (let attempt = 0; attempt < 6; attempt++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = PASSIVE_SPAWN_RANGE_MIN + Math.random() * (PASSIVE_SPAWN_RANGE_MAX - PASSIVE_SPAWN_RANGE_MIN);
                const targetX = player.position.x + Math.cos(angle) * distance;
                const targetZ = player.position.z + Math.sin(angle) * distance;
                const blockX = Math.floor(targetX) + 0.5;
                const blockZ = Math.floor(targetZ) + 0.5;
                const groundY = findSurfaceHeight(blockX, blockZ);
                if (groundY === null) {
                    continue;
                }
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤–æ–¥—É (–ø—Ä–æ–≤–µ—Ä—è–µ–º –±–ª–æ–∫ –Ω–∞ —É—Ä–æ–≤–Ω–µ –∑–µ–º–ª–∏ –∏ —á—É—Ç—å –≤—ã—à–µ)
                if (isWaterBlock(blockX, groundY - 1, blockZ) || isWaterBlock(blockX, groundY, blockZ)) {
                    continue;
                }
                let crowded = false;
                for (const animal of passiveAnimals) {
                    if (!animal) continue;
                    const dx = animal.position.x - blockX;
                    const dz = animal.position.z - blockZ;
                    if (dx * dx + dz * dz < 16) {
                        crowded = true;
                        break;
                    }
                }
                if (crowded) {
                    continue;
                }
                createPig(blockX, groundY, blockZ);
                break;
            }
        }

        function updatePassiveAnimals(delta) {
            debugStats.animalsRendered = 0;
            const maxUpdateDistance = renderDistance * CHUNK_SIZE * 1.1;
            const playerPos = player.position;
            const GRAVITY = 25.0;

            for (let i = passiveAnimals.length - 1; i >= 0; i--) {
                const animal = passiveAnimals[i];
                if (!animal || !animal.userData) {
                    passiveAnimals.splice(i, 1);
                    continue;
                }

                const dx = playerPos.x - animal.position.x;
                const dz = playerPos.z - animal.position.z;
                const distSq = dx * dx + dz * dz;

                // –î–µ—Å–ø–∞–≤–Ω
                if (distSq > PASSIVE_DESPAWN_DISTANCE * PASSIVE_DESPAWN_DISTANCE) {
                    removePassiveAnimal(animal, false);
                    continue;
                }

                // LOD
                const dist = Math.sqrt(distSq);
                const visible = dist <= maxUpdateDistance;
                animal.visible = visible;
                
                if (!visible) continue;

                debugStats.animalsRendered++;

                // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
                if (!animal.userData.tickOffset) animal.userData.tickOffset = Math.floor(Math.random() * 10);
                const frame = frameCount + animal.userData.tickOffset;
                
                let shouldUpdate = true;
                if (dist > 60) {
                    shouldUpdate = (frame % 10 === 0);
                } else if (dist > 30) {
                    shouldUpdate = (frame % 3 === 0);
                }

                const data = animal.userData;

                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–æ–≤—ã—Ö –ø–æ–ª–µ–π –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç (–¥–ª—è —Å—Ç–∞—Ä—ã—Ö –∂–∏–≤–æ—Ç–Ω—ã—Ö)
                if (!data.velocity) data.velocity = new THREE.Vector3(0, 0, 0);
                if (!data.state) data.state = 'idle';
                if (!data.stateTimer) data.stateTimer = 0;

                // –ï—Å–ª–∏ –Ω–µ –æ–±–Ω–æ–≤–ª—è–µ–º –ª–æ–≥–∏–∫—É, –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏–º–µ–Ω—è–µ–º –∏–Ω–µ—Ä—Ü–∏—é –∏ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é
                if (!shouldUpdate) {
                    if (data.currentSpeed > 0) {
                         animal.position.x += data.direction.x * data.currentSpeed * delta;
                         animal.position.z += data.direction.z * data.currentSpeed * delta;
                    }
                    // –ü—Ä–æ—Å—Ç–∞—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –±–µ–∑ –∫–æ–ª–ª–∏–∑–∏–π –¥–ª—è –¥–∞–ª–µ–∫–∏—Ö
                    // animal.position.y += data.velocity.y * delta; 
                    continue; 
                }

                // --- AI LOGIC ---
                
                // –¢–∞–π–º–µ—Ä—ã —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
                if (data.hurtCooldown > 0) data.hurtCooldown = Math.max(0, data.hurtCooldown - delta);
                if (data.flashTimer > 0) data.flashTimer = Math.max(0, data.flashTimer - delta);
                
                // –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–ª—É—á–µ–Ω–∏—è —É—Ä–æ–Ω–∞
                if (Array.isArray(data.materials)) {
                    const flashActive = data.flashTimer > 0;
                    const intensity = flashActive ? (0.35 + Math.sin(performance.now() * 0.02) * 0.25) : 0;
                    data.materials.forEach((mat) => {
                        if (mat && 'emissive' in mat) {
                            if (flashActive) {
                                mat.emissive.setHex(0xffd4e0);
                                mat.emissiveIntensity = intensity;
                            } else if (mat.emissiveIntensity) {
                                mat.emissive.setHex(0x000000);
                                mat.emissiveIntensity = 0;
                            }
                        }
                    });
                }

                // –ó–≤—É–∫–∏
                if (data.soundTimer !== undefined) {
                    data.soundTimer -= delta;
                    if (data.soundTimer <= 0) {
                        if (dist < 20) soundManager.play('pig_say');
                        data.soundTimer = 3 + Math.random() * 8;
                    }
                }

                // –°–º–µ–Ω–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π
                data.stateTimer -= delta;
                if (data.panicTimer > 0) {
                    data.state = 'flee';
                    data.panicTimer -= delta;
                } else if (data.stateTimer <= 0) {
                    // –í—ã–±–æ—Ä –Ω–æ–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
                    const rand = Math.random();
                    if (rand < 0.4) {
                        data.state = 'idle';
                        data.stateTimer = 2 + Math.random() * 4;
                        data.speedTarget = 0;
                    } else if (rand < 0.8) {
                        data.state = 'wander';
                        data.stateTimer = 3 + Math.random() * 5;
                        const angle = Math.random() * Math.PI * 2;
                        data.direction.set(Math.sin(angle), 0, Math.cos(angle));
                        data.speedTarget = data.baseSpeed;
                    } else {
                        // Look at player
                        data.state = 'look_at';
                        data.stateTimer = 2 + Math.random() * 2;
                        data.speedTarget = 0;
                    }
                }

                // –õ–æ–≥–∏–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π
                if (data.state === 'flee') {
                    const angleAway = Math.atan2(animal.position.x - player.position.x, animal.position.z - player.position.z);
                    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–º–Ω–æ–≥–æ —à—É–º–∞ —á—Ç–æ–±—ã –Ω–µ –±–µ–∂–∞–ª–∏ —Å—Ç—Ä–æ–≥–æ –ø–æ –ø—Ä—è–º–æ–π
                    const noise = (Math.random() - 0.5) * 0.5;
                    data.direction.set(Math.sin(angleAway + noise), 0, Math.cos(angleAway + noise));
                    data.speedTarget = data.runSpeed || (data.baseSpeed * 2.5);
                } else if (data.state === 'look_at' && dist < 10) {
                    const angleTo = Math.atan2(player.position.x - animal.position.x, player.position.z - animal.position.z);
                    data.direction.set(Math.sin(angleTo), 0, Math.cos(angleTo));
                }

                // –ü–ª–∞–≤–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
                data.currentSpeed += (data.speedTarget - data.currentSpeed) * Math.min(1, delta * 5);
                
                // --- PHYSICS & MOVEMENT ---
                
                // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                data.velocity.y -= GRAVITY * delta;
                
                // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ –ø–∞–¥–µ–Ω–∏—è
                if (data.velocity.y < -30) data.velocity.y = -30;

                // –†–∞—Å—á–µ—Ç –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è
                const moveX = data.direction.x * data.currentSpeed * delta;
                const moveZ = data.direction.z * data.currentSpeed * delta;
                const moveY = data.velocity.y * delta;

                const nextX = animal.position.x + moveX;
                const nextZ = animal.position.z + moveZ;
                const nextY = animal.position.y + moveY;

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–µ–º–ª–∏ –ø–æ–¥ –Ω–æ–≥–∞–º–∏ (Raycast –≤–Ω–∏–∑)
                // –ò—â–µ–º –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç (—Ç–µ–∫—É—â–∏–π Y + 1) –¥–æ (—Ç–µ–∫—É—â–∏–π Y - 5)
                const surfaceY = findSurfaceHeight(nextX, nextZ, animal.position.y + 1.5, animal.position.y - 5);
                
                let onGround = false;
                
                if (surfaceY !== null) {
                    // –ï—Å–ª–∏ –º—ã –ø–∞–¥–∞–µ–º –∏ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å –±–ª–∏–∑–∫–æ —Å–Ω–∏–∑—É
                    if (nextY <= surfaceY) {
                        animal.position.y = surfaceY;
                        data.velocity.y = 0;
                        onGround = true;
                    } else {
                        // –ú—ã –≤ –≤–æ–∑–¥—É—Ö–µ
                        animal.position.y = nextY;
                    }
                } else {
                    // –ü—Ä–æ–ø–∞—Å—Ç—å?
                    animal.position.y = nextY;
                }

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å–æ —Å—Ç–µ–Ω–∞–º–∏ (–ø–µ—Ä–µ–¥ —Å–æ–±–æ–π)
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–ª–æ–∫ –ø–µ—Ä–µ–¥ –Ω–∞–º–∏ –Ω–∞ —É—Ä–æ–≤–Ω–µ –≥–ª–∞–∑ –∏ –Ω–æ–≥
                const wallCheckDist = 0.6; // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
                const checkX = animal.position.x + data.direction.x * wallCheckDist;
                const checkZ = animal.position.z + data.direction.z * wallCheckDist;
                
                // –í—ã—Å–æ—Ç–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è –ø–µ—Ä–µ–¥ –Ω–∞–º–∏
                const wallHeight = findSurfaceHeight(checkX, checkZ, animal.position.y + 2, animal.position.y - 1);
                
                let blocked = false;
                if (wallHeight !== null) {
                    const diff = wallHeight - animal.position.y;
                    
                    if (diff > 1.1) {
                        // –í—ã—Å–æ–∫–∞—è —Å—Ç–µ–Ω–∞
                        blocked = true;
                    } else if (diff > 0.1 && onGround) {
                        // –°—Ç—É–ø–µ–Ω—å–∫–∞ (–¥–æ 1 –±–ª–æ–∫–∞) - –ø—Ä—ã–≥–∞–µ–º
                        data.velocity.y = 6; // –°–∏–ª–∞ –ø—Ä—ã–∂–∫–∞
                        onGround = false;
                    }
                }

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–¥—ã
                if (onGround) {
                    if (isWaterBlock(Math.floor(nextX), Math.floor(animal.position.y), Math.floor(nextZ))) {
                        // –í –≤–æ–¥–µ - –≤—Å–ø–ª—ã–≤–∞–µ–º
                        data.velocity.y = 2;
                        data.currentSpeed *= 0.5; // –ó–∞–º–µ–¥–ª–µ–Ω–∏–µ
                    }
                }

                if (blocked) {
                    // –ï—Å–ª–∏ —É–ø–µ—Ä–ª–∏—Å—å –≤ —Å—Ç–µ–Ω—É
                    if (data.state === 'flee') {
                        // –í –ø–∞–Ω–∏–∫–µ –ø—ã—Ç–∞–µ–º—Å—è –ø—Ä—ã–≥–∞—Ç—å –∏–ª–∏ —Å–∫–æ–ª—å–∑–∏—Ç—å
                        if (onGround) data.velocity.y = 6;
                    } else {
                        // –í —Å–ø–æ–∫–æ–π–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏ —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º—Å—è
                        data.direction.negate();
                        // –î–æ–±–∞–≤–ª—è–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç
                        const angle = (Math.random() - 0.5) * 2;
                        const ca = Math.cos(angle);
                        const sa = Math.sin(angle);
                        const nx = data.direction.x * ca - data.direction.z * sa;
                        const nz = data.direction.x * sa + data.direction.z * ca;
                        data.direction.set(nx, 0, nz).normalize();
                        
                        data.stateTimer = 1 + Math.random(); // –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º —Ä–µ—à–µ–Ω–∏–µ–º
                    }
                    // –ù–µ –¥–≤–∏–≥–∞–µ–º—Å—è –≤–ø–µ—Ä–µ–¥ –µ—Å–ª–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã
                    animal.position.x += moveX * 0.1; 
                    animal.position.z += moveZ * 0.1;
                } else {
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ
                    animal.position.x = nextX;
                    animal.position.z = nextZ;
                }

                // –í—Ä–∞—â–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
                if (data.currentSpeed > 0.1) {
                    const targetRotation = Math.atan2(data.direction.x, data.direction.z);
                    // –ü–ª–∞–≤–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç
                    let rotDiff = targetRotation - animal.rotation.y;
                    // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —É–≥–ª–∞
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    
                    animal.rotation.y += rotDiff * delta * 5;
                }

                // –ê–Ω–∏–º–∞—Ü–∏—è —Ö–æ–¥—å–±—ã
                data.walkCycle += data.currentSpeed * delta * 6;
                const swing = Math.sin(data.walkCycle) * 0.25 * Math.min(1, data.currentSpeed / data.baseSpeed);
                if (data.parts?.legs?.length === 4) {
                    data.parts.legs[0].rotation.x = swing;
                    data.parts.legs[1].rotation.x = -swing;
                    data.parts.legs[2].rotation.x = -swing;
                    data.parts.legs[3].rotation.x = swing;
                }
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –≥–æ–ª–æ–≤—ã (–ø–æ–≤–æ—Ä–æ—Ç –∫ –∏–≥—Ä–æ–∫—É –∏–ª–∏ —Å–ª—É—á–∞–π–Ω–æ)
                if (data.parts?.headGroup) {
                    let targetHeadYaw = 0;
                    let targetHeadPitch = 0;

                    if (data.state === 'look_at' || (dist < 8 && data.state !== 'flee')) {
                        // –°–º–æ—Ç—Ä–∏–º –Ω–∞ –∏–≥—Ä–æ–∫–∞
                        const dx = player.position.x - animal.position.x;
                        const dz = player.position.z - animal.position.z;
                        const dy = (player.position.y + 1.6) - (animal.position.y + 0.8); // –ì–ª–∞–∑–∞ –∏–≥—Ä–æ–∫–∞ - –≥–ª–∞–∑–∞ —Å–≤–∏–Ω—å–∏
                        
                        // –£–≥–æ–ª –∫ –∏–≥—Ä–æ–∫—É –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
                        const worldAngle = Math.atan2(dx, dz);
                        // –£–≥–æ–ª –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ç–µ–ª–∞ —Å–≤–∏–Ω—å–∏
                        let localAngle = worldAngle - animal.rotation.y;
                        
                        // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —É–≥–ª–∞ (-PI to PI)
                        while (localAngle > Math.PI) localAngle -= Math.PI * 2;
                        while (localAngle < -Math.PI) localAngle += Math.PI * 2;

                        // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ–≤–æ—Ä–æ—Ç–∞ –≥–æ–ª–æ–≤—ã (—à–µ—è –Ω–µ —Ä–µ–∑–∏–Ω–æ–≤–∞—è)
                        targetHeadYaw = Math.max(-0.8, Math.min(0.8, localAngle));
                        
                        // Pitch (–≤–≤–µ—Ä—Ö-–≤–Ω–∏–∑)
                        const distH = Math.sqrt(dx*dx + dz*dz);
                        targetHeadPitch = -Math.atan2(dy, distH);
                        targetHeadPitch = Math.max(-0.5, Math.min(0.5, targetHeadPitch));
                    } else {
                        // –°–ª—É—á–∞–π–Ω—ã–µ –¥–≤–∏–∂–µ–Ω–∏—è –≥–æ–ª–æ–≤–æ–π –≤ Idle
                        if (Math.random() < 0.02) {
                            data.targetHeadYaw = (Math.random() - 0.5) * 0.5;
                            data.targetHeadPitch = (Math.random() - 0.5) * 0.3;
                        }
                        targetHeadYaw = data.targetHeadYaw || 0;
                        targetHeadPitch = data.targetHeadPitch || 0;
                    }

                    // –ü–ª–∞–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è
                    data.parts.headGroup.rotation.y += (targetHeadYaw - data.parts.headGroup.rotation.y) * delta * 5;
                    data.parts.headGroup.rotation.x += (targetHeadPitch - data.parts.headGroup.rotation.x) * delta * 5;
                }
            }
        }
        
        function updateZombies(delta) {
            const isDay = timeOfDay > 5000 && timeOfDay < 19000;
            const maxUpdateDistance = renderDistance * CHUNK_SIZE * 1.2;
            
            debugStats.zombiesRendered = 0;
            
            for (let i = zombies.length - 1; i >= 0; i--) {
                const zombie = zombies[i];
                
                const dx = player.position.x - zombie.position.x;
                const dz = player.position.z - zombie.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                // Entity LOD - –¥–∞–ª–µ–∫–∏–µ –∑–æ–º–±–∏ —Å–∫—Ä—ã—Ç—ã
                if (dist > maxUpdateDistance) {
                    zombie.visible = false;
                    continue;
                }
                zombie.visible = true;
                debugStats.zombiesRendered++;
                
                // Tick Rate Scaling - –¥–∞–ª–µ–∫–∏–µ –∑–æ–º–±–∏ –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è —Ä–µ–∂–µ
                if (dist > 50) {
                    // –î–∞–ª–µ–∫–∏–µ - –æ–±–Ω–æ–≤–ª—è–µ–º –∫–∞–∂–¥—ã–π 5-–π –∫–∞–¥—Ä
                    if (!zombie.userData.tickCounter) zombie.userData.tickCounter = 0;
                    zombie.userData.tickCounter++;
                    if (zombie.userData.tickCounter < 5) continue;
                    zombie.userData.tickCounter = 0;
                }
                
                const parts = zombie.userData.parts;
                zombie.userData.walkTime += delta * 3;
                
                // –ê–Ω–∏–º–∞—Ü–∏—è —Ö–æ–¥—å–±—ã
                const swing = Math.sin(zombie.userData.walkTime) * 0.3;
                parts.leftArm.rotation.x = swing;
                parts.rightArm.rotation.x = -swing;
                parts.leftLeg.rotation.x = -swing;
                parts.rightLeg.rotation.x = swing;
                
                // –ì–û–†–ï–ù–ò–ï –î–ù–Å–ú
                if (isDay) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –±–ª–æ–∫ –Ω–∞–¥ –∑–æ–º–±–∏ (—Ç–µ–Ω—å)
                    const hasShade = isSolidBlock(zombie.position.x, zombie.position.y + 3, zombie.position.z);
                    
                    if (!hasShade) {
                        // –ù–µ—Ç —Ç–µ–Ω–∏ - –≥–æ—Ä–∏–º!
                        if (!zombie.userData.isBurning) {
                            zombie.userData.isBurning = true;
                            zombie.userData.seekingShadow = true;
                        }
                        zombie.userData.burnDamage += delta * 2;
                        
                        // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –≥–æ—Ä–µ–Ω–∏—è (–∫—Ä–∞—Å–Ω—ã–π —Ü–≤–µ—Ç)
                        Object.values(parts).forEach(part => {
                            if (part.material) {
                                part.material.emissive = new THREE.Color(0xff4400);
                                part.material.emissiveIntensity = 0.5 + Math.sin(zombie.userData.walkTime * 5) * 0.3;
                            }
                        });
                        
                        if (zombie.userData.burnDamage > 10) {
                            // –ó–æ–º–±–∏ —Å–≥–æ—Ä–µ–ª
                            scene.remove(zombie);
                            zombies.splice(i, 1);
                            continue;
                        }
                    } else {
                        // –í —Ç–µ–Ω–∏ - –Ω–µ –≥–æ—Ä–∏–º
                        zombie.userData.isBurning = false;
                        zombie.userData.seekingShadow = false;
                        Object.values(parts).forEach(part => {
                            if (part.material) {
                                part.material.emissive = new THREE.Color(0x000000);
                                part.material.emissiveIntensity = 0;
                            }
                        });
                    }
                } else {
                    zombie.userData.isBurning = false;
                    zombie.userData.seekingShadow = false;
                }
                
                // –î–í–ò–ñ–ï–ù–ò–ï –ò –ê–¢–ê–ö–ê
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–∂–µ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—É—é –¥–∏—Å—Ç–∞–Ω—Ü–∏—é dist
                
                if (zombie.userData.seekingShadow) {
                    // –ò—â–µ–º –±–ª–∏–∂–∞–π—à–∏–π –±–ª–æ–∫ —Å —Ç–µ–Ω—å—é
                    let nearestShade = null;
                    let minDist = Infinity;
                    
                    for (let ox = -10; ox <= 10; ox += 2) {
                        for (let oz = -10; oz <= 10; oz += 2) {
                            const checkX = Math.floor(zombie.position.x + ox);
                            const checkZ = Math.floor(zombie.position.z + oz);
                            const checkY = Math.floor(zombie.position.y);
                            
                            if (isSolidBlock(checkX, checkY + 3, checkZ)) {
                                const d = Math.sqrt(ox * ox + oz * oz);
                                if (d < minDist) {
                                    minDist = d;
                                    nearestShade = { x: checkX, z: checkZ };
                                }
                            }
                        }
                    }
                    
                    if (nearestShade) {
                        const sdx = nearestShade.x - zombie.position.x;
                        const sdz = nearestShade.z - zombie.position.z;
                        const sdist = Math.sqrt(sdx * sdx + sdz * sdz);
                        if (sdist > 0.5) {
                            const speed = 2 * delta;
                            zombie.position.x += (sdx / sdist) * speed;
                            zombie.position.z += (sdz / sdist) * speed;
                            zombie.rotation.y = Math.atan2(sdx, sdz);
                        }
                    }
                } else if (!isDead && dist > 1 && dist < 30) {
                    // –ü—Ä–µ—Å–ª–µ–¥—É–µ–º –∏–≥—Ä–æ–∫–∞
                    const speed = 1.5 * delta;
                    zombie.position.x += (dx / dist) * speed;
                    zombie.position.z += (dz / dist) * speed;
                    zombie.rotation.y = Math.atan2(dx, dz);
                    
                    // –ê–¢–ê–ö–ê –ò–ì–†–û–ö–ê
                    if (dist < 2) {
                        const now = performance.now();
                        if (now - lastDamageTime > 1000) { // Cooldown 1 —Å–µ–∫—É–Ω–¥–∞
                            damagePlayer(1);
                            lastDamageTime = now;
                        }
                    }
                }
            }
        }
        
        function damagePlayer(damage, options = {}) {
            if (isDead || damage <= 0) {
                return;
            }

            const { allowFatal = true } = options;
            const maxLoss = allowFatal ? playerHealth : Math.max(0, playerHealth - 1);
            if (maxLoss <= 0) {
                return;
            }

            const appliedDamage = Math.min(damage, maxLoss);
            if (appliedDamage <= 0) {
                return;
            }

            playerHealth = Math.max(allowFatal ? 0 : 1, playerHealth - appliedDamage);
            updateHealthBar();
            soundManager.play('player_hurt');

            if (playerHealth <= 0 && allowFatal) {
                isDead = true;
                soundManager.play('player_death');
                soundManager.stopAmbience();
                showDeathScreen();
            }
        }
        
        function updateHealthBar() {
            const row = document.getElementById('heartsRow');
            if (!row) {
                return;
            }
            const icons = row.querySelectorAll('.heart-icon');
            const activeHearts = Math.min(icons.length, Math.max(0, Math.floor(playerHealth)));
            icons.forEach((icon, index) => {
                if (index < activeHearts) {
                    icon.classList.remove('inactive');
                } else {
                    icon.classList.add('inactive');
                }
            });

            if (playerHealth < lastUIHealth) {
                row.classList.add('damage');
                clearTimeout(heartShakeTimeout);
                heartShakeTimeout = setTimeout(() => row.classList.remove('damage'), 420);
            } else if (playerHealth >= lastUIHealth) {
                row.classList.remove('damage');
            }

            lastUIHealth = playerHealth;
        }

        function updateHungerBar() {
            const row = document.getElementById('hungerRow');
            if (!row) {
                return;
            }
            const icons = row.querySelectorAll('.hunger-icon');
            const activeIcons = Math.min(icons.length, Math.max(0, Math.floor(playerHunger)));
            icons.forEach((icon, index) => {
                if (index < activeIcons) {
                    icon.classList.remove('inactive');
                    icon.classList.add('active');
                } else {
                    icon.classList.add('inactive');
                    icon.classList.remove('active');
                }
            });

            if (playerHunger <= 2) {
                row.classList.add('critical');
            } else {
                row.classList.remove('critical');
            }
        }

        function updateExperienceBar() {
            const indicator = document.getElementById('xpIndicator');
            if (!indicator) {
                return;
            }
            indicator.textContent = `LV ${experienceLevel}`;
        }

        function adjustHunger(delta) {
            const previous = playerHunger;
            playerHunger = Math.max(0, Math.min(PLAYER_MAX_HUNGER, playerHunger + delta));
            if (playerHunger !== previous) {
                updateHungerBar();
            }
        }

        function applyStarvationTick() {
            if (playerHealth <= 1) {
                return;
            }
            damagePlayer(1, { allowFatal: false });
        }

        function updateHungerAndStarvation(delta, sprinting) {
            if (sprinting && playerHunger > 0) {
                sprintHungerTimer += delta;
                if (sprintHungerTimer >= HUNGER_SPRINT_COST_INTERVAL) {
                    sprintHungerTimer = 0;
                    adjustHunger(-1);
                }
            } else {
                sprintHungerTimer = Math.max(0, sprintHungerTimer - delta * 0.5);
            }

            if (playerHunger <= 0) {
                starvationTimer += delta;
                if (starvationTimer >= STARVATION_TICK_INTERVAL) {
                    starvationTimer = 0;
                    applyStarvationTick();
                }
            } else {
                starvationTimer = 0;
            }
        }

        function handleFallDamage(fallDistance) {
            if (fallDistance <= SAFE_FALL_HEIGHT) {
                return;
            }
            const excess = Math.max(0, fallDistance - SAFE_FALL_HEIGHT);
            if (excess <= 0) {
                return;
            }
            const damage = Math.max(1, Math.round(Math.pow(excess, FALL_DAMAGE_POWER)));
            damagePlayer(damage);
        }

        function consumeSelectedFood() {
            if (eatCooldown > 0) {
                return false;
            }
            const stack = getSelectedHotbarStack();
            if (!stack) {
                return false;
            }
            const definition = getItemDefinition(stack.id);
            if (!definition || !definition.hungerRestore) {
                return false;
            }
            if (playerHunger >= PLAYER_MAX_HUNGER) {
                return false;
            }

            adjustHunger(definition.hungerRestore);
            eatCooldown = EAT_COOLDOWN;
            stack.qty -= 1;
            if (stack.qty <= 0) {
                inventoryState.hotbar[player.selectedSlot] = null;
            }
            refreshInventoryUI();
            soundManager.play('item_pickup');
            return true;
        }
        
        function showDeathScreen() {
            document.exitPointerLock();
            document.getElementById('deathScreen').classList.add('visible');
        }
        
        function respawnPlayer() {
            // –ò—â–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
            let spawnY = 10;
            for (let y = 20; y > 0; y--) {
                if (isSolidBlock(0, y, 0)) {
                    spawnY = y + 0.5 + PLAYER_HEIGHT; // –°–ø–∞–≤–Ω —Å —É—á—ë—Ç–æ–º –≤—ã—Å–æ—Ç—ã –∏–≥—Ä–æ–∫–∞
                    break;
                }
            }
            
            player.position.set(0, spawnY, 0);
            player.velocity.set(0, 0, 0);
            playerHealth = PLAYER_MAX_HEALTH;
            playerHunger = PLAYER_MAX_HUNGER;
            experienceProgress = 0;
            isDead = false;
            updateHealthBar();
            updateHungerBar();
            updateExperienceBar();
            
            document.getElementById('deathScreen').classList.remove('visible');
            setTimeout(() => {
                safeRequestPointerLock();
            }, 100);
            soundManager.startAmbience();
        }
        
        function createClouds() {
            if (clouds && clouds.length) {
                clouds.forEach((cloud) => scene.remove(cloud));
            }
            clouds = [];
            
            // –ú–∞—Ç–µ—Ä–∏–∞–ª –æ–±–ª–∞–∫–æ–≤
            const cloudMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });

            // –ù–∞–±–æ—Ä –≥–µ–æ–º–µ—Ç—Ä–∏–π –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è —Ñ–æ—Ä–º
            const geometries = [
                new THREE.BoxGeometry(16, 4, 12),
                new THREE.BoxGeometry(20, 5, 14),
                new THREE.BoxGeometry(12, 3, 10),
                new THREE.BoxGeometry(24, 6, 16),
                new THREE.BoxGeometry(14, 4, 14)
            ];
            
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏ —Ä–∞–∑–±—Ä–æ—Å
            const cloudCount = 60;
            const spawnArea = 512; 

            for (let i = 0; i < cloudCount; i++) {
                const geo = geometries[Math.floor(Math.random() * geometries.length)];
                const cloud = new THREE.Mesh(geo, cloudMaterial);
                
                cloud.position.set(
                    (Math.random() - 0.5) * spawnArea,
                    90 + Math.random() * 30, // –í—ã—Å–æ—Ç–∞ –æ—Ç 90 –¥–æ 120
                    (Math.random() - 0.5) * spawnArea
                );
                
                cloud.userData.isCloud = true;
                cloud.userData.speed = 1.5 + Math.random() * 3.0;
                
                scene.add(cloud);
                clouds.push(cloud);
            }
            console.log('‚úì –û–±–ª–∞–∫–∞ —Å–æ–∑–¥–∞–Ω—ã (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ)');
        }

        function updateLeavesMaterial() {
            if (!sharedMaterials.leaves) return;
            
            const isTransparent = activeGraphicsPreset.leavesTransparent;
            
            sharedMaterials.leaves.forEach(mat => {
                if (mat) {
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º alphaTest –¥–ª—è "–≤—ã—Ä–µ–∑–∞–Ω–∏—è" –ø—Ä–æ–∑—Ä–∞—á–Ω—ã—Ö —á–∞—Å—Ç–µ–π
                    // transparent: false –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é –∑–∞–ø–∏—Å—å –≤ depth buffer –∏ —Ç–µ–Ω–∏
                    mat.transparent = false;
                    mat.alphaTest = isTransparent ? 0.5 : 0;
                    mat.side = THREE.DoubleSide; // –õ–∏—Å—Ç–≤–∞ –≤–∏–¥–Ω–∞ —Å –æ–±–µ–∏—Ö —Å—Ç–æ—Ä–æ–Ω
                    mat.shadowSide = THREE.DoubleSide; // –¢–µ–Ω–∏ –æ—Ç –æ–±–µ–∏—Ö —Å—Ç–æ—Ä–æ–Ω
                    mat.needsUpdate = true;
                }
            });
        }

        function applyGraphicsPreset() {
            activeGraphicsPreset = GRAPHICS_PRESETS[graphicsQuality] || GRAPHICS_PRESETS.medium;
            if (typeof THREE !== 'undefined') {
                activeSkyColors = {
                    dawn: new THREE.Color(activeGraphicsPreset.sky.dawn),
                    day: new THREE.Color(activeGraphicsPreset.sky.day),
                    noon: new THREE.Color(activeGraphicsPreset.sky.noon || activeGraphicsPreset.sky.day),
                    dusk: new THREE.Color(activeGraphicsPreset.sky.dusk),
                    night: new THREE.Color(activeGraphicsPreset.sky.night)
                };
            }

            applyRenderDistanceSetting(renderDistance, graphicsQuality);

            smoothLighting = activeGraphicsPreset.smoothLighting;
            fancyClouds = activeGraphicsPreset.fancyClouds;
            particlesEnabled = activeGraphicsPreset.particles;
            shadowsEnabled = !!activeGraphicsPreset.shadows;

            setSharedMaterialsShading(!smoothLighting);
            updateLeavesMaterial();

            // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª –≤–æ–¥—ã
            if (waterSurfaceMaterial) {
                const wColor = activeGraphicsPreset.waterColor;
                const wOpacity = activeGraphicsPreset.waterOpacity;
                if (Array.isArray(waterSurfaceMaterial)) {
                    waterSurfaceMaterial.forEach(mat => {
                        mat.color.setHex(wColor);
                        mat.opacity = wOpacity;
                    });
                } else {
                    waterSurfaceMaterial.color.setHex(wColor);
                    waterSurfaceMaterial.opacity = wOpacity;
                }
            }

            // –ü–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ–º —á–∞–Ω–∫–∏, —Ç–∞–∫ –∫–∞–∫ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –ª–∏—Å—Ç–≤—ã –≤–ª–∏—è–µ—Ç –Ω–∞ culling
            if (chunks) {
                chunks.forEach(chunkGroup => {
                    optimizeChunkRendering(chunkGroup);
                });
            }

            if (renderer) {
                switch (activeGraphicsPreset.toneMapping) {
                    case 'aces':
                        renderer.toneMapping = THREE.ACESFilmicToneMapping;
                        break;
                    case 'reinhard':
                        renderer.toneMapping = THREE.ReinhardToneMapping;
                        break;
                    default:
                        renderer.toneMapping = THREE.NoToneMapping;
                        break;
                }
                renderer.toneMappingExposure = activeGraphicsPreset.exposure;
                renderer.physicallyCorrectLights = !!activeGraphicsPreset.physicallyCorrectLights;
                renderer.shadowMap.enabled = !!activeGraphicsPreset.shadows;
                if (renderer.shadowMap.enabled) {
                    // –î–ª—è –≤—ã—Å–æ–∫–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ —á–µ—Ç–∫–∏–µ —Ç–µ–Ω–∏ (PCF), –¥–ª—è –Ω–∏–∑–∫–∏—Ö - –º—è–≥–∫–∏–µ (PCFSoft)
                    if (graphicsQuality === 'ultra' || graphicsQuality === 'high') {
                        renderer.shadowMap.type = THREE.PCFShadowMap; // –ß–µ—Ç–∫–∏–µ –∫—Ä–∞—è
                    } else {
                        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // –ú—è–≥–∫–∏–µ –∫—Ä–∞—è
                    }
                }
                if (renderer.setPixelRatio) {
                    const ratioLimit = activeGraphicsPreset.pixelRatio || 1;
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, ratioLimit));
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }

            if (scene?.fog) {
                // –ù–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º –¥–∏—Å—Ç–∞–Ω—Ü–∏—é —Ç—É–º–∞–Ω–∞ –ø—Ä–µ—Å–µ—Ç–æ–º, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç Render Distance
                // scene.fog.near = activeGraphicsPreset.fogNear;
                // scene.fog.far = activeGraphicsPreset.fogFar;
                
                if (activeSkyColors?.day) {
                    scene.fog.color.copy(activeSkyColors.day);
                }
            }

            if (scene && activeSkyColors?.day) {
                if (!scene.background) {
                    scene.background = new THREE.Color(activeSkyColors.day.getHex());
                } else {
                    scene.background.copy(activeSkyColors.day);
                }
            }

            if (ambientLight) {
                ambientLight.intensity = activeGraphicsPreset.ambientIntensity;
            }

            if (hemisphereLight) {
                hemisphereLight.color.setHex(activeGraphicsPreset.hemisphereSkyColor);
                hemisphereLight.groundColor.setHex(activeGraphicsPreset.hemisphereGroundColor);
                hemisphereLight.intensity = activeGraphicsPreset.hemisphereIntensity;
            }

            if (sunLight) {
                sunLight.intensity = activeGraphicsPreset.sunIntensity;
                sunLight.castShadow = !!activeGraphicsPreset.shadows;
                // sunLight.position.normalize().multiplyScalar(200); // –£–±—Ä–∞–Ω–æ, —Ç–∞–∫ –∫–∞–∫ –ø–æ–∑–∏—Ü–∏—è –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –≤ updateDayNightCycle
                if (sunLight.shadow) {
                    // –£–ª—å—Ç—Ä–∞-—á–µ—Ç–∫–∏–µ —Ç–µ–Ω–∏: 8192 —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –¥–ª—è Ultra
                    const shadowSize = graphicsQuality === 'ultra' ? 8192 : (graphicsQuality === 'high' ? 2048 : 1024);
                    sunLight.shadow.mapSize.set(shadowSize, shadowSize);
                    sunLight.shadow.bias = -0.00005; // –ú–µ–Ω—å—à–∏–π bias –¥–ª—è –±–æ–ª—å—à–µ–π —Ç–æ—á–Ω–æ—Å—Ç–∏
                    const shadowCam = sunLight.shadow.camera;
                    if (shadowCam) {
                        // –ù–µ–º–Ω–æ–≥–æ —Å—É–∂–∞–µ–º –æ–±–ª–∞—Å—Ç—å —Ç–µ–Ω–µ–π –¥–ª—è Ultra, —á—Ç–æ–±—ã –ø–æ–≤—ã—Å–∏—Ç—å –ø–ª–æ—Ç–Ω–æ—Å—Ç—å –ø–∏–∫—Å–µ–ª–µ–π
                        const range = graphicsQuality === 'ultra' ? 60 : 80;
                        shadowCam.left = -range;
                        shadowCam.right = range;
                        shadowCam.top = range;
                        shadowCam.bottom = -range;
                        shadowCam.near = 10;
                        shadowCam.far = 260;
                    }
                }
            }

            if (moonLight) {
                moonLight.intensity = activeGraphicsPreset.moonIntensity ?? 0.35;
                moonLight.castShadow = false;
            }

            if (clouds && clouds.length) {
                clouds.forEach((cloud) => {
                    cloud.visible = activeGraphicsPreset.fancyClouds;
                    if (cloud.material) {
                        cloud.material.opacity = activeGraphicsPreset.cloudOpacity;
                        cloud.material.needsUpdate = true;
                    }
                });
            }

            if (waterSurfaceMaterial) {
                if (activeGraphicsPreset.waterColor) {
                    waterSurfaceMaterial.color.setHex(activeGraphicsPreset.waterColor);
                }
                if (activeGraphicsPreset.waterOpacity) {
                    waterSurfaceMaterial.opacity = activeGraphicsPreset.waterOpacity;
                }
                waterSurfaceMaterial.needsUpdate = true;
            }

            const enableShadows = !!(renderer?.shadowMap?.enabled && (activeGraphicsPreset?.shadows ?? false));
            updateWorldShadowState(enableShadows);

            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Bloom
            if (bloomPass) {
                if (activeGraphicsPreset.bloom && activeGraphicsPreset.bloom.enabled) {
                    bloomPass.strength = activeGraphicsPreset.bloom.strength;
                    bloomPass.radius = activeGraphicsPreset.bloom.radius;
                    bloomPass.threshold = activeGraphicsPreset.bloom.threshold;
                    console.log('‚úì Bloom –≤–∫–ª—é—á–µ–Ω:', activeGraphicsPreset.bloom);
                } else {
                    bloomPass.strength = 0; // –í—ã–∫–ª—é—á–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç
                }
            }
        }

        // === –ù–ï–ë–û –ò –ê–¢–ú–û–°–§–ï–†–ê ===
        let skyGeo, skyMat, skyMesh;
        let skyUniforms;
        const ZENITH_COLORS = {
            dawn: new THREE.Color(0x3a506b),
            day: new THREE.Color(0x1e90ff),
            noon: new THREE.Color(0x0077be),
            dusk: new THREE.Color(0x2c3e50),
            night: new THREE.Color(0x000005)
        };
        const tempZenithColor = new THREE.Color();

        function createSky() {
            if (skyMesh) {
                scene.remove(skyMesh);
                if (skyGeo) skyGeo.dispose();
                if (skyMat) skyMat.dispose();
            }

            const vertexShader = `
                varying vec3 vWorldPosition;
                void main() {
                    vWorldPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `;

            const fragmentShader = `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize( vWorldPosition ).y;
                    gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
                }
            `;

            skyUniforms = {
                topColor: { value: new THREE.Color( 0x0077ff ) },
                bottomColor: { value: new THREE.Color( 0xffffff ) },
                exponent: { value: 0.6 }
            };

            skyGeo = new THREE.SphereGeometry( 480, 32, 15 );
            skyMat = new THREE.ShaderMaterial( {
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: skyUniforms,
                side: THREE.BackSide,
                fog: false,
                depthWrite: false
            } );

            skyMesh = new THREE.Mesh( skyGeo, skyMat );
            skyMesh.renderOrder = -1;
            scene.add( skyMesh );
            console.log('‚úì –ù–µ–±–æ (Sky Sphere) —Å–æ–∑–¥–∞–Ω–æ');
        }

        // === –†–£–ö–ê –ò–ì–†–û–ö–ê ===
        const playerHand = {
            group: null,
            armMesh: null,
            itemMesh: null,
            // –ü–æ–¥–Ω–∏–º–∞–µ–º —Ä—É–∫—É –≤—ã—à–µ –∏ –±–ª–∏–∂–µ –∫ —Ü–µ–Ω—Ç—Ä—É, —á—Ç–æ–±—ã –æ–Ω–∞ –±—ã–ª–∞ –≤–∏–¥–Ω–∞
            basePosition: new THREE.Vector3(0.5, -0.4, -0.6), 
            bobbingTime: 0,
            swayAmount: 0.05,
            bobbingSpeed: 10,
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –∞—Ç–∞–∫–∏
            isSwinging: false,
            swingProgress: 0,
            swingSpeed: 15,
            
            init: function() {
                this.group = new THREE.Group();
                camera.add(this.group);
                
                // –†—É–∫–∞ - –ë–æ–ª–µ–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∞—è, –∫–∞–∫ –≤ Minecraft
                const armGeo = new THREE.BoxGeometry(0.25, 0.75, 0.25);
                armGeo.translate(0, -0.375, 0); // Pivot —Å–≤–µ—Ä—Ö—É
                
                const armMat = new THREE.MeshLambertMaterial({ 
                    color: 0xeebb99,
                    depthTest: false, // –†–∏—Å—É–µ–º –ø–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ
                    transparent: true // –í–∞–∂–Ω–æ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –ø–æ–≤–µ—Ä—Ö –ø—Ä–æ–∑—Ä–∞—á–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
                }); 
                this.armMesh = new THREE.Mesh(armGeo, armMat);
                this.armMesh.renderOrder = 999; // –ü–æ—Ä—è–¥–æ–∫ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
                
                // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º —Ä—É–∫—É, —á—Ç–æ–±—ã –æ–Ω–∞ –≤—ã—Ö–æ–¥–∏–ª–∞ –∏–∑ —É–≥–ª–∞
                this.armMesh.position.set(0.2, -0.2, 0.2);
                this.armMesh.rotation.x = Math.PI / 8;
                this.armMesh.rotation.z = -Math.PI / 8;
                this.armMesh.rotation.y = Math.PI / 12;
                
                this.group.add(this.armMesh);
                
                this.updateItem();
            },
            
            swing: function() {
                if (this.isSwinging) return;
                this.isSwinging = true;
                this.swingProgress = 0;
            },
            
            updateItem: function() {
                if (!this.group) return;
                
                if (this.itemMesh) {
                    this.group.remove(this.itemMesh);
                    // –û—á–∏—Å—Ç–∫–∞ –ø–∞–º—è—Ç–∏ –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞ –¥–ª—è –ø—Ä–æ—Å—Ç—ã—Ö –º–µ—à–µ–π, –Ω–æ —Ö–æ—Ä–æ—à–∞—è –ø—Ä–∞–∫—Ç–∏–∫–∞
                    this.itemMesh = null;
                }
                
                const stack = getSelectedHotbarStack();
                if (!stack) return;
                
                const def = getItemDefinition(stack.id);
                if (!def) return;
                
                // –°–æ–∑–¥–∞–µ–º –º–µ—à –ø—Ä–µ–¥–º–µ—Ç–∞
                if (def.category === 'blocks') {
                    const geo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
                    let mat;
                    
                    // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è —Ç—Ä–∞–≤—ã –∏ –±—Ä–µ–≤–µ–Ω, —É –∫–æ—Ç–æ—Ä—ã—Ö —Ä–∞–∑–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã —Å–æ —Å—Ç–æ—Ä–æ–Ω
                    if (def.id === 'grass') {
                         const top = new THREE.MeshLambertMaterial({ map: textures.grass_top, depthTest: false, transparent: true });
                         const side = new THREE.MeshLambertMaterial({ map: textures.grass_side, depthTest: false, transparent: true });
                         const bottom = new THREE.MeshLambertMaterial({ map: textures.dirt, depthTest: false, transparent: true });
                         mat = [side, side, top, bottom, side, side];
                    } else if (def.id === 'wood') {
                         const top = new THREE.MeshLambertMaterial({ map: textures.wood_top, depthTest: false, transparent: true });
                         const side = new THREE.MeshLambertMaterial({ map: textures.wood_side, depthTest: false, transparent: true });
                         mat = [side, side, top, top, side, side];
                    } else if (def.textureKey && textures[def.textureKey]) {
                        mat = new THREE.MeshLambertMaterial({ map: textures[def.textureKey], depthTest: false, transparent: true });
                    } else {
                        mat = new THREE.MeshLambertMaterial({ color: 0x888888, depthTest: false, transparent: true });
                    }

                    this.itemMesh = new THREE.Mesh(geo, mat);
                    this.itemMesh.renderOrder = 999;
                    // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –±–ª–æ–∫ –≤ —Ä—É–∫–µ
                    this.itemMesh.position.set(0, -0.2, -0.3);
                    this.itemMesh.rotation.y = Math.PI / 4;
                } else {
                    // –ü—Ä–µ–¥–º–µ—Ç—ã
                    const color = def.iconColor || '#ffffff';
                    const geo = new THREE.BoxGeometry(0.05, 0.05, 0.4);
                    const mat = new THREE.MeshLambertMaterial({ color: color, depthTest: false, transparent: true });
                    this.itemMesh = new THREE.Mesh(geo, mat);
                    this.itemMesh.renderOrder = 999;
                    this.itemMesh.position.set(0.1, -0.2, -0.3);
                    this.itemMesh.rotation.x = Math.PI / 4;
                    this.itemMesh.rotation.y = -Math.PI / 6;
                }
                
                if (this.itemMesh) {
                    this.group.add(this.itemMesh);
                }
            },
            
            update: function(delta, isMoving) {
                if (!this.group) return;
                
                // –ï—Å–ª–∏ –∑–∞–∂–∞—Ç–∞ –õ–ö–ú, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –º–∞—Ö–∞—Ç—å –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –ª–æ–º–∞–µ–º –±–ª–æ–∫
                if (leftMouseHeld && !this.isSwinging && typeof isBreaking !== 'undefined' && isBreaking) {
                    this.swing();
                }

                // –ë–∞–∑–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è
                this.group.position.copy(this.basePosition);
                this.group.rotation.set(0, 0, 0);
                
                // –ê–Ω–∏–º–∞—Ü–∏—è —É–¥–∞—Ä–∞
                if (this.isSwinging) {
                    this.swingProgress += delta * this.swingSpeed;
                    if (this.swingProgress >= Math.PI) {
                        this.isSwinging = false;
                        this.swingProgress = 0;
                    } else {
                        // –°–∏–Ω—É—Å–æ–∏–¥–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –¥–ª—è —É–¥–∞—Ä–∞
                        const swingPower = Math.sin(this.swingProgress);
                        this.group.rotation.x -= swingPower * 1.2; // –°–∏–ª—å–Ω–µ–µ –Ω–∞–∫–ª–æ–Ω –≤–ø–µ—Ä–µ–¥
                        this.group.rotation.y -= swingPower * 0.6; // –ü–æ–≤–æ—Ä–æ—Ç –≤–Ω—É—Ç—Ä—å
                        this.group.position.z -= swingPower * 0.4; // –í—ã–¥–≤–∏–∂–µ–Ω–∏–µ –≤–ø–µ—Ä–µ–¥
                        this.group.position.y += swingPower * 0.2; // –ß—É—Ç—å –≤–≤–µ—Ä—Ö
                    }
                }
                
                // –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è –ø—Ä–∏ —Ö–æ–¥—å–±–µ
                if (isMoving) {
                    this.bobbingTime += delta * this.bobbingSpeed;
                    const bobX = Math.cos(this.bobbingTime) * this.swayAmount;
                    const bobY = Math.abs(Math.sin(this.bobbingTime)) * this.swayAmount;
                    
                    this.group.position.x += bobX;
                    this.group.position.y -= bobY;
                    this.group.rotation.z += bobX * 0.5;
                    this.group.rotation.x += bobY * 0.5;
                } else {
                    // –ü–ª–∞–≤–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç –≤ –∏—Å—Ö–æ–¥–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ
                    this.bobbingTime = 0;
                }
            }
        };

        function initPostProcessing() {
            if (!renderer || !scene || !camera) return;

            // –°–æ–∑–¥–∞–µ–º –∫–æ–º–ø–æ–∑–µ—Ä
            composer = new THREE.EffectComposer(renderer);
            
            // 1. Render Pass (–æ–±—ã—á–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä —Å—Ü–µ–Ω—ã)
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // 2. SSAO Pass (Ambient Occlusion)
            const width = window.innerWidth;
            const height = window.innerHeight;
            ssaoPass = new THREE.SSAOPass(scene, camera, width, height);
            ssaoPass.kernelRadius = 16;
            ssaoPass.minDistance = 0.005;
            ssaoPass.maxDistance = 0.1;
            ssaoPass.enabled = false; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–∫–ª—é—á–µ–Ω, –≤–∫–ª—é—á–∏–º —á–µ—Ä–µ–∑ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
            composer.addPass(ssaoPass);
            
            // 3. Bloom Pass (—Å–≤–µ—á–µ–Ω–∏–µ)
            // Resolution, strength, radius, threshold
            const bloomResolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
            bloomPass = new THREE.UnrealBloomPass(bloomResolution, 1.5, 0.4, 0.85);
            bloomPass.strength = 0; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–∫–ª—é—á–µ–Ω
            bloomPass.radius = 0;
            bloomPass.threshold = 0;
            composer.addPass(bloomPass);
            
            console.log('‚úì Post-processing –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
        }

        function init() {
            console.log('=== –ù–ê–ß–ê–õ–û –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–ò ===');
            
            // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ë–ò–ë–õ–ò–û–¢–ï–ö ===
            
            // 1. Alea (RNG)
            if (typeof alea !== 'undefined') {
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π RNG –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                console.log('‚úì Alea RNG –¥–æ—Å—Ç—É–ø–µ–Ω');
            }

            // 2. Cannon.js (–§–∏–∑–∏–∫–∞)
            if (typeof CANNON !== 'undefined') {
                physicsWorld = new CANNON.World();
                physicsWorld.gravity.set(0, -20, 0);
                
                // –ú–∞—Ç–µ—Ä–∏–∞–ª—ã
                const physicsMaterial = new CANNON.Material('physicsMaterial');
                const physicsContactMaterial = new CANNON.ContactMaterial(
                    physicsMaterial, physicsMaterial,
                    { friction: 0.0, restitution: 0.0 }
                );
                physicsWorld.addContactMaterial(physicsContactMaterial);
                
                // –¢–µ–ª–æ –∏–≥—Ä–æ–∫–∞
                const playerShape = new CANNON.Box(new CANNON.Vec3(PLAYER_WIDTH/2, PLAYER_HEIGHT/2, PLAYER_WIDTH/2));
                const playerBody = new CANNON.Body({
                    mass: 70,
                    material: physicsMaterial
                });
                playerBody.addShape(playerShape, new CANNON.Vec3(0, PLAYER_HEIGHT/2, 0));
                playerBody.position.set(player.position.x, player.position.y, player.position.z);
                playerBody.fixedRotation = true;
                playerBody.linearDamping = 0.9;
                
                physicsWorld.addBody(playerBody);
                player.physicsBody = playerBody;
                
                console.log('‚úì Cannon.js —Ñ–∏–∑–∏–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞');
            }

            // 3. PeerJS (–ú—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä)
            if (typeof Peer !== 'undefined') {
                peer = new Peer();
                peer.on('open', (id) => {
                    console.log('‚úì PeerJS ID:', id);
                });
                console.log('‚úì PeerJS –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
            }

            canvas = document.getElementById('gameCanvas');
            
            // –°—Ü–µ–Ω–∞
            const preset = GRAPHICS_PRESETS[graphicsQuality] || GRAPHICS_PRESETS.medium;
            activeGraphicsPreset = preset;
            passiveAnimals.forEach((animal) => {
                if (animal && animal.parent) {
                    animal.parent.remove(animal);
                }
            });
            passiveAnimals.length = 0;
            scene = new THREE.Scene();
            const initialSkyColor = new THREE.Color(preset.sky.day);
            scene.background = initialSkyColor.clone();
            scene.fog = new THREE.Fog(initialSkyColor.getHex(), preset.fogNear, preset.fogFar);
            console.log('‚úì –°—Ü–µ–Ω–∞ —Å–æ–∑–¥–∞–Ω–∞');
            
            // –°–æ–∑–¥–∞—ë–º –Ω–µ–±–æ
            createSky();

            // –ö–∞–º–µ—Ä–∞
            camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.copy(player.position);
            camera.rotation.copy(player.rotation);
            scene.add(camera); // –í–ê–ñ–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –∫–∞–º–µ—Ä—É –≤ —Å—Ü–µ–Ω—É, —á—Ç–æ–±—ã —Ä–µ–Ω–¥–µ—Ä–∏–ª–∏—Å—å –µ—ë –¥–µ—Ç–∏ (—Ä—É–∫–∞)
            console.log('‚úì –ö–∞–º–µ—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞ –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏:', camera.position);
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä—É–∫–∏ –∏–≥—Ä–æ–∫–∞
            playerHand.init();

            // –†–µ–Ω–¥–µ—Ä–µ—Ä
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: false, // –û—Ç–∫–ª—é—á–∞–µ–º –∞–Ω—Ç–∏–∞–ª–∏–∞—Å–∏–Ω–≥ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
                powerPreference: 'high-performance',
                stencil: false, // –û—Ç–∫–ª—é—á–∞–µ–º stencil buffer
                depth: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º pixelRatio –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–∞—á–µ—Å—Ç–≤–∞ —Ç–µ–∫—Å—Ç—É—Ä
            const pixelRatioLimit = textureQuality === 'low' ? 1 : (textureQuality === 'high' ? 1.5 : 1.25);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, pixelRatioLimit));
            renderer.outputEncoding = THREE.sRGBEncoding;
            console.log('‚úì –†–µ–Ω–¥–µ—Ä–µ—Ä —Å–æ–∑–¥–∞–Ω');

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ—Å—Ç-–ø—Ä–æ—Ü–µ—Å—Å–∏–Ω–≥–∞
            initPostProcessing();

            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            ambientLight = new THREE.AmbientLight(0xffffff, preset.ambientIntensity);
            scene.add(ambientLight);
            hemisphereLight = new THREE.HemisphereLight(preset.hemisphereSkyColor, preset.hemisphereGroundColor, preset.hemisphereIntensity);
            scene.add(hemisphereLight);
            console.log('‚úì Ambient —Å–≤–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω');

            sunLight = new THREE.DirectionalLight(0xffffee, preset.sunIntensity);
            sunLight.position.set(50, 100, 50);
            scene.add(sunLight);
            console.log('‚úì –°–æ–ª–Ω—Ü–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ');
            
            moonLight = new THREE.DirectionalLight(0x9999ff, preset.moonIntensity ?? 0.35);
            moonLight.position.set(-50, -100, -50);
            moonLight.visible = false;
            scene.add(moonLight);
            console.log('‚úì –õ—É–Ω–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞');

            // –í–∏–∑—É–∞–ª—å–Ω–æ–µ –°–æ–ª–Ω—Ü–µ (2D –∫–≤–∞–¥—Ä–∞—Ç)
            const sunGeo = new THREE.PlaneGeometry(30, 30);
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—á–µ–Ω—å —è—Ä–∫–∏–π —Ü–≤–µ—Ç –¥–ª—è Bloom —ç—Ñ—Ñ–µ–∫—Ç–∞
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffffaa, fog: false });
            sunMesh = new THREE.Mesh(sunGeo, sunMat);
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —è—Ä–∫–æ—Å—Ç—å —Ü–≤–µ—Ç–∞ –Ω–∞–ø—Ä—è–º—É—é –¥–ª—è —É—Å–∏–ª–µ–Ω–∏—è Bloom
            sunMesh.material.color.multiplyScalar(2.0); 
            scene.add(sunMesh);

            // –í–∏–∑—É–∞–ª—å–Ω–∞—è –õ—É–Ω–∞ (2D –∫–≤–∞–¥—Ä–∞—Ç)
            const moonGeo = new THREE.PlaneGeometry(50, 50);
            const moonMat = new THREE.MeshBasicMaterial({ color: 0xffffff, fog: false });
            moonMesh = new THREE.Mesh(moonGeo, moonMat);
            scene.add(moonMesh);
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç—É—Ä—ã
            initTextures();
            
            // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—ã –≤ —Å–ª–æ—Ç–∞—Ö
            renderHotbarTextures();
            
            // –°–æ–∑–¥–∞—ë–º –æ–±–≤–æ–¥–∫—É –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –±–ª–æ–∫–∞ (—Ç–æ–ª—å–∫–æ —Ä—ë–±—Ä–∞)
            const outlineEdges = new THREE.EdgesGeometry(new THREE.BoxGeometry(1.002, 1.002, 1.002));
            const outlineMat = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.85
            });
            highlightBox = new THREE.LineSegments(outlineEdges, outlineMat);
            highlightBox.renderOrder = 10;
            highlightBox.visible = false;
            scene.add(highlightBox);
            console.log('‚úì –û–±–≤–æ–¥–∫–∞ –±–ª–æ–∫–∞ —Å–æ–∑–¥–∞–Ω–∞');

            dropGeometry = new THREE.BoxGeometry(DROP_SIZE, DROP_SIZE, DROP_SIZE);

            // –°–æ–∑–¥–∞—ë–º overlay –¥–ª—è —Ç—Ä–µ—â–∏–Ω
            const crackGeo = new THREE.BoxGeometry(1.001, 1.001, 1.001);
            const crackMat = new THREE.MeshBasicMaterial({
                map: textures.destroy_0,
                transparent: true,
                depthWrite: false,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1
            });
            window.crackOverlay = new THREE.Mesh(crackGeo, crackMat);
            window.crackOverlay.visible = false;
            scene.add(window.crackOverlay);
            console.log('‚úì Overlay —Ç—Ä–µ—â–∏–Ω —Å–æ–∑–¥–∞–Ω');

            // –ó–∞–≥—Ä—É–∂–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –º–∏—Ä–∞ (—Å–∏–¥, –ø–æ–∑–∏—Ü–∏—è)
            loadWorldMetadata();

            // –°–æ–∑–¥–∞—ë–º –º–∏—Ä
            createFlatWorld();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–º–µ—Ä—É –ø–æ—Å–ª–µ —Å–ø–∞–≤–Ω–∞
            camera.position.copy(player.position);
            camera.rotation.copy(player.rotation);
            console.log('‚úì –ö–∞–º–µ—Ä–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –Ω–∞ –ø–æ–∑–∏—Ü–∏—é:', camera.position);
            
            // –°–æ–∑–¥–∞—ë–º –æ–±–ª–∞–∫–∞
            createClouds();

            applyGraphicsPreset();
            refreshWorldMaterials();

            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            setupControls();

            window.addEventListener('resize', () => {
                const width = window.innerWidth;
                const height = window.innerHeight;

                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
                
                if (composer) {
                    composer.setSize(width, height);
                }
                if (ssaoPass) {
                    ssaoPass.setSize(width, height);
                }
                if (bloomPass) {
                    bloomPass.resolution.set(width, height);
                }
            });

            console.log('=== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ó–ê–í–ï–†–®–ï–ù–ê ===');
            console.log('–û–±—ä–µ–∫—Ç–æ–≤ –Ω–∞ —Å—Ü–µ–Ω–µ:', scene.children.length);
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –±–ª–æ–∫–æ–≤
            setTimeout(() => {
                applySavedChanges();
                console.log('‚úì –°–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π –º–∏—Ä –ø—Ä–∏–º–µ–Ω—ë–Ω');
            }, 100);
        }

        function createFlatWorld() {
            console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —á–∞–Ω–∫-—Å–∏—Å—Ç–µ–º—ã...');
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ —á–∞–Ω–∫–∏ –≤–æ–∫—Ä—É–≥ –∏–≥—Ä–æ–∫–∞
            const playerChunkX = Math.floor(player.position.x / CHUNK_SIZE);
            const playerChunkZ = Math.floor(player.position.z / CHUNK_SIZE);
            
            // –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∂–∞–µ–º —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π —á–∞–Ω–∫ –°–ò–ù–•–†–û–ù–ù–û, —á—Ç–æ–±—ã –∏–≥—Ä–æ–∫—É –±—ã–ª–æ –∫—É–¥–∞ –≤—Å—Ç–∞—Ç—å
            loadChunk(playerChunkX, playerChunkZ, true);

            for (let cx = -renderDistance; cx <= renderDistance; cx++) {
                for (let cz = -renderDistance; cz <= renderDistance; cz++) {
                    if (cx === 0 && cz === 0) continue;
                    loadChunk(playerChunkX + cx, playerChunkZ + cz);
                }
            }
            
            lastPlayerChunk = { x: playerChunkX, z: playerChunkZ };
            console.log('‚úì –ù–∞—á–∞–ª—å–Ω—ã–µ —á–∞–Ω–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã!');
            
            // –ü–æ–¥–±–∏—Ä–∞–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—É—é –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å –¥–ª—è —Å–ø–∞–≤–Ω–∞ –∏–≥—Ä–æ–∫–∞
            const spawnX = player.position.x;
            const spawnZ = player.position.z;
            let groundY = null;

            for (let y = CHUNK_HEIGHT - 2; y >= 0; y--) {
                const block = getBlock(spawnX, y, spawnZ);
                if (!block || !block.userData?.solid) {
                    continue;
                }
                const type = block.userData.type;
                if (!SPAWNABLE_BLOCK_TYPES.has(type)) {
                    continue;
                }
                const above1 = getBlock(spawnX, y + 1, spawnZ);
                const above2 = getBlock(spawnX, y + 2, spawnZ);
                if ((above1 && above1.userData?.solid) || (above2 && above2.userData?.solid)) {
                    continue;
                }
                groundY = y;
                break;
            }

            if (groundY === null) {
                for (let y = CHUNK_HEIGHT - 2; y >= 0; y--) {
                    const block = getBlock(spawnX, y, spawnZ);
                    if (!block || !block.userData?.solid) {
                        continue;
                    }
                    const above1 = getBlock(spawnX, y + 1, spawnZ);
                    const above2 = getBlock(spawnX, y + 2, spawnZ);
                    if ((above1 && above1.userData?.solid) || (above2 && above2.userData?.solid)) {
                        continue;
                    }
                    groundY = y;
                    break;
                }
            }

            if (groundY === null) {
                groundY = 10;
            }

            // –°—Ç–∞–≤–∏–º –∏–≥—Ä–æ–∫–∞ –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å (—Å —É—á—ë—Ç–æ–º –Ω–æ–≤–æ–π –≤—ã—Å–æ—Ç—ã)
            player.position.y = groundY + 0.5 + PLAYER_HEIGHT;
            player.velocity.y = 0;
            player.onGround = true;
            
            console.log(`‚úì –ò–≥—Ä–æ–∫ —Å–ø–∞–≤–Ω–∏–ª—Å—è –Ω–∞ –≤—ã—Å–æ—Ç–µ Y=${player.position.y}`);
        }
        
        function getChunkKey(chunkX, chunkZ) {
            return `${chunkX},${chunkZ}`;
        }
        
        function getLODLevel(distance, currentLOD = null) {
            // –ü—Ä–∏ —É–ª—å—Ç—Ä–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö - –≤—Å–µ–≥–¥–∞ –ø–æ–ª–Ω—ã–π LOD
            if (graphicsQuality === 'ultra' && distance < LOD_LEVELS.FULL.distanceMax * 2) {
                return 'FULL';
            }
            
            // –ì–∏—Å—Ç–µ—Ä–µ–∑–∏—Å
            if (currentLOD === 'FULL') {
                if (distance > LOD_LEVELS.FULL.distanceMaxHysteresis) {
                    if (distance < LOD_LEVELS.MEDIUM.distanceMaxHysteresis) return 'MEDIUM';
                    if (distance < LOD_LEVELS.LOW.distanceMaxHysteresis) return 'LOW';
                    return 'HIDDEN';
                }
                return 'FULL';
            }
            
            if (currentLOD === 'MEDIUM') {
                if (distance < LOD_LEVELS.FULL.distanceMax) return 'FULL';
                if (distance > LOD_LEVELS.MEDIUM.distanceMaxHysteresis) {
                    if (distance < LOD_LEVELS.LOW.distanceMaxHysteresis) return 'LOW';
                    return 'HIDDEN';
                }
                return 'MEDIUM';
            }
            
            if (currentLOD === 'LOW') {
                if (distance < LOD_LEVELS.FULL.distanceMax) return 'FULL';
                if (distance < LOD_LEVELS.MEDIUM.distanceMax) return 'MEDIUM';
                if (distance > LOD_LEVELS.LOW.distanceMaxHysteresis) return 'HIDDEN';
                return 'LOW';
            }
            
            if (currentLOD === 'HIDDEN') {
                if (distance < LOD_LEVELS.FULL.distanceMax) return 'FULL';
                if (distance < LOD_LEVELS.MEDIUM.distanceMax) return 'MEDIUM';
                if (distance < LOD_LEVELS.LOW.distanceMax) return 'LOW';
                return 'HIDDEN';
            }
            
            // –ü–µ—Ä–≤–∏—á–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
            if (distance < LOD_LEVELS.FULL.distanceMax) return 'FULL';
            if (distance < LOD_LEVELS.MEDIUM.distanceMax) return 'MEDIUM';
            if (distance < LOD_LEVELS.LOW.distanceMax) return 'LOW';
            return 'HIDDEN';
        }
        
        function updateChunkLOD(chunk, playerPos) {
            const chunkKey = chunk.name;
            
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ü–µ–Ω—Ç—Ä —á–∞–Ω–∫–∞ (–∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è)
            if (!chunk.userData.centerPos) {
                chunk.userData.centerPos = new THREE.Vector3();
                chunk.getWorldPosition(chunk.userData.centerPos);
            }
            const distance = playerPos.distanceTo(chunk.userData.centerPos);
            
            // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π LOD –∏–∑ –∫—ç—à–∞
            const currentLOD = chunkLODCache.get(chunkKey) || null;
            const newLOD = getLODLevel(distance, currentLOD);
            
            // –ï—Å–ª–∏ LOD –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
            if (currentLOD === newLOD) return;
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–π LOD –≤ –∫—ç—à
            chunkLODCache.set(chunkKey, newLOD);
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤–∏–¥–∏–º–æ—Å—Ç—å
            if (newLOD === 'HIDDEN') {
                chunk.visible = false;
                return;
            } else {
                chunk.visible = true;
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª—ã —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–∑–º–µ–Ω–∏–ª—Å—è —É—Ä–æ–≤–µ–Ω—å –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏
            chunk.children.forEach(block => {
                if (!block.userData || !block.userData.type) return;
                
                const blockType = block.userData.type;
                
                if (newLOD === 'LOW') {
                    // –ù–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ - –ø—Ä–æ—Å—Ç—ã–µ —Ü–≤–µ—Ç–∞
                    const color = BLOCK_TYPES[blockType]?.color || 0x808080;
                    if (!block.userData.lowLodMaterial) {
                        block.userData.lowLodMaterial = new THREE.MeshBasicMaterial({ 
                            color,
                            fog: true
                        });
                    }
                    block.material = block.userData.lowLodMaterial;
                } else {
                    // –í—ã—Å–æ–∫–æ–µ/—Å—Ä–µ–¥–Ω–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ - —Ç–µ–∫—Å—Ç—É—Ä—ã
                    if (sharedMaterials[blockType]) {
                        block.material = sharedMaterials[blockType];
                    }
                }
            });
        }
        
        function updateAllChunksLOD() {
            const playerPos = player.position.clone();
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            debugStats.chunksRendered = 0;
            debugStats.chunksTotal = chunks.size;
            debugStats.blocksRendered = 0;
            
            // Frustum culling
            const frustum = new THREE.Frustum();
            const projScreenMatrix = new THREE.Matrix4();
            projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromProjectionMatrix(projScreenMatrix);

            const cullingRadius = (renderDistance + 2) * CHUNK_SIZE;
            const queryRange = {
                minX: playerPos.x - cullingRadius,
                maxX: playerPos.x + cullingRadius,
                minZ: playerPos.z - cullingRadius,
                maxZ: playerPos.z + cullingRadius
            };

            const candidates = chunkQuadTree.query(queryRange);
            const fallback = candidates.length === 0;
            const chunkIterator = fallback ? Array.from(chunks.values()).map(chunk => ({ data: chunk })) : candidates;

            // –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏—è (Occlusion Culling)
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–µ—Ä–µ–∫—Ä—ã—Ç –ª–∏ —á–∞–Ω–∫ –¥—Ä—É–≥–∏–º–∏ —á–∞–Ω–∫–∞–º–∏ (—Ö–æ–ª–º–∞–º–∏)
            const isOccluded = (targetChunk, dist) => {
                if (dist < CHUNK_SIZE * 3) return false; // –ë–ª–∏–∑–∫–∏–µ —á–∞–Ω–∫–∏ –Ω–µ —Å–∫—Ä—ã–≤–∞–µ–º
                
                // –¶–µ–ª–∏–º—Å—è –≤ –≤–µ—Ä—Ö–Ω—é—é —á–∞—Å—Ç—å —á–∞–Ω–∫–∞, —á—Ç–æ–±—ã –Ω–µ —Å–∫—Ä—ã—Ç—å –≤–∏–¥–∏–º—ã–µ –≤–µ—Ä—Ö—É—à–∫–∏ –≥–æ—Ä
                const targetHeight = targetChunk.userData.maxHeight || 32;
                const targetPos = targetChunk.userData.centerPos.clone();
                targetPos.y = targetHeight; 

                const start = playerPos.clone();
                start.y += 1.6; // –£—Ä–æ–≤–µ–Ω—å –≥–ª–∞–∑
                
                const dir = new THREE.Vector3().subVectors(targetPos, start).normalize();
                const stepSize = CHUNK_SIZE;
                const steps = Math.floor(dist / stepSize);
                
                let curr = start.clone();
                
                // –®–∞–≥–∞–µ–º –ø–æ –ª—É—á—É –∫ —Ü–µ–ª–∏
                for(let i = 1; i < steps - 1; i++) {
                    curr.addScaledVector(dir, stepSize);
                    
                    const cx = Math.floor(curr.x / CHUNK_SIZE);
                    const cz = Math.floor(curr.z / CHUNK_SIZE);
                    const key = getChunkKey(cx, cz);
                    const blocker = chunks.get(key);
                    
                    if (blocker && blocker.userData.maxHeight !== undefined) {
                        // –í—ã—Å–æ—Ç–∞ –ª—É—á–∞ –≤ —ç—Ç–æ–π —Ç–æ—á–∫–µ
                        const t = i / steps;
                        const rayY = start.y + (targetPos.y - start.y) * t;
                        
                        // –ï—Å–ª–∏ –ª–∞–Ω–¥—à–∞—Ñ—Ç –≤—ã—à–µ –ª—É—á–∞ —Å –∑–∞–ø–∞—Å–æ–º, —Ç–æ –æ–Ω –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ—Ç –≤–∏–¥
                        if (blocker.userData.maxHeight > rayY + 6) {
                            return true; // –ü–µ—Ä–µ–∫—Ä—ã—Ç!
                        }
                    }
                }
                return false;
            };

            for (const entry of chunkIterator) {
                const chunk = entry.data;
                if (!chunk) {
                    continue;
                }

                if (!chunk.userData.centerPos) {
                    chunk.userData.centerPos = new THREE.Vector3();
                    chunk.getWorldPosition(chunk.userData.centerPos);
                }

                const chunkBox = new THREE.Box3();
                chunkBox.setFromCenterAndSize(
                    chunk.userData.centerPos,
                    new THREE.Vector3(CHUNK_SIZE, CHUNK_HEIGHT, CHUNK_SIZE)
                );

                const distanceToPlayer = chunk.userData.centerPos.distanceTo(playerPos);
                const inView = frustum.intersectsBox(chunkBox);
                // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–¥–∏—É—Å "–±–ª–∏–∂–Ω–µ–π –∑–æ–Ω—ã" –¥–æ 4 —á–∞–Ω–∫–æ–≤, —á—Ç–æ–±—ã –ø—Ä–∏ –ø–æ–≤–æ—Ä–æ—Ç–µ –Ω–µ –±—ã–ª–æ –ø—É—Å—Ç–æ—Ç—ã
                const isNear = distanceToPlayer < CHUNK_SIZE * 4.0;

                if (inView || isNear) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º Occlusion Culling —Ç–æ–ª—å–∫–æ –¥–ª—è –¥–∞–ª–µ–∫–∏—Ö —á–∞–Ω–∫–æ–≤
                    if (!isNear && isOccluded(chunk, distanceToPlayer)) {
                        chunk.visible = false;
                        // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–∫—Ä—ã—Ç—ã—Ö —á–∞–Ω–∫–æ–≤
                    } else {
                        updateChunkLOD(chunk, playerPos);
                        if (chunk.visible) {
                            debugStats.chunksRendered++;
                            debugStats.blocksRendered += chunk.children.length;
                        }
                    }
                } else {
                    chunk.visible = false;
                    chunkLODCache.set(chunk.name, 'HIDDEN');
                }
            }
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å–µ–¥–Ω–∏—Ö –±–ª–æ–∫–æ–≤ –¥–ª—è Face Culling
        function hasNeighborBlock(x, y, z) {
            return isSolidBlock(x, y, z);
        }
        
        function addBlockToChunk(x, y, z, type, chunkGroup, options = {}) {
            const key = `${x},${y},${z}`;
            if (worldBlocks.has(key)) return;
            
            const {
                geometry: customGeometry,
                material: customMaterial,
                segmentIndex = null,
                positionOffset,
                renderOrder: customRenderOrder,
                userData: additionalUserData
            } = options;

            const defaultGeometry = type === 'water' ? waterSurfaceGeometry : sharedGeometry;
            const defaultMaterial = type === 'water' ? waterSurfaceMaterial : sharedMaterials[type];
            const geometry = customGeometry || defaultGeometry;
            const material = customMaterial || defaultMaterial;
            if (!geometry || !material) return;

            const mesh = new THREE.Mesh(geometry, material);
            const offsetX = positionOffset?.x ?? 0;
            const offsetY = positionOffset?.y ?? 0;
            const offsetZ = positionOffset?.z ?? 0;
            // –î–ª—è –≤–æ–¥—ã —Ç–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –ø–æ–∑–∏—Ü–∏—é (—Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ BoxGeometry)
            const baseY = y; 
            mesh.position.set(x + offsetX, baseY + offsetY, z + offsetZ);
            mesh.renderOrder = customRenderOrder ?? (type === 'water' ? 1 : mesh.renderOrder);
            mesh.userData = { 
                x, y, z, 
                type, 
                chunkGroup,
                solid: !NON_SOLID_BLOCKS.has(type),
                segmentIndex,
                ...additionalUserData
            };
            mesh.matrixAutoUpdate = false;
            mesh.updateMatrix();
            const enableShadows = !!(renderer?.shadowMap?.enabled && (activeGraphicsPreset?.shadows ?? false));
            if (type !== 'water') {
                mesh.castShadow = enableShadows;
                mesh.receiveShadow = enableShadows;
            } else {
                mesh.castShadow = false;
                mesh.receiveShadow = false;
            }
            
            chunkGroup.add(mesh);
            worldBlocks.set(key, mesh);
        }
        
        function addBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            if (worldBlocks.has(key)) return;
            
            // –ù–∞—Ö–æ–¥–∏–º —á–∞–Ω–∫ –¥–ª—è —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞
            const chunkX = Math.floor(x / CHUNK_SIZE);
            const chunkZ = Math.floor(z / CHUNK_SIZE);
            const chunkKey = getChunkKey(chunkX, chunkZ);
            let chunkGroup = chunks.get(chunkKey);
            
            if (!chunkGroup) {
                chunkGroup = new THREE.Group();
                chunkGroup.name = chunkKey;
                chunks.set(chunkKey, chunkGroup);
                scene.add(chunkGroup);
            }
            
            addBlockToChunk(x, y, z, type, chunkGroup);

            // –û–±–Ω–æ–≤–ª—è–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é —á–∞–Ω–∫–∞
            optimizeChunkRendering(chunkGroup);

            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å–µ–¥–Ω–∏–µ —á–∞–Ω–∫–∏, –µ—Å–ª–∏ –±–ª–æ–∫ –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ
            const lx = (x % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
            const lz = (z % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;

            const updateNeighborChunk = (dx, dz) => {
                const nKey = getChunkKey(chunkX + dx, chunkZ + dz);
                if (chunks.has(nKey)) {
                    optimizeChunkRendering(chunks.get(nKey));
                }
            };

            if (lx === 0) updateNeighborChunk(-1, 0);
            if (lx === CHUNK_SIZE - 1) updateNeighborChunk(1, 0);
            if (lz === 0) updateNeighborChunk(0, -1);
            if (lz === CHUNK_SIZE - 1) updateNeighborChunk(0, 1);
        }

        function addTallGrassDecoration(x, y, z, chunkGroup) {
            if (!tallGrassMaterial || !tallGrassGeometry) {
                return;
            }
            const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            if (worldDecorations.has(key)) {
                return;
            }
            const cross = new THREE.Group();
            const planeA = new THREE.Mesh(tallGrassGeometry, tallGrassMaterial);
            const planeB = new THREE.Mesh(tallGrassGeometry, tallGrassMaterial);
            planeB.rotation.y = Math.PI * 0.5;
            planeA.userData = { decorationKey: key };
            planeB.userData = { decorationKey: key };
            cross.add(planeA);
            cross.add(planeB);
            // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: —É–±—Ä–∞–Ω–æ —Å–º–µ—â–µ–Ω–∏–µ +0.5 –ø–æ X/Z, —á—Ç–æ–±—ã —Ç—Ä–∞–≤–∞ –±—ã–ª–∞ –ø–æ —Ü–µ–Ω—Ç—Ä—É –±–ª–æ–∫–∞
            // Y –≤–æ–∑–≤—Ä–∞—â–µ–Ω –∫ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é (y - 0.36), —Ç–∞–∫ –∫–∞–∫ y - —ç—Ç–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –±–ª–æ–∫–∞ –í–û–ó–î–£–•–ê –Ω–∞–¥ –∑–µ–º–ª–µ–π
            cross.position.set(x, y - 0.36, z);
            cross.userData = {
                decoration: true,
                decorationKey: key,
                type: 'tall_grass'
            };
            worldDecorations.set(key, cross);
            chunkGroup.add(cross);
        }

        function removeDecorationByKey(key) {
            const deco = worldDecorations.get(key);
            if (!deco) {
                return;
            }
            if (deco.parent) {
                deco.parent.remove(deco);
            }
            worldDecorations.delete(key);
        }

        function removeDecorationAt(x, y, z) {
            const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            removeDecorationByKey(key);
        }
        
        function unloadChunk(chunkX, chunkZ) {
            const key = getChunkKey(chunkX, chunkZ);
            const chunk = chunks.get(key);
            if (!chunk) return;
            
            // –£–¥–∞–ª—è–µ–º –∏–∑ LOD –∫—ç—à–∞
            chunkLODCache.delete(key);

            unregisterChunkSpatial(chunkX, chunkZ);
            
            // –£–¥–∞–ª—è–µ–º –≤—Å–µ –±–ª–æ–∫–∏ —á–∞–Ω–∫–∞ –∏–∑ worldBlocks
            chunk.children.forEach(child => {
                if (child.userData?.decorationKey) {
                    worldDecorations.delete(child.userData.decorationKey);
                } else if (child.userData && child.userData.x !== undefined) {
                    const blockKey = `${child.userData.x},${child.userData.y},${child.userData.z}`;
                    worldBlocks.delete(blockKey);
                }
            });
            
            scene.remove(chunk);
            chunks.delete(key);
        }

        function updateChunkVisibility() {
            if (!frustumCullingEnabled) {
                chunks.forEach(chunk => chunk.visible = true);
                return;
            }

            // –û–±–Ω–æ–≤–ª—è–µ–º —Ñ—Ä—É—Å—Ç—É–º –∫–∞–º–µ—Ä—ã
            camera.updateMatrixWorld();
            projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromProjectionMatrix(projScreenMatrix);

            chunks.forEach((chunk, key) => {
                // –ï—Å–ª–∏ —É —á–∞–Ω–∫–∞ –Ω–µ—Ç BoundingBox, —Å–æ–∑–¥–∞–µ–º –µ–≥–æ
                if (!chunk.userData.boundingBox) {
                    const [cx, cz] = key.split(',').map(Number);
                    const min = new THREE.Vector3(cx * CHUNK_SIZE, 0, cz * CHUNK_SIZE);
                    const max = new THREE.Vector3((cx + 1) * CHUNK_SIZE, CHUNK_HEIGHT, (cz + 1) * CHUNK_SIZE);
                    chunk.userData.boundingBox = new THREE.Box3(min, max);
                }

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ
                if (frustum.intersectsBox(chunk.userData.boundingBox)) {
                    chunk.visible = true;
                } else {
                    chunk.visible = false;
                }
            });
        }
        
        function updateChunks() {
            // –û–±–Ω–æ–≤–ª—è–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–æ—è–≤–ª–µ–Ω–∏—è —á–∞–Ω–∫–æ–≤
            chunks.forEach(chunk => {
                if (chunk.userData.isAnimating) {
                    chunk.position.y += (chunk.userData.targetY - chunk.position.y) * 0.1;
                    if (Math.abs(chunk.userData.targetY - chunk.position.y) < 0.1) {
                        chunk.position.y = chunk.userData.targetY;
                        chunk.userData.isAnimating = false;
                    }
                }
            });

            const playerChunkX = Math.floor(player.position.x / CHUNK_SIZE);
            const playerChunkZ = Math.floor(player.position.z / CHUNK_SIZE);
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ–º–µ—Å—Ç–∏–ª—Å—è –ª–∏ –∏–≥—Ä–æ–∫ –≤ –¥—Ä—É–≥–æ–π —á–∞–Ω–∫
            if (playerChunkX === lastPlayerChunk.x && playerChunkZ === lastPlayerChunk.z) {
                return;
            }
            
            lastPlayerChunk = { x: playerChunkX, z: playerChunkZ };
            
            // –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–æ–≤—ã–µ —á–∞–Ω–∫–∏
            for (let cx = -renderDistance; cx <= renderDistance; cx++) {
                for (let cz = -renderDistance; cz <= renderDistance; cz++) {
                    loadChunk(playerChunkX + cx, playerChunkZ + cz);
                }
            }
            
            // –í—ã–≥—Ä—É–∂–∞–µ–º –¥–∞–ª—ë–∫–∏–µ —á–∞–Ω–∫–∏
            const toUnload = [];
            chunks.forEach((chunk, key) => {
                const [cx, cz] = key.split(',').map(Number);
                const dist = Math.max(Math.abs(cx - playerChunkX), Math.abs(cz - playerChunkZ));
                if (dist > renderDistance + 1) {
                    toUnload.push([cx, cz]);
                }
            });
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—ã–≥—Ä—É–∂–∞–µ–º—ã—Ö —á–∞–Ω–∫–æ–≤ –∑–∞ –∫–∞–¥—Ä
            toUnload.slice(0, 5).forEach(([cx, cz]) => unloadChunk(cx, cz));
        }
        

        function loadChunk(chunkX, chunkZ, forceSync = false) {
            const key = getChunkKey(chunkX, chunkZ);
            if (chunks.has(key) || pendingChunks.has(key)) return; // –ß–∞–Ω–∫ —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω –∏–ª–∏ –≤ –æ—á–µ—Ä–µ–¥–∏

            const chunkGroup = new THREE.Group();
            chunkGroup.name = key;
            chunkGroup.userData.centerPos = new THREE.Vector3(
                chunkX * CHUNK_SIZE + CHUNK_SIZE / 2,
                CHUNK_HEIGHT / 2,
                chunkZ * CHUNK_SIZE + CHUNK_SIZE / 2
            );
            let blockCount = 0;
            let chunkMaxHeight = 0; // –î–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (Occlusion Culling)

            // –í—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤ (–¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞)
            const generatedBlocks = new Map();
            
            // –§—É–Ω–∫—Ü–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –±–ª–æ–∫–∞ (–Ω–µ —Å–æ–∑–¥–∞–µ—Ç –º–µ—à —Å—Ä–∞–∑—É)
            const registerBlock = (x, y, z, type) => {
                const k = `${x},${y},${z}`;
                if (worldBlocks.has(k)) return; // –£–∂–µ –µ—Å—Ç—å –≤ –º–∏—Ä–µ
                if (generatedBlocks.has(k)) return; // –£–∂–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –≤ —ç—Ç–æ–º –±–∞—Ç—á–µ
                generatedBlocks.set(k, { x, y, z, type });
            };
    
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –±–ª–æ–∫–∏ –≤ —á–∞–Ω–∫–µ
            for (let lx = 0; lx < CHUNK_SIZE; lx++) {
                for (let lz = 0; lz < CHUNK_SIZE; lz++) {
                    const worldX = chunkX * CHUNK_SIZE + lx;
                    const worldZ = chunkZ * CHUNK_SIZE + lz;
                    
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—ã—Å–æ—Ç—ã (–•–æ–ª–º—ã –∏ –û–∑–µ—Ä–∞)
                    const seedOffset = worldSeed % 10000;
                    
                    // 1. –û—Å–Ω–æ–≤–∞ –ª–∞–Ω–¥—à–∞—Ñ—Ç–∞ (–±–æ–ª—å—à–∏–µ –ø–ª–∞–≤–Ω—ã–µ —Ö–æ–ª–º—ã)
                    const baseNoise = Math.sin((worldX + seedOffset) * 0.02) * Math.cos((worldZ + seedOffset) * 0.02);
                    
                    // 2. –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è (–º–µ–ª–∫–∏–µ –Ω–µ—Ä–æ–≤–Ω–æ—Å—Ç–∏)
                    const detailNoise = Math.sin((worldX + seedOffset) * 0.1) * Math.cos((worldZ + seedOffset) * 0.1);
                    
                    // 3. –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ–ø–∞–¥ –≤—ã—Å–æ—Ç (–≥–æ—Ä—ã vs —Ä–∞–≤–Ω–∏–Ω—ã)
                    const biomeNoise = Math.sin((worldX + seedOffset) * 0.005) + Math.cos((worldZ + seedOffset) * 0.005);
                    
                    // –ò—Ç–æ–≥–æ–≤–∞—è –≤—ã—Å–æ—Ç–∞: –ë–∞–∑–∞ 12 + (–•–æ–ª–º—ã * 10) + (–î–µ—Ç–∞–ª–∏ * 2) + (–ë–∏–æ–º * 8)
                    let rawHeight = 12 + (baseNoise * 10) + (detailNoise * 2) + (biomeNoise * 8);
                    
                    let height = Math.floor(Math.max(1, Math.min(CHUNK_HEIGHT - 10, rawHeight)));
                    chunkMaxHeight = Math.max(chunkMaxHeight, height);
                    
                    // –ü—Ä–æ—Å—Ç–æ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å –±–µ–∑ –æ–∑–µ—Ä
                    const surfaceY = height - 1;
                    registerBlock(worldX, surfaceY, worldZ, 'grass');
                    blockCount++;

                    for (let depth = 1; depth <= surfaceY; depth++) {
                        const targetY = surfaceY - depth;
                        if (targetY < 0) {
                            break;
                        }
                        const type = depth <= 2 ? 'dirt' : 'stone';
                        registerBlock(worldX, targetY, worldZ, type);
                        blockCount++;
                    }

                        if (surfaceY + 1 < CHUNK_HEIGHT && Math.random() < 0.08) {
                            addTallGrassDecoration(worldX, surfaceY + 1, worldZ, chunkGroup);
                        }

                        // –ó–æ–Ω—ã –ª–µ—Å–æ–≤ (—à—É–º –Ω–∏–∑–∫–æ–π —á–∞—Å—Ç–æ—Ç—ã)
                        const forestNoise = Math.sin((worldX + seedOffset) * 0.03) + Math.cos((worldZ + seedOffset) * 0.03);
                        
                        // –®–∞–Ω—Å —Å–ø–∞–≤–Ω–∞ –¥–µ—Ä–µ–≤–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∑–æ–Ω—ã
                        let treeChance = 0.005; 
                        if (forestNoise > 0.8) {
                            treeChance = 0.04; // –ì—É—Å—Ç–æ–π –ª–µ—Å
                        } else if (forestNoise < -0.5) {
                            treeChance = 0.001; // –†–µ–¥–∫–∏–µ –¥–µ—Ä–µ–≤—å—è
                        }

                        // –£–õ–£–ß–®–ï–ù–ù–´–ï –î–ï–†–ï–í–¨–Ø
                        if (Math.random() < treeChance && Math.abs(worldX) > 5 && Math.abs(worldZ) > 5 && height > 4) {
                            removeDecorationAt(worldX, surfaceY + 1, worldZ);
                            const treeHeight = 5 + Math.floor(Math.random() * 2); // 5-6 –±–ª–æ–∫–æ–≤
                            
                            // –°—Ç–≤–æ–ª –¥–µ—Ä–µ–≤–∞
                            for (let ty = 0; ty < treeHeight; ty++) {
                                registerBlock(worldX, height + ty, worldZ, 'wood');
                            }
                            
                            // –ö–†–ê–°–ò–í–ê–Ø –õ–ò–°–¢–í–ê (3 —Å–ª–æ—è)
                            const topY = height + treeHeight - 1;
                            
                            // –í–µ—Ä—Ö—É—à–∫–∞ (1 –±–ª–æ–∫)
                            registerBlock(worldX, topY + 1, worldZ, 'leaves');
                            
                            // –°—Ä–µ–¥–Ω–∏–π —Å–ª–æ–π (3x3)
                            for (let lx2 = -1; lx2 <= 1; lx2++) {
                                for (let lz2 = -1; lz2 <= 1; lz2++) {
                                    registerBlock(worldX + lx2, topY, worldZ + lz2, 'leaves');
                                }
                            }
                            
                            // –ù–∏–∂–Ω–∏–π —Å–ª–æ–π (5x5 —Å –ø—Ä–æ–ø—É—Å–∫–∞–º–∏ –ø–æ —É–≥–ª–∞–º)
                            for (let lx2 = -2; lx2 <= 2; lx2++) {
                                for (let lz2 = -2; lz2 <= 2; lz2++) {
                                    // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∞–ª—å–Ω–∏–µ —É–≥–ª—ã
                                    if (Math.abs(lx2) === 2 && Math.abs(lz2) === 2) continue;
                                    registerBlock(worldX + lx2, topY - 1, worldZ + lz2, 'leaves');
                                }
                            }
                            
                            // –°–∞–º—ã–π –Ω–∏–∂–Ω–∏–π —Å–ª–æ–π (3x3)
                            for (let lx2 = -1; lx2 <= 1; lx2++) {
                                for (let lz2 = -1; lz2 <= 1; lz2++) {
                                    if (Math.random() < 0.7) { // –°–ª—É—á–∞–π–Ω—ã–µ –ø—Ä–æ–ø—É—Å–∫–∏
                                        registerBlock(worldX + lx2, topY - 2, worldZ + lz2, 'leaves');
                                    }
                                }
                            }
                        }
                }
            }

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤: —Å–æ–∑–¥–∞–µ–º –º–µ—à–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è –≤–∏–¥–∏–º—ã—Ö
            generatedBlocks.forEach(block => {
                const { x, y, z, type } = block;
                
                let visible = false;
                
                // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è –≤–æ–¥—ã: —Å–∫—Ä—ã–≤–∞–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –≥—Ä–∞–Ω–∏
                if (type === 'water') {
                    const neighbors = [
                        [x+1, y, z], [x-1, y, z],
                        [x, y+1, z], [x, y-1, z],
                        [x, y, z+1], [x, y, z-1]
                    ];
                    
                    for (const [nx, ny, nz] of neighbors) {
                        const nk = `${nx},${ny},${nz}`;
                        let neighborType = null;
                        
                        if (generatedBlocks.has(nk)) {
                            neighborType = generatedBlocks.get(nk).type;
                        } else if (worldBlocks.has(nk)) {
                            const wb = worldBlocks.get(nk);
                            neighborType = wb.userData.type;
                        }
                        
                        // –í–æ–¥–∞ –≤–∏–¥–Ω–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≥—Ä–∞–Ω–∏—á–∏—Ç —Å –ù–ï –≤–æ–¥–æ–π (–≤–æ–∑–¥—É—Ö, –∑–µ–º–ª—è, –Ω–æ –Ω–µ –¥—Ä—É–≥–∞—è –≤–æ–¥–∞)
                        if (!neighborType || (neighborType !== 'water' && (NON_SOLID_BLOCKS.has(neighborType) || neighborType === 'leaves'))) {
                            visible = true;
                            break;
                        }
                    }
                } else if (NON_SOLID_BLOCKS.has(type)) {
                    visible = true; // –û—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ –±–ª–æ–∫–∏ (—Å—Ç–µ–∫–ª–æ –∏ —Ç.–¥.) –ø–æ–∫–∞ –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
                } else {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º 6 —Å–æ—Å–µ–¥–µ–π –¥–ª—è —Ç–≤–µ—Ä–¥—ã—Ö –±–ª–æ–∫–æ–≤
                    const neighbors = [
                        [x+1, y, z], [x-1, y, z],
                        [x, y+1, z], [x, y-1, z],
                        [x, y, z+1], [x, y, z-1]
                    ];
                    
                    for (const [nx, ny, nz] of neighbors) {
                        const nk = `${nx},${ny},${nz}`;
                        let neighborType = null;
                        
                        if (generatedBlocks.has(nk)) {
                            neighborType = generatedBlocks.get(nk).type;
                        } else if (worldBlocks.has(nk)) {
                            const wb = worldBlocks.get(nk);
                            neighborType = wb.userData.type;
                        }
                        
                        // –ï—Å–ª–∏ —Å–æ—Å–µ–¥ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç (–≤–æ–∑–¥—É—Ö) –∏–ª–∏ –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π - –º—ã –≤–∏–¥–∏–º—ã
                        if (!neighborType || NON_SOLID_BLOCKS.has(neighborType) || neighborType === 'leaves') {
                            visible = true;
                            break;
                        }
                    }
                }
                
                if (visible) {
                    addBlockToChunk(x, y, z, type, chunkGroup);
                } else {
                    // –°–æ–∑–¥–∞–µ–º "–í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –±–ª–æ–∫" (–±–µ–∑ –º–µ—à–∞, –Ω–æ —Å –¥–∞–Ω–Ω—ã–º–∏ –¥–ª—è —Ñ–∏–∑–∏–∫–∏)
                    const key = `${x},${y},${z}`;
                    const virtualBlock = {
                        userData: { x, y, z, type, solid: true, chunkGroup: chunkGroup },
                        position: { x, y, z },
                        visible: false // –§–ª–∞–≥ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ—Å—Ç–∏
                    };
                    worldBlocks.set(key, virtualBlock);
                }
            });
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è —á–∞–Ω–∫–∞ (–ø–ª–∞–≤–Ω–æ–µ –≤—Å–ø–ª—ã—Ç–∏–µ)
            chunkGroup.position.y = -30; // –ù–∞—á–∏–Ω–∞–µ–º —Å–Ω–∏–∑—É
            chunkGroup.userData.targetY = 0;
            chunkGroup.userData.isAnimating = true;
            chunkGroup.userData.maxHeight = chunkMaxHeight; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–∞–∫—Å. –≤—ã—Å–æ—Ç—É –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
            
            chunks.set(key, chunkGroup);
            scene.add(chunkGroup);
            registerChunkSpatial(chunkX, chunkZ, chunkGroup);
            optimizeChunkRendering(chunkGroup);
            // console.log(`–ß–∞–Ω–∫ [${chunkX}, ${chunkZ}] –∑–∞–≥—Ä—É–∂–µ–Ω: ${blockCount} –±–ª–æ–∫–æ–≤`);
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –±–ª–æ–∫–∞ –ø—Ä–∏ –∫–æ–ø–∞–Ω–∏–∏ –≤–≥–ª—É–±—å
        function ensureBlockExists(x, y, z) {
            const key = `${x},${y},${z}`;
            if (worldBlocks.has(key)) return;
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –±–ª–æ–∫ –Ω–∞ –ª–µ—Ç—É (–∑–µ–º–ª—è –∏–ª–∏ –∫–∞–º–µ–Ω—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≥–ª—É–±–∏–Ω—ã)
            const blockType = y > 2 ? 'dirt' : 'stone';
            addBlock(x, y, z, blockType);
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            const block = worldBlocks.get(key);
            
            if (block) {
                const blockType = block.userData.type;
                const chunkGroup = block.userData.chunkGroup;

                // 1. –£–¥–∞–ª—è–µ–º –∏–∑ —Å—Ü–µ–Ω—ã –∏ –¥–∞–Ω–Ω—ã—Ö
                if (block.parent) {
                    block.parent.remove(block);
                }
                worldBlocks.delete(key);
                
                // 2. –≠—Ñ—Ñ–µ–∫—Ç—ã –∏ –ª–æ–≥–∏–∫–∞ –∏–≥—Ä—ã
                removeDecorationAt(x, y + 1, z);
                worldChanges[key] = null; // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º —É–¥–∞–ª–µ–Ω–∏–µ
                spawnBlockDrop(blockType, x, y, z);
                soundManager.play('block_break', { material: blockType });

                // 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å–µ–¥–µ–π –∏ "–ø—Ä–æ—è–≤–ª—è–µ–º" —Å–∫—Ä—ã—Ç—ã–µ –±–ª–æ–∫–∏
                const neighbors = [
                    [x+1, y, z], [x-1, y, z],
                    [x, y+1, z], [x, y-1, z],
                    [x, y, z+1], [x, y, z-1]
                ];
                
                const chunksToUpdate = new Set();
                if (chunkGroup) chunksToUpdate.add(chunkGroup);

                for (const [nx, ny, nz] of neighbors) {
                    const nk = `${nx},${ny},${nz}`;
                    const neighbor = worldBlocks.get(nk);
                    if (neighbor) {
                        // –ï—Å–ª–∏ —ç—Ç–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –±–ª–æ–∫ (–Ω–µ Mesh)
                        if (!neighbor.isMesh) {
                            const nType = neighbor.userData.type;
                            const nChunkGroup = neighbor.userData.chunkGroup;
                            
                            worldBlocks.delete(nk);
                            addBlockToChunk(nx, ny, nz, nType, nChunkGroup);
                            
                            if (nChunkGroup) chunksToUpdate.add(nChunkGroup);
                        } else {
                            // –ï—Å–ª–∏ —Ä–µ–∞–ª—å–Ω—ã–π –±–ª–æ–∫, –Ω–æ –≤ –¥—Ä—É–≥–æ–º —á–∞–Ω–∫–µ, –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å –µ–≥–æ –≥–µ–æ–º–µ—Ç—Ä–∏—é
                            if (neighbor.userData.chunkGroup && neighbor.userData.chunkGroup !== chunkGroup) {
                                chunksToUpdate.add(neighbor.userData.chunkGroup);
                            }
                        }
                    }
                }

                // 4. –û–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ –∑–∞—Ç—Ä–æ–Ω—É—Ç—ã–µ —á–∞–Ω–∫–∏
                chunksToUpdate.forEach(cg => {
                    optimizeChunkRendering(cg);
                });
            }
        }

        let particles = [];
        const PARTICLE_GRAVITY = 15;

        function spawnBlockParticles(x, y, z, blockType, count = 5) {
            if (!particlesEnabled) return;
            
            const definition = getItemDefinition(blockType);
            if (!definition) return;
            
            // –ü–æ–ª—É—á–∞–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª –±–ª–æ–∫–∞ –¥–ª—è —á–∞—Å—Ç–∏—Ü
            let material = null;
            if (sharedMaterials[blockType]) {
                const mats = sharedMaterials[blockType];
                // –ë–µ—Ä–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª –≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω–∏ –∏–ª–∏ –ø–µ—Ä–≤—ã–π –¥–æ—Å—Ç—É–ø–Ω—ã–π
                material = mats[2] || mats[0];
            }
            
            if (!material) return;

            // –°–æ–∑–¥–∞–µ–º –º–∞–ª–µ–Ω—å–∫–∏–µ —á–∞—Å—Ç–∏—Ü—ã
            const particleGeo = new THREE.PlaneGeometry(0.1, 0.1);
            
            for (let i = 0; i < count; i++) {
                const mesh = new THREE.Mesh(particleGeo, material.clone());
                // –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –≤–Ω—É—Ç—Ä–∏ –±–ª–æ–∫–∞
                mesh.position.set(
                    x + Math.random() * 0.8 - 0.4,
                    y + Math.random() * 0.8 - 0.4,
                    z + Math.random() * 0.8 - 0.4
                );
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 4,
                    Math.random() * 4 + 1,
                    (Math.random() - 0.5) * 4
                );
                
                mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                
                scene.add(mesh);
                particles.push({
                    mesh,
                    velocity,
                    age: 0,
                    maxAge: 0.5 + Math.random() * 0.5
                });
            }
        }

        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.age += delta;
                
                if (p.age >= p.maxAge) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                    continue;
                }
                
                p.velocity.y -= PARTICLE_GRAVITY * delta;
                p.mesh.position.addScaledVector(p.velocity, delta);
                p.mesh.rotation.x += delta * 2;
                p.mesh.rotation.y += delta * 2;
                
                // –ö–æ–ª–ª–∏–∑–∏—è —Å –ø–æ–ª–æ–º (–ø—Ä–æ—Å—Ç–∞—è)
                if (p.mesh.position.y < -64 || isSolidBlock(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z)) {
                     scene.remove(p.mesh);
                     particles.splice(i, 1);
                }
            }
        }

        function spawnItemDrop(itemId, x, y, z, options = {}) {
            if (!dropGeometry) {
                dropGeometry = new THREE.BoxGeometry(DROP_SIZE, DROP_SIZE, DROP_SIZE);
            }

            const {
                quantity = 1,
                exactPosition = false,
                initialVelocity = null,
                pickupDelay = 0,
                velocityJitter = initialVelocity ? 0.15 : 0
            } = options;

            const definition = getItemDefinition(itemId);
            if (!definition) {
                return null;
            }

            let meshMaterial = null;
            let visualMesh = null;

            if (sharedMaterials[itemId]) {
                const materials = sharedMaterials[itemId];
                visualMesh = new THREE.Mesh(dropGeometry, materials.map(mat => (mat?.clone ? mat.clone() : mat)));
            } else {
                const fallbackColor = definition.iconColor || DEFAULT_ICON_COLORS[definition.category] || '#cfcfcf';
                meshMaterial = new THREE.MeshLambertMaterial({ color: fallbackColor });
                visualMesh = new THREE.Mesh(dropGeometry, meshMaterial);
            }

            if (!visualMesh) {
                return null;
            }

            // –°–æ–∑–¥–∞–µ–º –≥—Ä—É–ø–ø—É –¥–ª—è —Ñ–∏–∑–∏–∫–∏
            const group = new THREE.Group();

            if (exactPosition) {
                group.position.set(x, y, z);
            } else {
                group.position.set(x + 0.5, y + 0.5, z + 0.5);
            }
            
            // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π –º–µ—à (–º–µ–Ω—å—à–µ –∏ —Å–¥–≤–∏–Ω—É—Ç –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è)
            visualMesh.castShadow = true;
            visualMesh.receiveShadow = true;
            visualMesh.scale.set(0.5, 0.5, 0.5); // –ú–µ–Ω—å—à–µ –±–ª–æ–∫–∞
            
            group.add(visualMesh);

            let velocity;
            if (initialVelocity && typeof initialVelocity.x === 'number') {
                velocity = new THREE.Vector3(initialVelocity.x, initialVelocity.y, initialVelocity.z);
                if (velocityJitter > 0) {
                    velocity.x += (Math.random() - 0.5) * velocityJitter;
                    velocity.y += (Math.random() - 0.5) * velocityJitter;
                    velocity.z += (Math.random() - 0.5) * velocityJitter;
                }
            } else {
                velocity = new THREE.Vector3((Math.random() - 0.5) * 2.5, 3 + Math.random() * 1.5, (Math.random() - 0.5) * 2.5).multiplyScalar(0.25);
            }
            
            const drop = {
                mesh: group, // –§–∏–∑–∏—á–µ—Å–∫–∏–π –æ–±—ä–µ–∫—Ç (–≥—Ä—É–ø–ø–∞)
                visual: visualMesh, // –í–∏–∑—É–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç (–º–µ—à –≤–Ω—É—Ç—Ä–∏)
                velocity,
                type: itemId,
                qty: quantity,
                age: 0,
                grounded: false,
                pickupDelay: Math.max(0, pickupDelay),
                bobOffset: Math.random() * Math.PI * 2
            };

            scene.add(group);
            droppedItems.push(drop);
            return drop;
        }

        function spawnBlockDrop(blockType, x, y, z) {
            spawnItemDrop(blockType, x, y, z);
        }

        function dropSelectedItem() {
            if (inventoryOpen || isPaused || isDead) {
                return;
            }
            const stack = getSelectedHotbarStack();
            if (!stack || stack.qty <= 0) {
                return;
            }

            const definition = getItemDefinition(stack.id);
            if (!definition) {
                return;
            }

            const forward = new THREE.Vector3(
                -Math.sin(player.rotation.y),
                0,
                -Math.cos(player.rotation.y)
            ).normalize();

            const dropOrigin = new THREE.Vector3().copy(player.position);
            dropOrigin.y -= PLAYER_HEIGHT * 0.6;
            dropOrigin.addScaledVector(forward, 1.6);

            const throwVelocity = forward.clone().multiplyScalar(2.3);
            throwVelocity.y += 1.25;

            spawnItemDrop(stack.id, dropOrigin.x, dropOrigin.y, dropOrigin.z, {
                quantity: 1,
                exactPosition: true,
                initialVelocity: throwVelocity,
                velocityJitter: 0.25,
                pickupDelay: 1.0
            });

            stack.qty -= 1;
            if (stack.qty <= 0) {
                inventoryState.hotbar[player.selectedSlot] = null;
            }
            refreshInventoryUI();
        }

        function collectDrop(drop, index) {
            const success = depositItemToInventory(drop.type, drop.qty);
            if (!success) {
                return;
            }
            scene.remove(drop.mesh);
            droppedItems.splice(index, 1);
            refreshInventoryUI();
            soundManager.play('item_pickup');
        }

        function depositItemToInventory(itemId, quantity) {
            let stack = { id: itemId, qty: quantity };
            const definition = getItemDefinition(itemId);
            const categoryId = definition?.category ? definition.category : 'blocks';
            let remainder = placeStackIntoArray(stack, inventoryState.hotbar);
            if (remainder) {
                remainder = placeStackIntoArray(remainder, ensureCategoryStorage(categoryId));
            }
            return !remainder;
        }

        function updateDroppedItems(delta) {
            if (!droppedItems.length) {
                return;
            }

            for (let i = droppedItems.length - 1; i >= 0; i--) {
                const drop = droppedItems[i];
                drop.age += delta;

                drop.velocity.y -= DROP_GRAVITY * delta;
                drop.mesh.position.addScaledVector(drop.velocity, delta);

                // –ê–Ω–∏–º–∞—Ü–∏—è –∫–∞–∫ –≤ Minecraft (–≤—Ä–∞—â–µ–Ω–∏–µ –∏ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ)
                if (drop.visual) {
                    // –í—Ä–∞—â–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ Y
                    drop.visual.rotation.y += delta * 1.5;
                    
                    // –ü–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤–≤–µ—Ä—Ö-–≤–Ω–∏–∑
                    const bobHeight = 0.15;
                    const bobSpeed = 3.0;
                    drop.visual.position.y = Math.sin(drop.age * bobSpeed + drop.bobOffset) * bobHeight;
                } else if (drop.rotationSpeed) {
                    // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Å—Ç–∞—Ä—ã—Ö –¥—Ä–æ–ø–æ–≤ (–µ—Å–ª–∏ –µ—Å—Ç—å)
                    drop.mesh.rotation.x += drop.rotationSpeed.x * delta;
                    drop.mesh.rotation.y += drop.rotationSpeed.y * delta;
                    drop.mesh.rotation.z += drop.rotationSpeed.z * delta;
                }

                if (drop.mesh.position.y < -64) {
                    scene.remove(drop.mesh);
                    droppedItems.splice(i, 1);
                    continue;
                }

                // –ü—Ä–æ—Å—Ç–∞—è –∫–æ–ª–ª–∏–∑–∏—è —Å –∑–µ–º–ª–µ–π
                const colliderRadius = DROP_SIZE / 2;
                const belowY = Math.round(drop.mesh.position.y - colliderRadius - 0.05);
                const belowSolid = isSolidBlock(drop.mesh.position.x, belowY, drop.mesh.position.z);
                
                if (belowSolid) {
                    const groundLevel = belowY + 0.5 + colliderRadius;
                    if (drop.mesh.position.y < groundLevel) {
                        drop.mesh.position.y = groundLevel;
                        if (drop.velocity.y < 0) {
                            drop.velocity.y = 0;
                        }
                        drop.velocity.x *= DROP_FRICTION;
                        drop.velocity.z *= DROP_FRICTION;
                        drop.grounded = true;
                    }
                } else {
                    drop.grounded = false;
                }

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–±–æ—Ä –∏–≥—Ä–æ–∫–æ–º
                const dx = player.position.x - drop.mesh.position.x;
                const dy = (player.position.y - PLAYER_HEIGHT * 0.5) - drop.mesh.position.y;
                const dz = player.position.z - drop.mesh.position.z;
                const distanceSq = dx * dx + dy * dy + dz * dz;
                const pickupDelay = typeof drop.pickupDelay === 'number' ? drop.pickupDelay : 0;
                if (drop.age >= pickupDelay && distanceSq <= DROP_PICKUP_RADIUS * DROP_PICKUP_RADIUS) {
                    collectDrop(drop, i);
                }
            }
        }

        // –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º getBlock - –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –±–ª–æ–∫–∏
        function getBlock(x, y, z) {
            const key = `${Math.round(x)},${Math.round(y)},${Math.round(z)}`;
            return worldBlocks.get(key) || null;
        }

        function isSolidBlock(x, y, z) {
            const block = getBlock(x, y, z);
            return !!(block && block.userData && block.userData.solid);
        }

        function isWaterBlock(x, y, z) {
            const block = getBlock(x, y, z);
            return !!(block && block.userData && block.userData.type === 'water');
        }

        function raycast() {
            const raycaster = new THREE.Raycaster();
            raycaster.layers.enable(1); // —É—á–∏—Ç—ã–≤–∞—Ç—å –Ω–µ–≤–∏–¥–∏–º—ã–µ —Å–ª—É–∂–µ–±–Ω—ã–µ –±–ª–æ–∫–∏
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            raycaster.far = 10; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
            
            // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –±–ª–æ–∫–∏ –≤ –±–ª–∏–∂–∞–π—à–∏—Ö —á–∞–Ω–∫–∞—Ö
            const targetBlocks = [];
            const queryRadius = CHUNK_SIZE * 3;
            const range = {
                minX: player.position.x - queryRadius,
                maxX: player.position.x + queryRadius,
                minZ: player.position.z - queryRadius,
                maxZ: player.position.z + queryRadius
            };
            const candidates = chunkQuadTree.query(range);

            if (candidates.length) {
                for (const entry of candidates) {
                    const chunk = entry.data;
                    if (chunk && chunk.children?.length) {
                        targetBlocks.push(...chunk.children);
                    }
                }
            } else {
                const playerChunkX = Math.floor(player.position.x / CHUNK_SIZE);
                const playerChunkZ = Math.floor(player.position.z / CHUNK_SIZE);
                for (let cx = -2; cx <= 2; cx++) {
                    for (let cz = -2; cz <= 2; cz++) {
                        const chunkKey = getChunkKey(playerChunkX + cx, playerChunkZ + cz);
                        const chunk = chunks.get(chunkKey);
                        if (chunk && chunk.children?.length) {
                            targetBlocks.push(...chunk.children);
                        }
                    }
                }
            }
            
            const intersects = raycaster.intersectObjects(targetBlocks, false);
            if (!intersects.length) {
                return null;
            }
            for (const hit of intersects) {
                if (hit.object?.userData?.solid) {
                    return hit;
                }
            }
            return null;
        }
        
        function startBreaking() {
            if (!pointerLocked || inventoryOpen) return;

            const blockHit = raycast();
            const animalHit = raycastPassiveAnimal();
            const decorationHit = raycastDecoration();
            const blockDistance = blockHit ? blockHit.distance : Infinity;
            const animalDistance = animalHit ? animalHit.distance : Infinity;
            const decorationDistance = decorationHit ? decorationHit.distance : Infinity;

            if (animalHit && animalDistance <= blockDistance && animalDistance <= decorationDistance) {
                attackPassiveAnimal(animalHit.animal, 0.5);
                return;
            }

            if (decorationHit && decorationDistance <= blockDistance) {
                removeDecorationByKey(decorationHit.key);
                soundManager.play('block_break', { material: 'dirt' });
                return;
            }

            if (blockHit && blockDistance < 5) {
                const block = blockHit.object;
                if (!block.userData || !block.userData.solid) {
                    return;
                }
                const key = `${block.userData.x},${block.userData.y},${block.userData.z}`;

                if (breakingBlock !== key) {
                    breakingBlock = key;
                    breakProgress = 0;
                    isBreaking = true;
                }
            }
        }
        
        function stopBreaking() {
            isBreaking = false;
            breakingBlock = null;
            breakProgress = 0;
            document.getElementById('breakProgress').style.display = 'none';
            if (window.crackOverlay) {
                window.crackOverlay.visible = false;
            }
        }
        
        function updateBreaking(delta) {
            if (!isBreaking || !breakingBlock) return;
            
            const hit = raycast();
            if (!hit || hit.distance >= 5) {
                stopBreaking();
                return;
            }
            
            const block = hit.object;
            if (!block.userData || !block.userData.solid) {
                stopBreaking();
                return;
            }
            const key = `${block.userData.x},${block.userData.y},${block.userData.z}`;
            
            if (key !== breakingBlock) {
                stopBreaking();
                return;
            }
            
            let breakTime = BREAK_TIME * 1.5; // –ù–µ–º–Ω–æ–≥–æ –º–µ–¥–ª–µ–Ω–Ω–µ–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            if (block.userData.type === 'stone') {
                breakTime = 7.0; // –û—á–µ–Ω—å –¥–æ–ª–≥–æ
            } else if (block.userData.type === 'wood') {
                breakTime = 2.5; // –¢–≤–µ—Ä–¥–æ–µ
            } else if (block.userData.type === 'dirt' || block.userData.type === 'grass' || block.userData.type === 'sand') {
                breakTime = 0.6; // –ë—ã—Å—Ç—Ä–æ, –Ω–æ –º–µ–¥–ª–µ–Ω–Ω–µ–µ —á–µ–º —Ä–∞–Ω—å—à–µ
            }

            breakProgress += delta / breakTime;
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å (–æ—Ç–∫–ª—é—á–µ–Ω–æ)
            // const progressBar = document.getElementById('breakProgress');
            // progressBar.style.display = 'block';
            // progressBar.querySelector('.bar').style.width = (breakProgress * 100) + '%';
            
            // –ê–Ω–∏–º–∞—Ü–∏—è —Ç—Ä–µ—â–∏–Ω (5 —Å—Ç–∞–¥–∏–π)
            const stage = Math.min(4, Math.floor(breakProgress * 5));
            window.crackOverlay.material.map = textures[`destroy_${stage}`];
            window.crackOverlay.position.copy(block.position);
            window.crackOverlay.visible = true;
            
            if (breakProgress >= 1) {
                spawnBlockParticles(block.userData.x + 0.5, block.userData.y + 0.5, block.userData.z + 0.5, block.userData.type, 15);
                removeBlock(block.userData.x, block.userData.y, block.userData.z);
                stopBreaking();
            }
        }
        
        function placeBlock() {
            const hit = raycast();
            if (hit && hit.distance < 5) {
                const block = hit.object;
                if (!block.userData || block.userData.type === 'water') {
                    return;
                }
                const normal = hit.face.normal;
                
                // –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ä–∞—Å—á—ë—Ç –ø–æ–∑–∏—Ü–∏–∏ –Ω–æ–≤–æ–≥–æ –±–ª–æ–∫–∞
                const newX = block.userData.x + Math.round(normal.x);
                const newY = block.userData.y + Math.round(normal.y);
                const newZ = block.userData.z + Math.round(normal.z);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –Ω–µ —Å—Ç–∞–≤–∏–º –±–ª–æ–∫ –Ω–∞ –º–µ—Å—Ç–µ –∏–≥—Ä–æ–∫–∞
                const dx = Math.abs(newX - Math.round(player.position.x));
                const dy = Math.abs(newY - Math.round(player.position.y - PLAYER_HEIGHT * 0.5)); // –¶–µ–Ω—Ç—Ä —Ö–∏—Ç–±–æ–∫—Å–∞ –∏–≥—Ä–æ–∫–∞
                const dz = Math.abs(newZ - Math.round(player.position.z));
                
                if (dx > 0 || dy > 1 || dz > 0) {
                    if (isWaterBlock(newX, newY, newZ)) {
                        return;
                    }
                    const selectedStack = getSelectedHotbarStack();
                    if (!selectedStack) {
                        return;
                    }
                    const definition = getItemDefinition(selectedStack.id);
                    if (!definition || definition.category !== 'blocks') {
                        return;
                    }
                    removeDecorationAt(newX, newY, newZ);
                    addBlock(newX, newY, newZ, definition.id);
                    worldChanges[`${newX},${newY},${newZ}`] = definition.id;
                    selectedStack.qty -= 1;
                    if (selectedStack.qty <= 0) {
                        inventoryState.hotbar[player.selectedSlot] = null;
                    }
                    refreshInventoryUI();
                    soundManager.play('block_place', { material: definition.id });
                }
            }
        }
        
        function safeRequestPointerLock() {
            if (!canvas) return;
            // –í —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –±—Ä–∞—É–∑–µ—Ä–∞—Ö requestPointerLock –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Promise
            try {
                const promise = canvas.requestPointerLock();
                if (promise && typeof promise.catch === 'function') {
                    promise.catch(err => {
                        // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–º–µ–Ω–∏–ª –∑–∞—Ö–≤–∞—Ç –∏–ª–∏ —Å–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ –∫–ª–∏–∫–∞–ª
                        if (err.name === 'SecurityError' || err.name === 'NotSupportedError') {
                            // console.log('Pointer lock suppressed:', err.message);
                        } else {
                            console.warn('Pointer lock failed:', err);
                        }
                    });
                }
            } catch (e) {
                console.warn('Pointer lock error:', e);
            }
        }

        function setupControls() {
            let lastAutoPauseTime = 0;

            document.addEventListener('keydown', (e) => {
                // F1 –∏–ª–∏ Escape - –æ—Ç–∫—Ä—ã—Ç–∏–µ –º–µ–Ω—é –ø–∞—É–∑—ã
                if (e.code === 'F1' || e.code === 'Escape') {
                    e.preventDefault();
                    
                    // –ï—Å–ª–∏ —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å—Ä–∞–±–æ—Ç–∞–ª–∞ –∞–≤—Ç–æ-–ø–∞—É–∑–∞ (–∏–∑-–∑–∞ –ø–æ—Ç–µ—Ä–∏ —Ñ–æ–∫—É—Å–∞), –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–∞–∂–∞—Ç–∏–µ
                    if (Date.now() - lastAutoPauseTime < 100) return;

                    togglePause();
                    return;
                }
                
                // F2 - –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ —á–∞–Ω–∫–æ–≤
                if (e.code === 'F2') {
                    e.preventDefault();
                    console.log('–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ —á–∞–Ω–∫–æ–≤...');
                    
                    const chunkKeys = Array.from(chunks.keys());
                    chunkKeys.forEach((key) => {
                        const [cx, cz] = key.split(',').map(Number);
                        unloadChunk(cx, cz);
                    });
                    worldDecorations.clear();
                    chunkLODCache.clear();
                    
                    // –†–µ–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —á–∞–Ω–∫–∏
                    for (let x = -renderDistance; x <= renderDistance; x++) {
                        for (let z = -renderDistance; z <= renderDistance; z++) {
                            const chunkX = Math.floor(player.position.x / CHUNK_SIZE) + x;
                            const chunkZ = Math.floor(player.position.z / CHUNK_SIZE) + z;
                            loadChunk(chunkX, chunkZ);
                        }
                    }
                    updateAllChunksLOD();
                    console.log('‚úì –ß–∞–Ω–∫–∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω—ã');
                    return;
                }
                
                // F3 - Debug –ø–∞–Ω–µ–ª—å (–∫–∞–∫ –≤ Minecraft)
                if (e.code === 'F3') {
                    e.preventDefault();
                    const debugPanel = document.getElementById('debugPanel');
                    debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
                    return;
                }
                
                if (isPaused) return;
                
                if (e.code === 'KeyQ') {
                    e.preventDefault();
                    dropSelectedItem();
                    return;
                }

                if (e.code === 'KeyF') {
                    if (consumeSelectedFood()) {
                        e.preventDefault();
                        return;
                    }
                }

                // Map codes to keys for controls
                const keyMap = {
                    'KeyW': 'w',
                    'KeyA': 'a',
                    'KeyS': 's',
                    'KeyD': 'd',
                    'Space': ' ',
                    'ShiftLeft': 'shift',
                    'ShiftRight': 'shift'
                };

                if (keyMap[e.code]) {
                    controls[keyMap[e.code]] = true;
                } else {
                    controls[e.key.toLowerCase()] = true;
                }
                
                // –í—ã–±–æ—Ä —Å–ª–æ—Ç–∞ (1-9 –∏ 0 –¥–ª—è 10-–≥–æ)
                if (e.code.startsWith('Digit')) {
                    const digit = parseInt(e.code.replace('Digit', ''), 10);
                    if (digit >= 1 && digit <= 9) {
                        const index = digit - 1;
                        if (index >= 0 && index < HOTBAR_SIZE) {
                            player.selectedSlot = index;
                            updateHotbar();
                        }
                    } else if (digit === 0 && HOTBAR_SIZE === 9) {
                        player.selectedSlot = HOTBAR_SIZE - 1;
                        updateHotbar();
                    }
                }
                
                // –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å
                if (e.code === 'KeyE') {
                    toggleInventory();
                }
            });

            document.addEventListener('keyup', (e) => {
                const keyMap = {
                    'KeyW': 'w',
                    'KeyA': 'a',
                    'KeyS': 's',
                    'KeyD': 'd',
                    'Space': ' ',
                    'ShiftLeft': 'shift',
                    'ShiftRight': 'shift'
                };
                if (keyMap[e.code]) {
                    controls[keyMap[e.code]] = false;
                } else {
                    controls[e.key.toLowerCase()] = false;
                }
            });
            
            // –ö–æ–ª–µ—Å–∏–∫–æ –º—ã—à–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Å–ª–æ—Ç–∞
            canvas.addEventListener('wheel', (e) => {
                if (isPaused || inventoryOpen) return;
                
                e.preventDefault();
                
                if (e.deltaY > 0) {
                    player.selectedSlot = (player.selectedSlot + 1) % HOTBAR_SIZE;
                } else {
                    player.selectedSlot = (player.selectedSlot - 1 + HOTBAR_SIZE) % HOTBAR_SIZE;
                }
                
                updateHotbar();
            }, { passive: false });
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∏
            const renderDistanceSlider = document.getElementById('renderDistance');
            if (renderDistanceSlider) {
                renderDistanceSlider.addEventListener('input', (e) => {
                    const clamped = applyRenderDistanceSetting(parseInt(e.target.value, 10), graphicsQuality);
                    e.target.value = clamped;
                });
            }

            const sensitivitySlider = document.getElementById('sensitivity');
            if (sensitivitySlider) {
                sensitivitySlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    mouseSensitivity = (value / 50) * 0.002;
                    const label = document.getElementById('sensitivityValue');
                    if (label) {
                        label.textContent = value;
                    }
                });
            }
            
            const graphicsQualitySelect = document.getElementById('graphicsQualitySelect');
            if (graphicsQualitySelect) {
                graphicsQualitySelect.addEventListener('change', (e) => {
                    graphicsQuality = e.target.value;
                    const labels = { low: '–ù–∏–∑–∫–∞—è', medium: '–°—Ä–µ–¥–Ω—è—è', high: '–í—ã—Å–æ–∫–∞—è', ultra: '–£–ª—å—Ç—Ä–∞' };
                    const label = document.getElementById('graphicsQualityValue');
                    if (label) {
                        label.textContent = labels[graphicsQuality];
                    }
                    applyRenderDistanceSetting(renderDistance, graphicsQuality);
                });
            }
            
            const textureResolutionSelect = document.getElementById('textureResolution');
            if (textureResolutionSelect) {
                textureResolutionSelect.parentElement.style.display = 'none'; // –°–∫—Ä—ã–≤–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É
            }
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —á–µ–∫–±–æ–∫—Å–æ–≤
            const showFPSCheckbox = document.getElementById('showFPS');
            if (showFPSCheckbox) {
                showFPSCheckbox.addEventListener('change', (e) => {
                    showFPS = e.target.checked;
                    const fpsElement = document.getElementById('fps');
                    if (fpsElement) {
                        fpsElement.style.display = showFPS ? 'block' : 'none';
                    }
                });
            }

            const smoothLightingCheckbox = document.getElementById('smoothLighting');
            if (smoothLightingCheckbox) {
                smoothLightingCheckbox.addEventListener('change', (e) => {
                    smoothLighting = e.target.checked;
                });
            }

            const fancyCloudsCheckbox = document.getElementById('fancyClouds');
            if (fancyCloudsCheckbox) {
                fancyCloudsCheckbox.addEventListener('change', (e) => {
                    fancyClouds = e.target.checked;
                });
            }

            const particlesEnabledCheckbox = document.getElementById('particlesEnabled');
            if (particlesEnabledCheckbox) {
                particlesEnabledCheckbox.addEventListener('change', (e) => {
                    particlesEnabled = e.target.checked;
                });
            }
            
            document.addEventListener('mousedown', (e) => {
                if (!pointerLocked || inventoryOpen) return;

                if (e.button === 0) {
                    leftMouseHeld = true;
                    playerHand.swing(); // –°—Ä–∞–∑—É –º–∞—à–µ–º
                    startBreaking();
                } else if (e.button === 2) {
                    rightMouseHeld = true;
                    playerHand.swing(); // –ú–∞—à–µ–º –∏ –ø—Ä–∏ –ü–ö–ú
                    const ate = consumeSelectedFood();
                    if (!ate) {
                        placeBlock();
                    }
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    leftMouseHeld = false;
                    stopBreaking();
                } else if (e.button === 2) {
                    rightMouseHeld = false;
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!pointerLocked) return;
                mouse.x += e.movementX;
                mouse.y += e.movementY;
            });

            // –ó–∞—Ö–≤–∞—Ç –∫—É—Ä—Å–æ—Ä–∞ –ø—Ä–∏ –∫–ª–∏–∫–µ (—Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è –∏–≥—Ä—ã)
            document.addEventListener('click', () => {
                soundManager.unlock();
                if (!pointerLocked && gameStarted && !isPaused && !inventoryOpen && !isDead) {
                    safeRequestPointerLock();
                }
            });
            
            // –¢–∞–∫–∂–µ –ø—ã—Ç–∞–µ–º—Å—è –∑–∞—Ö–≤–∞—Ç–∏—Ç—å –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –Ω–∞ canvas
            canvas.addEventListener('click', () => {
                soundManager.unlock();
                if (!pointerLocked && gameStarted) {
                    safeRequestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                pointerLocked = document.pointerLockElement === canvas;
                console.log('Pointer lock:', pointerLocked ? '–ó–ê–•–í–ê–ß–ï–ù' : '–û–¢–ü–£–©–ï–ù');
                if (!pointerLocked) {
                    rightMouseHeld = false;
                    
                    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø–∞—É–∑–∞ –ø—Ä–∏ –ø–æ—Ç–µ—Ä–µ —Ñ–æ–∫—É—Å–∞ (Esc, Alt-Tab)
                    if (gameStarted && !isPaused && !inventoryOpen && !isDead) {
                        togglePause();
                        lastAutoPauseTime = Date.now();
                    }
                }
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º/—Å–∫—Ä—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É
                const clickHint = document.getElementById('clickHint');
                if (gameStarted && !isPaused && !inventoryOpen && !isDead) {
                    clickHint.style.display = pointerLocked ? 'none' : 'block';
                } else {
                    clickHint.style.display = 'none';
                }
            });

            console.log('‚úì –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ');
        }
        
        function updateHotbar() {
            renderHotbarTextures();
            playerHand.updateItem();
        }

        function renderHotbarTextures() {
            renderWorldHotbar();
            renderInventoryHotbarOverlay();
        }
        
        function toggleInventory(forceOpen) {
            const targetState = typeof forceOpen === 'boolean' ? forceOpen : !inventoryOpen;
            if (inventoryOpen === targetState) {
                return;
            }

            inventoryOpen = targetState;
            const inv = inventoryUIRefs.inventoryRoot || document.getElementById('inventory');

            if (!inv) {
                return;
            }

            if (inventoryOpen) {
                inv.classList.add('visible');
                document.exitPointerLock?.();
                renderInventoryGrid();
                renderInventoryHotbarOverlay();
                soundManager.play('ui_open');
                if (stevePreview) {
                    try {
                        stevePreview.start();
                    } catch (e) {
                        console.error('StevePreview start failed:', e);
                    }
                }
            } else {
                inv.classList.remove('visible');
                hideTooltip();
                if (dragState.active) {
                    dragState.stack = null;
                    endDrag();
                }
                if (gameStarted) {
                    safeRequestPointerLock();
                }
                soundManager.play('ui_close');
                if (stevePreview) {
                    try {
                        stevePreview.stop();
                    } catch (e) {
                        console.error('StevePreview stop failed:', e);
                    }
                }
            }
        }

        function togglePause() {
            isPaused = !isPaused;
            const pauseMenu = document.getElementById('pauseMenu');
            const resumeBtn = document.getElementById('resumeBtn');
            const backBtn = document.getElementById('backToMenuBtn');
            const clickHint = document.getElementById('clickHint');
            
            if (isPaused) {
                pauseMenu.classList.add('visible');
                if (clickHint) clickHint.style.display = 'none';
                // –û—Ç–∫–ª—é—á–∞–µ–º pointer lock —á—Ç–æ–±—ã –∫—É—Ä—Å–æ—Ä –±—ã–ª –≤–∏–¥–µ–Ω
                document.exitPointerLock();
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–≥—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞
                if (gameStarted) {
                    resumeBtn.style.display = 'block';
                    backBtn.textContent = '–í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é';
                } else {
                    resumeBtn.style.display = 'none';
                    backBtn.textContent = '–ù–∞–∑–∞–¥';
                }
            } else {
                pauseMenu.classList.remove('visible');
                // –ó–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º –º—ã—à—å –æ–±—Ä–∞—Ç–Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–≥—Ä–∞ –∏–¥—ë—Ç
                if (gameStarted) {
                    setTimeout(() => {
                        safeRequestPointerLock();
                    }, 100);
                }
            }
        }
        
        function resumeGame() {
            if (gameStarted) {
                togglePause();
            }
        }
        
        function backToMenu() {
            if (gameStarted) {
                isPaused = false;
                gameStarted = false;
                document.getElementById('pauseMenu').classList.remove('visible');
                document.getElementById('menu').classList.remove('hidden');
                document.exitPointerLock();
                soundManager.stopAmbience();
            } else {
                document.getElementById('pauseMenu').classList.remove('visible');
                document.getElementById('menu').classList.remove('hidden');
            }
        }
        
        function saveWorld() {
            if (!currentWorldId) {
                console.error('–ù–µ –≤—ã–±—Ä–∞–Ω –º–∏—Ä –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è!');
                return;
            }

            const saveData = {
                worldChanges,
                playerPos: {
                    x: player.position.x,
                    y: player.position.y,
                    z: player.position.z
                },
                timestamp: Date.now()
            };
            localStorage.setItem('minecraftWorld_' + currentWorldId, JSON.stringify(saveData));
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–∫—É –≤—Ä–µ–º–µ–Ω–∏ –≤ –∏–Ω–¥–µ–∫—Å–µ
            const worlds = getWorldsIndex();
            const world = worlds.find(w => w.id === currentWorldId);
            if (world) {
                world.lastPlayed = Date.now();
                saveWorldsIndex(worlds);
            }

            console.log('‚úì –ú–∏—Ä —Å–æ—Ö—Ä–∞–Ω—ë–Ω:', Object.keys(worldChanges).length, '–∏–∑–º–µ–Ω–µ–Ω–∏–π');
            alert('–ú–∏—Ä —Å–æ—Ö—Ä–∞–Ω—ë–Ω!');
        }
        
        function loadWorldMetadata() {
            if (!currentWorldId) {
                const worlds = getWorldsIndex();
                if (worlds.length > 0) {
                    currentWorldId = worlds[0].id;
                } else {
                    worldSeed = Math.floor(Math.random() * 2147483647);
                    return;
                }
            }

            const saved = localStorage.getItem('minecraftWorld_' + currentWorldId);
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    worldChanges = data.worldChanges || {};
                    worldSeed = data.seed !== undefined ? data.seed : Math.floor(Math.random() * 2147483647);
                    
                    if (data.playerPos) {
                        player.position.set(data.playerPos.x, data.playerPos.y, data.playerPos.z);
                        player.velocity.set(0, 0, 0);
                    }
                    console.log('‚úì –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –º–∏—Ä–∞ –∑–∞–≥—Ä—É–∂–µ–Ω—ã. –°–∏–¥:', worldSeed);
                } catch(e) {
                    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –º–∏—Ä–∞:', e);
                    worldChanges = {};
                    worldSeed = Math.floor(Math.random() * 2147483647);
                }
            } else {
                worldSeed = Math.floor(Math.random() * 2147483647);
            }
        }

        function applySavedChanges() {
            if (!worldChanges || Object.keys(worldChanges).length === 0) return;
            
            console.log('–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π –º–∏—Ä–∞...');
            Object.keys(worldChanges).forEach(key => {
                const [x, y, z] = key.split(',').map(Number);
                const blockType = worldChanges[key];
                
                if (blockType === null) {
                    // –ë–ª–æ–∫ –±—ã–ª —É–¥–∞–ª—ë–Ω
                    removeBlock(x, y, z);
                } else {
                    // –ë–ª–æ–∫ –±—ã–ª –¥–æ–±–∞–≤–ª–µ–Ω
                    addBlock(x, y, z, blockType);
                }
            });
            console.log('‚úì –ò–∑–º–µ–Ω–µ–Ω–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω—ã:', Object.keys(worldChanges).length);
        }
        
        function saveSettings() {
            const volumeSlider = document.getElementById('mainVolume');
            const volume = volumeSlider ? parseInt(volumeSlider.value, 10) : 50;
            
            const settings = {
                renderDistance,
                mouseSensitivity: mouseSensitivity / 0.002 * 50,
                textureQuality,
                graphicsQuality,
                showFPS,
                smoothLighting,
                fancyClouds,
                particlesEnabled,
                flatBlocks,
                volume
            };
            localStorage.setItem('minecraftSettings', JSON.stringify(settings));
            // alert('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã! –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–≥—Ä—É (F2) –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è.');
        }
        
        function loadSettings() {
            const saved = localStorage.getItem('minecraftSettings');
            let settings = null;

            if (saved) {
                try {
                    settings = JSON.parse(saved);
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫:', error);
                }
            }

            if (settings) {
                const originalGraphics = settings.graphicsQuality;
                const knownGraphics = (typeof originalGraphics === 'string' && GRAPHICS_PRESETS[originalGraphics])
                    ? originalGraphics
                    : graphicsQuality;
                const graphicsChanged = originalGraphics !== undefined && knownGraphics !== originalGraphics;
                graphicsQuality = knownGraphics;

                const savedDistance = settings.renderDistance !== undefined ? settings.renderDistance : renderDistance;
                const clampedDistance = clampRenderDistance(savedDistance, graphicsQuality);
                const distanceChanged = settings.renderDistance !== undefined && clampedDistance !== settings.renderDistance;
                renderDistance = clampedDistance;

                fov = settings.fov !== undefined ? settings.fov : 75;
                if (camera) {
                    camera.fov = fov;
                    camera.updateProjectionMatrix();
                }

                const savedSensitivity = Number.isFinite(settings.mouseSensitivity) ? settings.mouseSensitivity : 50;
                mouseSensitivity = (savedSensitivity / 50) * 0.002;
                const knownTextureQuality = (typeof settings.textureQuality === 'string' && TEXTURE_LABELS[settings.textureQuality])
                    ? settings.textureQuality
                    : textureQuality;
                const textureChanged = settings.textureQuality !== undefined && knownTextureQuality !== settings.textureQuality;
                textureQuality = knownTextureQuality;
                showFPS = settings.showFPS !== undefined ? settings.showFPS : showFPS;
                smoothLighting = settings.smoothLighting !== undefined ? settings.smoothLighting : smoothLighting;
                fancyClouds = settings.fancyClouds !== undefined ? settings.fancyClouds : fancyClouds;
                particlesEnabled = settings.particlesEnabled !== undefined ? settings.particlesEnabled : particlesEnabled;
                flatBlocks = settings.flatBlocks !== undefined ? settings.flatBlocks : flatBlocks;
                fogEnabled = settings.fogEnabled !== undefined ? settings.fogEnabled : true;
                frustumCullingEnabled = settings.frustumCullingEnabled !== undefined ? settings.frustumCullingEnabled : true;
                
                const ssaoEnabled = settings.ssaoEnabled !== undefined ? settings.ssaoEnabled : false;
                if (ssaoPass) {
                    ssaoPass.enabled = ssaoEnabled;
                }
                const ssaoCheckbox = document.getElementById('mainSSAOEnabled');
                if (ssaoCheckbox) {
                    ssaoCheckbox.checked = ssaoEnabled;
                }
                const frustumCheckbox = document.getElementById('mainFrustumCulling');
                if (frustumCheckbox) {
                    frustumCheckbox.checked = frustumCullingEnabled;
                }

                if (settings.volume !== undefined) {
                    const vol = Math.max(0, Math.min(100, settings.volume));
                    soundManager.setVolume(vol / 100);
                    const volSlider = document.getElementById('mainVolume');
                    if (volSlider) {
                        volSlider.value = vol;
                        const volLabel = document.getElementById('mainVolumeValue');
                        if (volLabel) volLabel.textContent = vol;
                    }
                }

                if (settings.musicVolume !== undefined) {
                    const vol = Math.max(0, Math.min(100, settings.musicVolume));
                    soundManager.setMusicVolume(vol / 100);
                    const volSlider = document.getElementById('mainMusicVolume');
                    if (volSlider) {
                        volSlider.value = vol;
                        const volLabel = document.getElementById('mainMusicVolumeValue');
                        if (volLabel) volLabel.textContent = vol;
                    }
                }

                if (settings.effectsVolume !== undefined) {
                    const vol = Math.max(0, Math.min(100, settings.effectsVolume));
                    soundManager.setEffectsVolume(vol / 100);
                    const volSlider = document.getElementById('mainEffectsVolume');
                    if (volSlider) {
                        volSlider.value = vol;
                        const volLabel = document.getElementById('mainEffectsVolumeValue');
                        if (volLabel) volLabel.textContent = vol;
                    }
                }

                if (graphicsChanged || distanceChanged || textureChanged) {
                    settings.graphicsQuality = graphicsQuality;
                    settings.renderDistance = renderDistance;
                    settings.textureQuality = textureQuality;
                    try {
                        localStorage.setItem('minecraftSettings', JSON.stringify(settings));
                    } catch (storageError) {
                        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ localStorage:', storageError);
                    }
                }
            } else {
                renderDistance = clampRenderDistance(renderDistance, graphicsQuality);
            }

            applyRenderDistanceSetting(renderDistance, graphicsQuality);

            const sensitivitySlider = document.getElementById('sensitivity');
            if (sensitivitySlider) {
                const value = Math.round(mouseSensitivity / 0.002 * 50);
                sensitivitySlider.value = value;
                const label = document.getElementById('sensitivityValue');
                if (label) {
                    label.textContent = value;
                }
            }

            const graphicsSelect = document.getElementById('graphicsQualitySelect');
            if (graphicsSelect) {
                graphicsSelect.value = graphicsQuality;
                const labels = { low: '–ù–∏–∑–∫–∞—è', medium: '–°—Ä–µ–¥–Ω—è—è', high: '–í—ã—Å–æ–∫–∞—è', ultra: '–£–ª—å—Ç—Ä–∞' };
                const label = document.getElementById('graphicsQualityValue');
                if (label) {
                    label.textContent = labels[graphicsQuality];
                }
            }
            const mainGraphicsPreset = document.getElementById('mainGraphicsPreset');
            if (mainGraphicsPreset) {
                mainGraphicsPreset.value = graphicsQuality;
            }
            const mainGraphicsLabel = document.getElementById('mainGraphicsPresetValue');
            if (mainGraphicsLabel) {
                mainGraphicsLabel.textContent = GRAPHICS_LABELS[graphicsQuality] || GRAPHICS_LABELS.medium;
            }
            const mainTextureSelect = document.getElementById('mainTextureQuality');
            if (mainTextureSelect) {
                mainTextureSelect.value = textureQuality;
            }
            const mainTextureLabel = document.getElementById('mainTextureValue');
            if (mainTextureLabel) {
                mainTextureLabel.textContent = TEXTURE_LABELS[textureQuality] || TEXTURE_LABELS.medium;
            }
            const mainSensitivity = document.getElementById('mainSensitivity');
            if (mainSensitivity) {
                const value = Math.round(mouseSensitivity / 0.002 * 50);
                mainSensitivity.value = value;
                const label = document.getElementById('mainSensitivityValue');
                if (label) {
                    label.textContent = value;
                }
            }

            const showFPSCheckbox = document.getElementById('showFPS');
            if (showFPSCheckbox) {
                showFPSCheckbox.checked = showFPS;
            }
            const smoothLightingCheckbox = document.getElementById('smoothLighting');
            if (smoothLightingCheckbox) {
                smoothLightingCheckbox.checked = smoothLighting;
            }
            const fancyCloudsCheckbox = document.getElementById('fancyClouds');
            if (fancyCloudsCheckbox) {
                fancyCloudsCheckbox.checked = fancyClouds;
            }
            const particlesEnabledCheckbox = document.getElementById('particlesEnabled');
            if (particlesEnabledCheckbox) {
                particlesEnabledCheckbox.checked = particlesEnabled;
            }
            const mainShowFPS = document.getElementById('mainShowFPS');
            if (mainShowFPS) {
                mainShowFPS.checked = showFPS;
            }
            const mainFlatBlocks = document.getElementById('mainFlatBlocks');
            if (mainFlatBlocks) {
                mainFlatBlocks.checked = flatBlocks;
            }
            const mainFogEnabled = document.getElementById('mainFogEnabled');
            if (mainFogEnabled) {
                mainFogEnabled.checked = fogEnabled;
            }
            const fpsElement = document.getElementById('fps');
            if (fpsElement) {
                fpsElement.style.display = showFPS ? 'block' : 'none';
            }
            applyGraphicsPreset();
        }
        
        function openMainSettings() {
            const settings = document.getElementById('mainSettings');
            const menu = document.getElementById('menu');
            if (!settings || !menu) {
                return;
            }
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
            soundManager.play('ui_open');
            loadSettings();
            settings.classList.add('visible');
            menu.classList.add('hidden');
        }
        
        
        function closeMainSettings() {
            const settings = document.getElementById('mainSettings');
            const menu = document.getElementById('menu');
            if (settings) {
                settings.classList.remove('visible');
            }
            if (menu) {
                menu.classList.remove('hidden');
            }
            soundManager.play('ui_close');
        }
        
        function switchSettingsTab(tabName) {
            document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.settings-content').forEach(c => c.classList.remove('active'));
            
            const tab = document.querySelector(`.settings-tab[onclick="switchSettingsTab('${tabName}')"]`);
            const content = document.getElementById(`tab-${tabName}`);
            
            if (tab) tab.classList.add('active');
            if (content) content.classList.add('active');
            
            soundManager.play('ui_click');
        }

        function saveMainSettings() {
            const renderSlider = document.getElementById('mainRenderDistance');
            const sensitivitySlider = document.getElementById('mainSensitivity');
            const graphicsSelect = document.getElementById('mainGraphicsPreset');
            const textureSelect = document.getElementById('mainTextureQuality');
            const showFPSCheckbox = document.getElementById('mainShowFPS');
            const flatBlocksCheckbox = document.getElementById('mainFlatBlocks');
            const volumeSlider = document.getElementById('mainVolume');
            const musicVolumeSlider = document.getElementById('mainMusicVolume');
            const effectsVolumeSlider = document.getElementById('mainEffectsVolume');
            const fovSlider = document.getElementById('mainFov');
            const fogCheckbox = document.getElementById('mainFogEnabled');
            const ssaoCheckbox = document.getElementById('mainSSAOEnabled');
            const frustumCheckbox = document.getElementById('mainFrustumCulling');

            if (!renderSlider || !sensitivitySlider || !graphicsSelect || !textureSelect || !showFPSCheckbox || !flatBlocksCheckbox) {
                console.warn('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏: –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —ç–ª–µ–º–µ–Ω—Ç—ã —Ñ–æ—Ä–º—ã.');
                return;
            }

            const newRenderDistance = parseInt(renderSlider.value, 10);
            const newSensitivity = parseInt(sensitivitySlider.value, 10);
            const newGraphicsQuality = graphicsSelect.value;
            const newTextureQuality = textureSelect.value;
            const newVolume = volumeSlider ? parseInt(volumeSlider.value, 10) : 50;
            const newMusicVolume = musicVolumeSlider ? parseInt(musicVolumeSlider.value, 10) : 50;
            const newEffectsVolume = effectsVolumeSlider ? parseInt(effectsVolumeSlider.value, 10) : 50;
            const newFov = fovSlider ? parseInt(fovSlider.value, 10) : 75;

            const previousGraphicsQuality = graphicsQuality;
            const previousTextureQuality = textureQuality;

            graphicsQuality = newGraphicsQuality;
            fogEnabled = fogCheckbox ? fogCheckbox.checked : true;
            frustumCullingEnabled = frustumCheckbox ? frustumCheckbox.checked : true;
            const ssaoEnabled = ssaoCheckbox ? ssaoCheckbox.checked : false;
            if (ssaoPass) {
                ssaoPass.enabled = ssaoEnabled;
            }

            const distanceTarget = Number.isFinite(newRenderDistance) ? newRenderDistance : renderDistance;
            const clampedDistance = applyRenderDistanceSetting(distanceTarget, graphicsQuality);
            renderSlider.value = clampedDistance;
            mouseSensitivity = Number.isFinite(newSensitivity) ? (newSensitivity / 50) * 0.002 : mouseSensitivity;
            textureQuality = newTextureQuality;
            showFPS = showFPSCheckbox.checked;
            flatBlocks = flatBlocksCheckbox.checked;
            
            soundManager.setVolume(newVolume / 100);
            soundManager.setMusicVolume(newMusicVolume / 100);
            soundManager.setEffectsVolume(newEffectsVolume / 100);

            fov = newFov;
            if (camera) {
                camera.fov = fov;
                camera.updateProjectionMatrix();
            }

            const mainGraphicsLabel = document.getElementById('mainGraphicsPresetValue');
            if (mainGraphicsLabel) {
                mainGraphicsLabel.textContent = GRAPHICS_LABELS[graphicsQuality] || GRAPHICS_LABELS.medium;
            }
            const mainTextureLabel = document.getElementById('mainTextureValue');
            if (mainTextureLabel) {
                mainTextureLabel.textContent = TEXTURE_LABELS[textureQuality] || TEXTURE_LABELS.medium;
            }

            const fpsElement = document.getElementById('fps');
            if (fpsElement) {
                fpsElement.style.display = showFPS ? 'block' : 'none';
            }

            const settings = {
                renderDistance,
                mouseSensitivity: mouseSensitivity / 0.002 * 50,
                textureQuality,
                graphicsQuality,
                showFPS,
                flatBlocks,
                fogEnabled,
                ssaoEnabled,
                frustumCullingEnabled,
                volume: newVolume,
                musicVolume: newMusicVolume,
                effectsVolume: newEffectsVolume,
                fov: newFov
            };
            localStorage.setItem('minecraftSettings', JSON.stringify(settings));

            if (previousTextureQuality !== textureQuality) {
                initTextures();
            }

            if (previousGraphicsQuality !== graphicsQuality) {
                applyGraphicsPreset();
                refreshWorldMaterials();
            }

            alert('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã! –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Å—Ç—É–ø—è—Ç –≤ —Å–∏–ª—É —Å—Ä–∞–∑—É.');
        }

        function updatePlayer(delta) {
            eatCooldown = Math.max(0, eatCooldown - delta);
            if (isDead) {
                return;
            }
            if (inventoryOpen || isPaused) {
                updateHungerAndStarvation(delta, false);
                player.wasOnGround = player.onGround;
                return;
            }
            
            // DEBUG: –ª–æ–≥–∏—Ä—É–µ–º –ø–µ—Ä–≤—ã–µ 3 –≤—ã–∑–æ–≤–∞
            if (frameCount < 3) {
                console.log(`updatePlayer –≤—ã–∑–≤–∞–Ω, frame ${frameCount}, pointerLocked=${pointerLocked}, gameStarted=${gameStarted}`);
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–∏—Ä –¥–∞–∂–µ –µ—Å–ª–∏ –∫—É—Ä—Å–æ—Ä –Ω–µ –∑–∞—Ö–≤–∞—á–µ–Ω
            // –û–±–Ω–æ–≤–ª—è–µ–º —á–∞–Ω–∫–∏
            updateChunks();
            updateChunkVisibility();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º LOD –∫–∞–∂–¥—ã–π –∫–∞–¥—Ä –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏ –ø—Ä–∏ –ø–æ–≤–æ—Ä–æ—Ç–µ –∫–∞–º–µ—Ä—ã
            // –†–∞–Ω–µ–µ –±—ã–ª–æ —Ä–∞–∑ –≤ 1 —Å–µ–∫, —á—Ç–æ –≤—ã–∑—ã–≤–∞–ª–æ –∑–∞–¥–µ—Ä–∂–∫–∏ –ø–æ—è–≤–ª–µ–Ω–∏—è —á–∞–Ω–∫–æ–≤
            updateAllChunksLOD();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è —Å—É—Ç–æ–∫
            updateDayNightCycle(delta);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –æ–±–ª–∞–∫–∞
            updateClouds(delta);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∑–æ–º–±–∏
            updateZombies(delta);
            updatePassiveAnimals(delta);
            
            // –°–ø–∞–≤–Ω –∑–æ–º–±–∏ –Ω–æ—á—å—é
            const isNight = timeOfDay > 19000 || timeOfDay < 5000;
            if (isNight && zombies.length < 5 && Math.random() < 0.001) {
                // –°–ø–∞–≤–Ω–∏–º –∑–æ–º–±–∏ —Ä—è–¥–æ–º —Å –∏–≥—Ä–æ–∫–æ–º –Ω–æ –Ω–µ —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ
                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 20;
                const x = player.position.x + Math.cos(angle) * distance;
                const z = player.position.z + Math.sin(angle) * distance;
                const y = 65; // –í—ã—Å–æ—Ç–∞ —Å–ø–∞–≤–Ω–∞
                spawnZombie(x, y, z);
            }

            if (!isNight && passiveAnimals.length < MAX_PASSIVE_ANIMALS && Math.random() < PASSIVE_SPAWN_CHANCE) {
                spawnPigNearPlayer();
            }

            const wasOnGround = player.wasOnGround;
            
            // –ï—Å–ª–∏ –∫—É—Ä—Å–æ—Ä –Ω–µ –∑–∞—Ö–≤–∞—á–µ–Ω, –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
            if (!pointerLocked) {
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É –µ—Å–ª–∏ –∏–≥—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞
                const clickHint = document.getElementById('clickHint');
                if (clickHint && gameStarted && !isPaused && !inventoryOpen && !isDead) {
                    clickHint.style.display = 'block';
                }
                updateHungerAndStarvation(delta, false);
                player.wasOnGround = player.onGround;
                if (player.onGround) {
                    player.fallStartY = null;
                }
                return;
            }
            
            // –°–∫—Ä—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É –∫–æ–≥–¥–∞ –∫—É—Ä—Å–æ—Ä –∑–∞—Ö–≤–∞—á–µ–Ω
            const clickHint = document.getElementById('clickHint');
            if (clickHint) clickHint.style.display = 'none';
            
            // DEBUG: –ª–æ–≥–∏—Ä—É–µ–º –∫–æ–≥–¥–∞ –∫—É—Ä—Å–æ—Ä –∑–∞—Ö–≤–∞—á–µ–Ω
            if (frameCount === 1) {
                console.log('‚úì –ö—É—Ä—Å–æ—Ä –∑–∞—Ö–≤–∞—á–µ–Ω, —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ');
            }
            
            if (rightMouseHeld && !inventoryOpen && !isPaused) {
                consumeSelectedFood();
            }

            // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å —Ä–∞–∑—Ä—É—à–µ–Ω–∏—è –±–ª–æ–∫–∞
            updateBreaking(delta);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —á–∞—Å—Ç–∏—Ü—ã
            updateParticles(delta);

            const prevX = player.position.x;
            const prevZ = player.position.z;
            
            const baseSpeed = 4.3;
            const jumpPower = 8;
            const gravity = -20;
            const waterGravity = -5;
            const swimAcceleration = 10;
            const swimDrag = 0.85;
            const sprintMultiplier = 1.5;
            let speed = baseSpeed;
            let sprinting = false;

            // –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã (–∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é mouseSensitivity)
            player.rotation.y -= mouse.x * mouseSensitivity;
            player.rotation.x -= mouse.y * mouseSensitivity;
            player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));
            mouse.x = 0;
            mouse.y = 0;

            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è (–ò–°–ü–†–ê–í–õ–ï–ù–û!)
            const forward = new THREE.Vector3(
                -Math.sin(player.rotation.y),
                0,
                -Math.cos(player.rotation.y)
            );
            const right = new THREE.Vector3(
                -Math.sin(player.rotation.y - Math.PI / 2),
                0,
                -Math.cos(player.rotation.y - Math.PI / 2)
            );
            forward.normalize();
            right.normalize();

            const headLevel = player.position.y - COLLISION_EPSILON;
            const torsoLevel = player.position.y - PLAYER_HEIGHT * 0.5;
            const feetLevel = player.position.y - PLAYER_HEIGHT + 0.1;
            const inWater = isWaterBlock(player.position.x, torsoLevel, player.position.z) ||
                            isWaterBlock(player.position.x, feetLevel, player.position.z);
            const headUnderWater = isWaterBlock(player.position.x, headLevel, player.position.z);

            player.inWater = inWater;
            applyUnderwaterEffects(inWater, headUnderWater);
            if (inWater) {
                speed *= headUnderWater ? 0.5 : 0.65;
                player.onGround = false;
            } else {
                if (controls['control'] && !inventoryOpen && !isPaused) {
                    speed *= sprintMultiplier;
                    sprinting = true;
                }
                if (controls['shift'] && !inventoryOpen && !isPaused) {
                    speed *= 0.55;
                }
            }

            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
            let moveX = 0, moveZ = 0;
            if (controls['w'] || controls['—Ü']) {
                moveX += forward.x * speed * delta;
                moveZ += forward.z * speed * delta;
            }
            if (controls['s'] || controls['—ã']) {
                moveX -= forward.x * speed * delta;
                moveZ -= forward.z * speed * delta;
            }
            if (controls['a'] || controls['—Ñ']) {
                moveX -= right.x * speed * delta;
                moveZ -= right.z * speed * delta;
            }
            if (controls['d'] || controls['–≤']) {
                moveX += right.x * speed * delta;
                moveZ += right.z * speed * delta;
            }

            const tryStepUp = (targetX, targetZ) => {
                const stepY = player.position.y + PLAYER_STEP_HEIGHT;
                if (!checkCollision(targetX, stepY, targetZ)) {
                    player.position.y = stepY;
                    player.velocity.y = 0;
                    player.onGround = true;
                    return true;
                }
                return false;
            };

            // –û—Å—å X
            if (Math.abs(moveX) > 0) {
                const targetX = player.position.x + moveX;
                if (!checkCollision(targetX, player.position.y, player.position.z)) {
                    player.position.x = targetX;
                } else {
                    tryStepUp(targetX, player.position.z);
                }
            }

            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ —É—Å–∫–æ—Ä–µ–Ω–∏–µ
            if (inWater) {
                if (controls[' ']) {
                    player.velocity.y += swimAcceleration * delta;
                } else if (controls['shift'] && headUnderWater) {
                    player.velocity.y -= swimAcceleration * delta;
                } else {
                    player.velocity.y *= swimDrag;
                }
                player.velocity.y += waterGravity * delta;
                player.velocity.y = Math.max(Math.min(player.velocity.y, 4), -4);
            } else {
                player.velocity.y += gravity * delta;
                if (controls[' '] && player.onGround) {
                    player.velocity.y = jumpPower;
                    player.onGround = false;
                    // soundManager.play('player_jump'); // –ó–≤—É–∫ –ø—Ä—ã–∂–∫–∞ —É–±—Ä–∞–Ω
                }
            }

            // –û—Å—å Y
            let dy = player.velocity.y * delta;
            
            // –ê–Ω—Ç–∏-–¥—Ä–æ–∂–∞–Ω–∏–µ: –µ—Å–ª–∏ –º—ã –Ω–∞ –∑–µ–º–ª–µ –∏ –ø—ã—Ç–∞–µ–º—Å—è –ø–∞–¥–∞—Ç—å –≤–Ω–∏–∑
            if (player.onGround && dy < 0 && !inWater) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∑–µ–º–ª—è —á—É—Ç—å –Ω–∏–∂–µ –Ω–∞—Å (–≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –Ω–µ–±–æ–ª—å—à–æ–≥–æ —à–∞–≥–∞)
                // –ï—Å–ª–∏ –µ—Å—Ç—å, —Ç–æ –º—ã –Ω–µ –ø–∞–¥–∞–µ–º, –∞ –ø—Ä–∏–ª–∏–ø–∞–µ–º –∫ –∑–µ–º–ª–µ
                if (checkCollision(player.position.x, player.position.y - 0.1, player.position.z)) {
                    dy = 0;
                    player.velocity.y = 0;
                    // –ù–µ –º–µ–Ω—è–µ–º –ø–æ–∑–∏—Ü–∏—é –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Å–∫–∞—á–∫–æ–≤
                }
            }

            if (dy !== 0) {
                player.position.y += dy;
                if (checkCollision(player.position.x, player.position.y, player.position.z)) {
                    if (dy > 0) {
                        // –£–¥–∞—Ä –≥–æ–ª–æ–≤–æ–π
                        const headBlockY = Math.round(player.position.y);
                        // –û—Ç—Ç–∞–ª–∫–∏–≤–∞–µ–º —á—É—Ç—å —Å–∏–ª—å–Ω–µ–µ, —á—Ç–æ–±—ã –Ω–µ –∑–∞—Å—Ç—Ä—è—Ç—å
                        player.position.y = headBlockY - 0.5 - COLLISION_EPSILON - 0.01;
                        player.velocity.y = 0;
                    } else {
                        // –ü—Ä–∏–∑–µ–º–ª–µ–Ω–∏–µ
                        const groundY = Math.round(player.position.y - PLAYER_HEIGHT);
                        player.position.y = groundY + 0.5 + PLAYER_HEIGHT + COLLISION_EPSILON;
                        player.onGround = true;
                        player.velocity.y = 0;
                    }
                } else {
                    player.onGround = false;
                }
            }

            // –û—Å—å Z
            if (Math.abs(moveZ) > 0) {
                const targetZ = player.position.z + moveZ;
                if (!checkCollision(player.position.x, player.position.y, targetZ)) {
                    player.position.z = targetZ;
                } else {
                    tryStepUp(player.position.x, targetZ);
                }
            }

            const horizontalMoved = Math.hypot(player.position.x - prevX, player.position.z - prevZ);

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏ —Ä—É–∫–∏
            const isMoving = horizontalMoved > 0.001 || (Math.abs(moveX) > 0 || Math.abs(moveZ) > 0);
            playerHand.update(delta, isMoving);

            // –ß–∞—Å—Ç–∏—Ü—ã –ø—Ä–∏ —Ö–æ–¥—å–±–µ
            if (player.onGround && horizontalMoved > 0.05 && particlesEnabled) {
                // –°–ø–∞–≤–Ω–∏–º —á–∞—Å—Ç–∏—Ü—ã —Ä–µ–∂–µ, —á–µ–º –∫–∞–∂–¥—ã–π –∫–∞–¥—Ä
                if (Math.random() < 0.2) {
                    const blockBelow = getBlock(player.position.x, player.position.y - PLAYER_HEIGHT - 0.1, player.position.z);
                    if (blockBelow && blockBelow.userData && blockBelow.userData.type) {
                        spawnBlockParticles(player.position.x, player.position.y - PLAYER_HEIGHT + 0.1, player.position.z, blockBelow.userData.type, 1);
                    }
                }
            }
            
            // –ß–∞—Å—Ç–∏—Ü—ã –ø—Ä–∏ –ø–ª–∞–≤–∞–Ω–∏–∏
            if (inWater && (horizontalMoved > 0.02 || Math.abs(player.velocity.y) > 0.1) && particlesEnabled) {
                if (Math.random() < 0.15) {
                     // –ü—É–∑—ã—Ä—å–∫–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ–º –≤–æ–¥—É –∫–∞–∫ —Ç–µ–∫—Å—Ç—É—Ä—É)
                     spawnBlockParticles(player.position.x, player.position.y + 0.5, player.position.z, 'water', 1);
                }
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–µ–º–ª–∏ –ø–æ—Å–ª–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —á—É—Ç—å –±–æ–ª—å—à–∏–π –æ—Ç—Å—Ç—É–ø (0.05), —á—Ç–æ–±—ã –Ω–∞–¥–µ–∂–Ω–æ –¥–æ—Å—Ç–∞—Ç—å –¥–æ –±–ª–æ–∫–∞ –ø–æ–¥ –Ω–æ–≥–∞–º–∏,
            // –¥–∞–∂–µ –µ—Å–ª–∏ –º—ã —Å—Ç–æ–∏–º –Ω–∞ COLLISION_EPSILON (0.01) –≤—ã—à–µ
            const feetY = player.position.y - PLAYER_HEIGHT - 0.05;
            if (isSolidBlock(player.position.x, feetY, player.position.z) ||
                isSolidBlock(player.position.x + PLAYER_HALF_WIDTH, feetY, player.position.z) ||
                isSolidBlock(player.position.x - PLAYER_HALF_WIDTH, feetY, player.position.z) ||
                isSolidBlock(player.position.x, feetY, player.position.z + PLAYER_HALF_WIDTH) ||
                isSolidBlock(player.position.x, feetY, player.position.z - PLAYER_HALF_WIDTH)) {
                
                // –ß–∞—Å—Ç–∏—Ü—ã –ø—Ä–∏ –ø—Ä–∏–∑–µ–º–ª–µ–Ω–∏–∏
                if (!wasOnGround && player.velocity.y < -2 && particlesEnabled) {
                     const blockBelow = getBlock(player.position.x, feetY, player.position.z);
                     if (blockBelow && blockBelow.userData && blockBelow.userData.type) {
                        spawnBlockParticles(player.position.x, player.position.y - PLAYER_HEIGHT + 0.1, player.position.z, blockBelow.userData.type, 10);
                     }
                }
                
                player.onGround = true;
                player.fallStartY = null;
            }

            if (player.inWater) {
                player.fallStartY = null;
            } else {
                if (wasOnGround && !player.onGround) {
                    player.fallStartY = player.position.y;
                }
                if (!player.onGround) {
                    if (player.fallStartY === null) {
                        player.fallStartY = player.position.y;
                    } else {
                        player.fallStartY = Math.max(player.fallStartY, player.position.y);
                    }
                } else if (!wasOnGround && player.onGround && player.fallStartY !== null) {
                    const fallDistance = player.fallStartY - player.position.y;
                    if (fallDistance > 0) {
                        handleFallDamage(fallDistance);
                    }
                    player.fallStartY = null;
                } else if (player.onGround) {
                    player.fallStartY = null;
                }
            }

            if (player.onGround && !player.inWater) {
                stepAccumulator += horizontalMoved;
                let stride = STEP_DISTANCE_DEFAULT;
                if (controls['control'] && !inventoryOpen && !isPaused) {
                    stride = STEP_DISTANCE_SPRINT;
                } else if (controls['shift'] && !inventoryOpen && !isPaused) {
                    stride = STEP_DISTANCE_SNEAK;
                }
                if (horizontalMoved > 0.02 && stepAccumulator >= stride) {
                    stepAccumulator = 0;
                    const surface = getSurfaceMaterialUnderPlayer();
                    soundManager.play('footstep', { material: surface });
                }
            } else {
                stepAccumulator = 0;
            }

            const sprintingActive = sprinting && horizontalMoved > 0.02 && player.onGround && !player.inWater;
            updateHungerAndStarvation(delta, sprintingActive);

            // –ù–µ –ø–∞–¥–∞–µ–º –Ω–∏–∂–µ y=1 - —Ä–µ—Å–ø–∞–≤–Ω
            if (player.position.y < 1) {
                // –ù–∞—Ö–æ–¥–∏–º –±–µ–∑–æ–ø–∞—Å–Ω—É—é –≤—ã—Å–æ—Ç—É
                let safeY = 10;
                for (let y = 30; y >= 0; y--) {
                    if (isSolidBlock(player.position.x, y, player.position.z)) {
                        safeY = y;
                        break;
                    }
                }
                player.position.y = safeY + 0.5 + PLAYER_HEIGHT;
                player.velocity.y = 0;
                console.log('‚ò† –ò–≥—Ä–æ–∫ —É–ø–∞–ª! –†–µ—Å–ø–∞–≤–Ω –Ω–∞ Y=' + player.position.y);
            }

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            camera.position.copy(player.position);
            // –ì–ª–∞–∑–∞ –Ω–∞—Ö–æ–¥—è—Ç—Å—è —á—É—Ç—å –Ω–∏–∂–µ –º–∞–∫—É—à–∫–∏ (1.62–º –æ—Ç –∑–µ–º–ª–∏ –ø—Ä–∏ —Ä–æ—Å—Ç–µ 1.8–º)
            camera.position.y -= 0.18; 

            if (!player.inWater && controls['shift'] && !controls['control']) {
                camera.position.y -= 0.25;
            }
            camera.rotation.set(player.rotation.x, player.rotation.y, 0, 'YXZ');
            player.wasOnGround = player.onGround;
        }
        
        function checkCollision(x, y, z) {
            // AABB —Ö–∏—Ç–±–æ–∫—Å –∏–≥—Ä–æ–∫–∞: –ø–æ–∑–∏—Ü–∏—è —Ö—Ä–∞–Ω–∏—Ç –≤–µ—Ä—Ö–Ω—é—é —Ç–æ—á–∫—É —Ö–∏—Ç–±–æ–∫—Å–∞
            // –ù–µ–º–Ω–æ–≥–æ —Å—É–∂–∞–µ–º —Ö–∏—Ç–±–æ–∫—Å –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏ –¥–ª—è –ø—Ä–æ—Ö–æ–¥–∞ –≤ —É–∑–∫–∏–µ –º–µ—Å—Ç–∞
            const width = PLAYER_WIDTH * 0.9;
            const halfWidth = width / 2;
            
            const minX = x - halfWidth + COLLISION_EPSILON;
            const maxX = x + halfWidth - COLLISION_EPSILON;
            const minZ = z - halfWidth + COLLISION_EPSILON;
            const maxZ = z + halfWidth - COLLISION_EPSILON;
            const minY = y - PLAYER_HEIGHT + COLLISION_EPSILON;
            const maxY = y - COLLISION_EPSILON;
            return intersectsSolidBlocks(minX, maxX, minY, maxY, minZ, maxZ);
        }

        function intersectsSolidBlocks(minX, maxX, minY, maxY, minZ, maxZ) {
            if (minX > maxX || minY > maxY || minZ > maxZ) return false;
            
            const minBlockX = Math.round(minX);
            const maxBlockX = Math.round(maxX);
            const minBlockY = Math.round(minY);
            const maxBlockY = Math.round(maxY);
            const minBlockZ = Math.round(minZ);
            const maxBlockZ = Math.round(maxZ);
            
            for (let bx = minBlockX; bx <= maxBlockX; bx++) {
                for (let by = minBlockY; by <= maxBlockY; by++) {
                    if (by < -64 || by > 256) continue;
                    for (let bz = minBlockZ; bz <= maxBlockZ; bz++) {
                        const block = getBlock(bx, by, bz);
                        if (block && block.userData && block.userData.solid) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function updateDayNightCycle(delta) {
            // –£—Å–∫–æ—Ä–µ–Ω–Ω—ã–π —Ü–∏–∫–ª: 1 –∏–≥—Ä–æ–≤–æ–π –¥–µ–Ω—å = 10 –º–∏–Ω—É—Ç (5 –º–∏–Ω –¥–µ–Ω—å + 5 –º–∏–Ω –Ω–æ—á—å)
            timeOfDay += delta * 40; // 24000 / (10 * 60) = 40
            if (timeOfDay >= 24000) timeOfDay = 0;

            const preset = activeGraphicsPreset || GRAPHICS_PRESETS[graphicsQuality] || GRAPHICS_PRESETS.medium;
            const colors = activeSkyColors;

            // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Ä–∞—Å—á–µ—Ç —É–≥–ª–∞: 6000 = –ü–æ–ª–¥–µ–Ω—å (–ó–µ–Ω–∏—Ç), 18000 = –ü–æ–ª–Ω–æ—á—å (–ù–∞–¥–∏—Ä)
            // –°–º–µ—â–∞–µ–º —Ñ–∞–∑—É –Ω–∞ -PI/2, —á—Ç–æ–±—ã 0 –±—ã–ª–æ –≤–æ—Å—Ö–æ–¥–æ–º, –∞ 6000 - –∑–µ–Ω–∏—Ç–æ–º
            const angle = ((timeOfDay - 6000) / 24000) * Math.PI * 2;
            const dist = 400;

            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Å–æ–ª–Ω—Ü–∞ –∏ –ª—É–Ω—ã –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∏–≥—Ä–æ–∫–∞
            // –í–ê–ñ–ù–û: –ò—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞ (sunLight/moonLight) –¥–æ–ª–∂–Ω—ã –¥–≤–∏–≥–∞—Ç—å—Å—è –≤–º–µ—Å—Ç–µ —Å –∏–≥—Ä–æ–∫–æ–º,
            // —á—Ç–æ–±—ã —Ç–µ–Ω–∏ –≤—Å–µ–≥–¥–∞ –±—ã–ª–∏ —á–µ—Ç–∫–∏–º–∏ –≤–æ–∫—Ä—É–≥ –Ω–µ–≥–æ (Shadow Map —Å–ª–µ–¥—É–µ—Ç –∑–∞ –∫–∞–º–µ—Ä–æ–π)
            
            // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å–æ–ª–Ω—Ü–∞ –Ω–∞ –Ω–µ–±–µ—Å–Ω–æ–π —Å—Ñ–µ—Ä–µ
            // Y - –≤—ã—Å–æ—Ç–∞ (sin), X - –≤–æ—Å—Ç–æ–∫/–∑–∞–ø–∞–¥ (cos)
            // –ü—Ä–∏ angle=0 (–ü–æ–ª–¥–µ–Ω—å): sin=0, cos=1. –°—Ç–æ–ø, –Ω–∞–º –Ω—É–∂–Ω–æ Y=1.
            // –ó–Ω–∞—á–∏—Ç: Y = cos(angle), X = sin(angle).
            // –ü—Ä–æ–≤–µ—Ä–∫–∞:
            // –ü–æ–ª–¥–µ–Ω—å (6000) -> angle=0 -> Y=1 (–ó–µ–Ω–∏—Ç), X=0. –û–ö.
            // –ó–∞–∫–∞—Ç (12000) -> angle=PI/2 -> Y=0 (–ì–æ—Ä–∏–∑–æ–Ω—Ç), X=1 (–ó–∞–ø–∞–¥). –û–ö.
            // –ü–æ–ª–Ω–æ—á—å (18000) -> angle=PI -> Y=-1 (–ù–∞–¥–∏—Ä), X=0. –û–ö.
            // –í–æ—Å—Ö–æ–¥ (0/24000) -> angle=-PI/2 -> Y=0 (–ì–æ—Ä–∏–∑–æ–Ω—Ç), X=-1 (–í–æ—Å—Ç–æ–∫). –û–ö.
            
            const sunY = Math.cos(angle) * 100;
            const sunX = Math.sin(angle) * 100;
            const sunZ = 0; // –£–±—Ä–∞–ª–∏ —Å–º–µ—â–µ–Ω–∏–µ –ø–æ Z, —á—Ç–æ–±—ã —Å–æ–ª–Ω—Ü–µ —à–ª–æ —Ä–æ–≤–Ω–æ –ø–æ —Ü–µ–Ω—Ç—Ä—É

            if (sunLight) {
                // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫ —Å–≤–µ—Ç–∞
                // –ï—Å–ª–∏ —Å–æ–ª–Ω—Ü–µ –Ω–∞ –í–æ—Å—Ç–æ–∫–µ (X=-100), —Å–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –∏–¥—Ç–∏ –û–¢–¢–£–î–ê.
                // –ó–Ω–∞—á–∏—Ç –ø–æ–∑–∏—Ü–∏—è –∏—Å—Ç–æ—á–Ω–∏–∫–∞ = –ò–≥—Ä–æ–∫ + –í–µ–∫—Ç–æ—Ä–°–æ–ª–Ω—Ü–∞
                sunLight.position.set(
                    player.position.x + sunX,
                    player.position.y + sunY,
                    player.position.z + sunZ
                );
                // –¶–µ–ª—å —Å–≤–µ—Ç–∞ - –≤—Å–µ–≥–¥–∞ –∏–≥—Ä–æ–∫
                sunLight.target.position.copy(player.position);
                sunLight.target.updateMatrixWorld();
            }
            
            if (moonLight) {
                // –õ—É–Ω–∞ –Ω–∞–ø—Ä–æ—Ç–∏–≤ —Å–æ–ª–Ω—Ü–∞
                moonLight.position.set(
                    player.position.x - sunX,
                    player.position.y - sunY,
                    player.position.z - sunZ
                );
                moonLight.target.position.copy(player.position);
                moonLight.target.updateMatrixWorld();
            }

            // –í–∏–∑—É–∞–ª—å–Ω—ã–µ –º–µ—à–∏ —Å–æ–ª–Ω—Ü–∞ –∏ –ª—É–Ω—ã (–æ–Ω–∏ –ø—Ä–æ—Å—Ç–æ –≤–∏—Å—è—Ç –≤ –Ω–µ–±–µ –¥–∞–ª–µ–∫–æ)
            if (sunMesh) {
                // –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –º–µ—à–∞, —á—Ç–æ–±—ã —Å–æ–≤–ø–∞–¥–∞–ª–∞ —Å —Ä–∞—Å—á–µ—Ç–æ–º —Å–≤–µ—Ç–∞
                sunMesh.position.set(
                    player.position.x + sunX * (dist/100),
                    player.position.y + sunY * (dist/100),
                    player.position.z
                );
                sunMesh.lookAt(player.position);
            }

            if (moonMesh) {
                moonMesh.position.set(
                    player.position.x - sunX * (dist/100),
                    player.position.y - sunY * (dist/100),
                    player.position.z
                );
                moonMesh.lookAt(player.position);
            }

            // –õ–æ–≥–∏–∫–∞ —Å–º–µ–Ω—ã –¥–Ω—è –∏ –Ω–æ—á–∏ (0 - –í–æ—Å—Ö–æ–¥, 6000 - –ü–æ–ª–¥–µ–Ω—å, 12000 - –ó–∞–∫–∞—Ç)
            const isDay = timeOfDay > 0 && timeOfDay < 12000;
            
            // –Ø—Ä–∫–æ—Å—Ç—å —Å–æ–ª–Ω—Ü–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –≤—ã—Å–æ—Ç—ã (sunY)
            // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤—ã—Å–æ—Ç—É –æ—Ç 0 –¥–æ 1
            const sunHeight = Math.max(0, sunY / 100); 
            
            if (sunLight) {
                sunLight.visible = sunHeight > 0;
                sunLight.intensity = sunHeight * preset.sunIntensity;
            }

            if (moonLight) {
                const moonHeight = Math.max(0, -sunY / 100);
                moonLight.visible = moonHeight > 0;
                moonLight.intensity = moonHeight * preset.moonIntensity;
            }

            if (ambientLight) {
                // Ambient –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫
                const base = preset.ambientIntensity;
                // –î–Ω–µ–º —Å–≤–µ—Ç–ª–µ–µ, –Ω–æ—á—å—é —Ç–µ–º–Ω–µ–µ
                const dayFactor = Math.max(0, Math.min(1, (sunY + 50) / 100)); // –ü–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥
                ambientLight.intensity = base * (0.2 + 0.8 * dayFactor);
            }

            if (hemisphereLight) {
                const dayFactor = Math.max(0, Math.min(1, (sunY + 50) / 100));
                hemisphereLight.intensity = preset.hemisphereIntensity * (0.2 + 0.8 * dayFactor);
            }

            if (colors && scene?.fog) {
                // –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è —Ü–≤–µ—Ç–æ–≤ –Ω–µ–±–∞
                // 0 (24000) - –í–æ—Å—Ö–æ–¥
                // 6000 - –î–µ–Ω—å
                // 12000 - –ó–∞–∫–∞—Ç
                // 18000 - –ù–æ—á—å
                
                if (timeOfDay >= 22000 || timeOfDay < 2000) {
                    // –ù–æ—á—å -> –í–æ—Å—Ö–æ–¥ (22000..24000..2000)
                    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É 0..1
                    let t;
                    if (timeOfDay >= 22000) t = (timeOfDay - 22000) / 4000; // 0..0.5
                    else t = (timeOfDay + 2000) / 4000; // 0.5..1
                    
                    // –ù–æ—á—å -> –†–∞—Å—Å–≤–µ—Ç -> –î–µ–Ω—å
                    // –£–ø—Ä–æ—Å—Ç–∏–º: –ù–æ—á—å -> –†–∞—Å—Å–≤–µ—Ç
                    if (timeOfDay >= 22000) {
                         const localT = (timeOfDay - 22000) / 2000; // 0..1
                         tempSkyColor.copy(colors.night).lerp(colors.dawn, localT);
                         tempZenithColor.copy(ZENITH_COLORS.night).lerp(ZENITH_COLORS.dawn, localT);
                    } else {
                         const localT = timeOfDay / 2000; // 0..1
                         tempSkyColor.copy(colors.dawn).lerp(colors.day, localT);
                         tempZenithColor.copy(ZENITH_COLORS.dawn).lerp(ZENITH_COLORS.day, localT);
                    }
                } else if (timeOfDay >= 2000 && timeOfDay < 10000) {
                    // –î–µ–Ω—å (—Å–≤–µ—Ç–ª–æ)
                    tempSkyColor.copy(colors.day);
                    if (timeOfDay > 4000 && timeOfDay < 8000) {
                        // –ü–æ–ª–¥–µ–Ω—å - —á—É—Ç—å —è—Ä—á–µ/–≥–æ–ª—É–±–µ–µ
                        const t = 1 - Math.abs(timeOfDay - 6000) / 2000; // 0..1..0
                        tempSkyColor.lerp(colors.noon, t);
                        tempZenithColor.copy(ZENITH_COLORS.day).lerp(ZENITH_COLORS.noon, t);
                    } else {
                        tempZenithColor.copy(ZENITH_COLORS.day);
                    }
                } else if (timeOfDay >= 10000 && timeOfDay < 14000) {
                    // –î–µ–Ω—å -> –ó–∞–∫–∞—Ç -> –ù–æ—á—å
                    if (timeOfDay < 12000) {
                        const t = (timeOfDay - 10000) / 2000;
                        tempSkyColor.copy(colors.day).lerp(colors.dusk, t);
                        tempZenithColor.copy(ZENITH_COLORS.day).lerp(ZENITH_COLORS.dusk, t);
                    } else {
                        const t = (timeOfDay - 12000) / 2000;
                        tempSkyColor.copy(colors.dusk).lerp(colors.night, t);
                        tempZenithColor.copy(ZENITH_COLORS.dusk).lerp(ZENITH_COLORS.night, t);
                    }
                } else {
                    // –ù–æ—á—å
                    tempSkyColor.copy(colors.night);
                    tempZenithColor.copy(ZENITH_COLORS.night);
                }
                
                scene.background.copy(tempSkyColor);
                scene.fog.color.copy(tempSkyColor);

                if (skyUniforms) {
                    skyUniforms.bottomColor.value.copy(tempSkyColor);
                    skyUniforms.topColor.value.copy(tempZenithColor);
                }
                if (skyMesh) {
                    skyMesh.position.copy(player.position);
                }
            }
        }

        function applyUnderwaterEffects(inWater, headUnderWater) {
            const preset = activeGraphicsPreset || GRAPHICS_PRESETS[graphicsQuality] || GRAPHICS_PRESETS.medium;

            // Fog and background tint
            if (scene?.fog) {
                if (headUnderWater) {
                    scene.fog.near = UNDERWATER_FOG_NEAR;
                    scene.fog.far = UNDERWATER_FOG_FAR;
                    scene.fog.color.setHex(UNDERWATER_FOG_COLOR);
                    if (scene.background) {
                        scene.background.setHex(UNDERWATER_FOG_COLOR);
                    }
                } else {
                    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç—É–º–∞–Ω –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–ª—å–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ä–∏—Å–æ–≤–∫–∏
                    const viewDistance = renderDistance * CHUNK_SIZE;
                    scene.fog.near = viewDistance * 0.25;
                    scene.fog.far = viewDistance * 0.8;
                }
            }

            // Screen overlay intensity
            if (waterOverlay) {
                const target = headUnderWater ? 0.55 : 0;
                waterOverlay.style.opacity = target;
            }

            if (waterSurfaceMaterial) {
                const desiredOpacity = headUnderWater ? Math.min(preset.waterOpacity, 0.16) : preset.waterOpacity;
                if (waterSurfaceMaterial.opacity !== desiredOpacity) {
                    waterSurfaceMaterial.opacity = desiredOpacity;
                    waterSurfaceMaterial.needsUpdate = true;
                }
            }
        }
        
        function updateClouds(delta) {
            if (!clouds.length) {
                return;
            }
            const preset = activeGraphicsPreset || GRAPHICS_PRESETS[graphicsQuality] || GRAPHICS_PRESETS.medium;
            if (!preset.fancyClouds) {
                clouds.forEach((cloud) => {
                    cloud.visible = false;
                });
                return;
            }
            
            const speedMultiplier = preset.cloudSpeedMultiplier ?? 1;
            const playerPos = player.position;
            const renderDist = 300; // –î–∏—Å—Ç–∞–Ω—Ü–∏—è —Ä–µ—Å–ø–∞–≤–Ω–∞ –æ–±–ª–∞–∫–æ–≤
            
            clouds.forEach((cloud) => {
                cloud.visible = true;
                
                // –î–≤–∏–∂–µ–Ω–∏–µ
                cloud.position.x += cloud.userData.speed * speedMultiplier * delta;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Ö–æ–¥–∞ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –≤–æ–∫—Ä—É–≥ –∏–≥—Ä–æ–∫–∞ (–±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–µ –æ–±–ª–∞–∫–∞)
                let respawned = false;
                
                // –ü–æ –æ—Å–∏ X
                if (cloud.position.x - playerPos.x > renderDist) {
                    cloud.position.x -= renderDist * 2;
                    respawned = true;
                } else if (cloud.position.x - playerPos.x < -renderDist) {
                    cloud.position.x += renderDist * 2;
                    respawned = true;
                }
                
                // –ü–æ –æ—Å–∏ Z
                if (cloud.position.z - playerPos.z > renderDist) {
                    cloud.position.z -= renderDist * 2;
                    respawned = true;
                } else if (cloud.position.z - playerPos.z < -renderDist) {
                    cloud.position.z += renderDist * 2;
                    respawned = true;
                }
                
                // –ï—Å–ª–∏ –æ–±–ª–∞–∫–æ –ø–µ—Ä–µ–º–µ—Å—Ç–∏–ª–æ—Å—å, –º–æ–∂–Ω–æ –Ω–µ–º–Ω–æ–≥–æ —Ä–∞–Ω–¥–æ–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –µ–≥–æ –ø–æ–∑–∏—Ü–∏—é –ø–æ –¥—Ä—É–≥–æ–π –æ—Å–∏,
                // —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –≤–∏–¥–Ω–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π –ø–∞—Ç—Ç–µ—Ä–Ω–∞, –Ω–æ –∞–∫–∫—É—Ä–∞—Ç–Ω–æ
                if (respawned) {
                    // –°–ª–µ–≥–∫–∞ –º–µ–Ω—è–µ–º –≤—ã—Å–æ—Ç—É
                    cloud.position.y = 90 + Math.random() * 30;
                }
            });
        }

        let lastTime = performance.now();
        let frameCount = 0;
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è
        let targetPixelRatio = window.devicePixelRatio;
        let currentPixelRatio = window.devicePixelRatio;

        function animate() {
            if (!gameStarted) {
                console.error('‚ùå animate() –≤—ã–∑–≤–∞–Ω –Ω–æ gameStarted = false!');
                return;
            }

            requestAnimationFrame(animate);

            const currentTime = performance.now();
            globalUniforms.time.value = currentTime * 0.001; // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –¥–ª—è —à–µ–π–¥–µ—Ä–æ–≤
            const delta = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            // –ê–Ω–∏–º–∞—Ü–∏—è –≤–æ–¥—ã
            if (textures.water) {
                textures.water.offset.x = (currentTime * 0.0001) % 1;
                textures.water.offset.y = (currentTime * 0.0001) % 1;
            }

            // === PHYSICS STEP ===
            if (physicsWorld) {
                physicsWorld.step(1 / 60, delta, 3);
            }
            
            // DYNAMIC RESOLUTION SCALING
            // –ï—Å–ª–∏ –º—ã—à—å –¥–≤–∏–≥–∞–µ—Ç—Å—è –±—ã—Å—Ç—Ä–æ, —Å–Ω–∏–∂–∞–µ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
            const mouseSpeed = Math.abs(mouse.x) + Math.abs(mouse.y);
            const isMovingFast = mouseSpeed > 5; // –ü–æ—Ä–æ–≥ —Å–∫–æ—Ä–æ—Å—Ç–∏
            
            // –¶–µ–ª–µ–≤–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ: 0.7 –æ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª–∞ –ø—Ä–∏ –±—ã—Å—Ç—Ä–æ–º –¥–≤–∏–∂–µ–Ω–∏–∏, –∏–Ω–∞—á–µ 1.0
            // –ù–æ –Ω–µ –Ω–∏–∂–µ 0.5 –∏ –Ω–µ –≤—ã—à–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∏
            const maxRatio = textureQuality === 'low' ? 1 : (textureQuality === 'high' ? 1.5 : 1.25);
            const minRatio = 0.6; 
            
            const target = isMovingFast ? Math.max(minRatio, maxRatio * 0.6) : maxRatio;
            
            // –ü–ª–∞–≤–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ
            currentPixelRatio += (target - currentPixelRatio) * 0.1;
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ (—á—Ç–æ–±—ã –Ω–µ –¥—ë—Ä–≥–∞—Ç—å GPU)
            if (Math.abs(currentPixelRatio - renderer.getPixelRatio()) > 0.05) {
                renderer.setPixelRatio(currentPixelRatio);
            }

            // FPS —Å—á–µ—Ç—á–∏–∫
            fpsCounter++;
            fpsTime += delta;
            if (fpsTime >= 1.0) {
                if (showFPS) {
                    const fpsElement = document.getElementById('fps');
                    if (fpsElement) {
                        fpsElement.textContent = `FPS: ${fpsCounter}`;
                    }
                }
                fpsCounter = 0;
                fpsTime = 0;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º debug –ø–∞–Ω–µ–ª—å
                const debugPanel = document.getElementById('debugPanel');
                if (debugPanel && debugPanel.style.display !== 'none') {
                    document.getElementById('chunksInfo').textContent = `${debugStats.chunksRendered}/${debugStats.chunksTotal}`;
                    document.getElementById('blocksInfo').textContent = debugStats.blocksRendered;
                    document.getElementById('zombiesInfo').textContent = debugStats.zombiesRendered;
                    const animalsInfo = document.getElementById('animalsInfo');
                    if (animalsInfo) {
                        animalsInfo.textContent = debugStats.animalsRendered;
                    }
                    document.getElementById('drawCallsInfo').textContent = renderer && renderer.info ? renderer.info.render.calls : 0;
                    document.getElementById('posInfo').textContent = 
                        `${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}`;
                    
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º LOD –±–ª–∏–∂–∞–π—à–µ–≥–æ —á–∞–Ω–∫–∞
                    const playerChunkX = Math.floor(player.position.x / CHUNK_SIZE);
                    const playerChunkZ = Math.floor(player.position.z / CHUNK_SIZE);
                    const chunkKey = getChunkKey(playerChunkX, playerChunkZ);
                    const lodLevel = chunkLODCache.get(chunkKey) || 'FULL';
                    document.getElementById('lodInfo').textContent = lodLevel;
                }
            }

            updatePlayer(delta);
            updateDroppedItems(delta);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –æ–±–≤–æ–¥–∫—É –±–ª–æ–∫–∞ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
            if (!inventoryOpen && pointerLocked) {
                const hit = raycast();
                if (hit && hit.distance < 5) {
                    const block = hit.object;
                    const blockType = block.userData?.type;
                    const isWater = blockType === 'water';
                    if (!player.inWater && !isWater) {
                        highlightBox.position.copy(block.position);
                        highlightBox.visible = true;
                    } else {
                        highlightBox.visible = false;
                    }
                } else {
                    highlightBox.visible = false;
                }
            } else {
                highlightBox.visible = false;
            }
            
            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
            if (graphicsQuality === 'ultra' && composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }

            frameCount++;
            if (frameCount === 1) {
                console.log('‚úì –ü–µ—Ä–≤—ã–π –∫–∞–¥—Ä –æ—Ç—Ä–µ–Ω–¥–µ—Ä–µ–Ω!');
            }
        }

        // === –°–ò–°–¢–ï–ú–ê –ú–ò–†–û–í ===
        function getWorldsIndex() {
            const index = localStorage.getItem('minecraftWorldsIndex');
            return index ? JSON.parse(index) : [];
        }

        function saveWorldsIndex(index) {
            localStorage.setItem('minecraftWorldsIndex', JSON.stringify(index));
        }

        function migrateOldSave() {
            const oldSave = localStorage.getItem('minecraftWorld');
            if (oldSave && !localStorage.getItem('minecraftWorldsIndex')) {
                const id = 'world_' + Date.now();
                const index = [{
                    id: id,
                    name: '–ú–æ–π –ø–µ—Ä–≤—ã–π –º–∏—Ä',
                    created: Date.now(),
                    lastPlayed: Date.now()
                }];
                saveWorldsIndex(index);
                localStorage.setItem('minecraftWorld_' + id, oldSave);
                localStorage.removeItem('minecraftWorld');
            }
        }

        function showWorldSelection() {
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('worldSelectionScreen').classList.remove('hidden');
            migrateOldSave();
            renderWorldList();
        }

        function backToMainMenu() {
            document.getElementById('worldSelectionScreen').classList.add('hidden');
            document.getElementById('menu').classList.remove('hidden');
        }

        function renderWorldList() {
            const list = document.getElementById('worldList');
            list.innerHTML = '';
            const worlds = getWorldsIndex();
            
            if (worlds.length === 0) {
                list.innerHTML = '<div style="color: #aaa; padding: 20px; text-align: center; font-family: \'Press Start 2P\';">–ù–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –º–∏—Ä–æ–≤</div>';
                return;
            }

            worlds.sort((a, b) => b.lastPlayed - a.lastPlayed);

            worlds.forEach(world => {
                const item = document.createElement('div');
                item.className = 'world-item';
                item.onclick = (e) => {
                    if (e.target.closest('.world-action-btn')) return;
                    selectWorld(world.id);
                };
                
                const date = new Date(world.lastPlayed).toLocaleString();
                
                item.innerHTML = `
                    <div class="world-info">
                        <div class="world-name">${world.name}</div>
                        <div class="world-date">–ò–≥—Ä–∞–ª–∏: ${date}</div>
                    </div>
                    <div class="world-actions">
                        <button class="world-action-btn" onclick="renameWorld('${world.id}')" title="–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å">‚úé</button>
                        <button class="world-action-btn delete" onclick="deleteWorld('${world.id}')" title="–£–¥–∞–ª–∏—Ç—å">üóë</button>
                        <button class="world-action-btn" onclick="selectWorld('${world.id}')" title="–ò–≥—Ä–∞—Ç—å">‚ñ∂</button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        function createNewWorld() {
            const name = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–∏—Ä–∞:', '–ù–æ–≤—ã–π –º–∏—Ä');
            if (!name) return;
            
            let seedInput = prompt('–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ (–æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ):');
            let seed;
            if (seedInput) {
                // –ü—Ä–æ—Å—Ç–æ–π —Ö—ç—à —Å—Ç—Ä–æ–∫–∏ –≤ —á–∏—Å–ª–æ
                seed = 0;
                for (let i = 0; i < seedInput.length; i++) {
                    seed = ((seed << 5) - seed) + seedInput.charCodeAt(i);
                    seed |= 0;
                }
            } else {
                seed = Math.floor(Math.random() * 2147483647);
            }

            const id = 'world_' + Date.now();
            const worlds = getWorldsIndex();
            worlds.push({
                id: id,
                name: name,
                created: Date.now(),
                lastPlayed: Date.now()
            });
            saveWorldsIndex(worlds);
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—É—Å—Ç–æ–π –º–∏—Ä
            const initialData = {
                worldChanges: {},
                playerPos: null, // –ë—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω —Å–ø–∞–≤–Ω –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                timestamp: Date.now(),
                seed: seed
            };
            localStorage.setItem('minecraftWorld_' + id, JSON.stringify(initialData));
            
            selectWorld(id);
        }

        function deleteWorld(id) {
            if (!confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç –º–∏—Ä? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å.')) return;
            
            let worlds = getWorldsIndex();
            worlds = worlds.filter(w => w.id !== id);
            saveWorldsIndex(worlds);
            localStorage.removeItem('minecraftWorld_' + id);
            renderWorldList();
        }

        function renameWorld(id) {
            const worlds = getWorldsIndex();
            const world = worlds.find(w => w.id === id);
            if (!world) return;
            
            const newName = prompt('–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ:', world.name);
            if (newName && newName !== world.name) {
                world.name = newName;
                saveWorldsIndex(worlds);
                renderWorldList();
            }
        }

        function selectWorld(id) {
            currentWorldId = id;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞—Ç—É –ø–æ—Å–ª–µ–¥–Ω–µ–π –∏–≥—Ä—ã
            const worlds = getWorldsIndex();
            const world = worlds.find(w => w.id === id);
            if (world) {
                world.lastPlayed = Date.now();
                saveWorldsIndex(worlds);
            }
            
            document.getElementById('worldSelectionScreen').classList.add('hidden');
            startGame();
        }

        function startGame() {
            console.log('\n========== –ó–ê–ü–£–°–ö –ò–ì–†–´ ==========');
            soundManager.unlock();

            const menu = document.getElementById('menu');
            const loadingScreen = document.getElementById('loadingScreen');
            const loadingFill = document.getElementById('loadingFill');
            const loadingText = document.getElementById('loadingText');

            if (menu) {
                menu.classList.add('hidden');
            }

            if (!loadingScreen || !loadingFill || !loadingText) {
                init();
                gameStarted = true;
                lastTime = performance.now();
                animate();
                soundManager.startAmbience();
                return;
            }

            loadingScreen.classList.add('visible');
            loadingFill.style.width = '15%';
            loadingText.textContent = '–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...';

            requestAnimationFrame(() => {
                try {
                    init();
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', error);
                    loadingText.textContent = '–û—à–∏–±–∫–∞! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å.';
                    return;
                }

                loadingFill.style.width = '100%';
                loadingText.textContent = '–ì–æ—Ç–æ–≤–æ!';

                setTimeout(() => {
                    loadingScreen.classList.remove('visible');
                    loadingFill.style.width = '0%';
                    soundManager.play('ui_close');

                    gameStarted = true;
                    lastTime = performance.now();
                    animate();
                    soundManager.startAmbience();

                    setTimeout(() => {
                        if (!pointerLocked && !inventoryOpen && !isPaused && !isDead) {
                            safeRequestPointerLock();
                            setTimeout(() => {
                                const clickHint = document.getElementById('clickHint');
                                if (clickHint) {
                                    clickHint.style.display = pointerLocked ? 'none' : 'block';
                                }
                            }, 200);
                        }
                    }, 150);
                }, 250);
            });
        }

        Object.assign(window, {
            startGame,
            openMainSettings,
            saveMainSettings,
            closeMainSettings,
            saveWorld,
            resumeGame,
            backToMenu,
            respawnPlayer
        });

        // –ó–∞–ø—Ä–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é
        document.addEventListener('contextmenu', e => e.preventDefault());
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –¥–ª—è –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é (–¥–æ –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã)
        document.addEventListener('DOMContentLoaded', () => {
            // –ó–∞–ø—É—Å–∫ –º—É–∑—ã–∫–∏ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–∏
            const startMusicOnInteraction = () => {
                soundManager.unlock();
                soundManager.startAmbience();
                document.removeEventListener('click', startMusicOnInteraction);
                document.removeEventListener('keydown', startMusicOnInteraction);
            };
            document.addEventListener('click', startMusicOnInteraction);
            document.addEventListener('keydown', startMusicOnInteraction);

            loadSettings();

            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é
            const mainVolume = document.getElementById('mainVolume');
            if (mainVolume) {
                mainVolume.addEventListener('input', (e) => {
                    const val = parseInt(e.target.value, 10);
                    document.getElementById('mainVolumeValue').textContent = val;
                    soundManager.setVolume(val / 100);
                });
            }

            const mainMusicVolume = document.getElementById('mainMusicVolume');
            if (mainMusicVolume) {
                mainMusicVolume.addEventListener('input', (e) => {
                    const val = parseInt(e.target.value, 10);
                    document.getElementById('mainMusicVolumeValue').textContent = val;
                    soundManager.setMusicVolume(val / 100);
                });
            }

            const mainEffectsVolume = document.getElementById('mainEffectsVolume');
            if (mainEffectsVolume) {
                mainEffectsVolume.addEventListener('input', (e) => {
                    const val = parseInt(e.target.value, 10);
                    document.getElementById('mainEffectsVolumeValue').textContent = val;
                    soundManager.setEffectsVolume(val / 100);
                });
            }

            const mainFov = document.getElementById('mainFov');
            if (mainFov) {
                mainFov.addEventListener('input', (e) => {
                    const val = parseInt(e.target.value, 10);
                    document.getElementById('mainFovValue').textContent = val;
                    fov = val;
                    if (camera) {
                        camera.fov = fov;
                        camera.updateProjectionMatrix();
                    }
                });
            }

            const mainRenderDistance = document.getElementById('mainRenderDistance');
            if (mainRenderDistance) {
                mainRenderDistance.addEventListener('input', (e) => {
                    document.getElementById('mainRenderDistanceValue').textContent = e.target.value;
                });
                const label = document.getElementById('mainRenderDistanceValue');
                if (label) {
                    label.textContent = mainRenderDistance.value;
                }
            }

            document.querySelectorAll('.menu-button').forEach((button) => {
                button.addEventListener('pointerdown', () => {
                    soundManager.unlock();
                    soundManager.play('ui_click');
                });
            });
            
            const mainSensitivity = document.getElementById('mainSensitivity');
            if (mainSensitivity) {
                mainSensitivity.addEventListener('input', (e) => {
                    document.getElementById('mainSensitivityValue').textContent = e.target.value;
                });
                const label = document.getElementById('mainSensitivityValue');
                if (label) {
                    label.textContent = mainSensitivity.value;
                }
            }
            
            const mainGraphicsPreset = document.getElementById('mainGraphicsPreset');
            if (mainGraphicsPreset) {
                mainGraphicsPreset.addEventListener('change', (e) => {
                    const quality = e.target.value;
                    const label = document.getElementById('mainGraphicsPresetValue');
                    if (label) {
                        label.textContent = GRAPHICS_LABELS[quality] || GRAPHICS_LABELS.medium;
                    }
                    // Render distance is now independent
                });
                const label = document.getElementById('mainGraphicsPresetValue');
                if (label) {
                    label.textContent = GRAPHICS_LABELS[mainGraphicsPreset.value] || GRAPHICS_LABELS.medium;
                }
            }

            const mainTextureQuality = document.getElementById('mainTextureQuality');
            if (mainTextureQuality) {
                mainTextureQuality.addEventListener('change', (e) => {
                    const label = document.getElementById('mainTextureValue');
                    if (label) {
                        label.textContent = TEXTURE_LABELS[e.target.value] || TEXTURE_LABELS.medium;
                    }
                });
                const textureLabel = document.getElementById('mainTextureValue');
                if (textureLabel) {
                    textureLabel.textContent = TEXTURE_LABELS[mainTextureQuality.value] || TEXTURE_LABELS.medium;
                }
            }
            
            console.log('‚úì –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã');
        });

        console.log('–°–∫—Ä–∏–ø—Ç –∑–∞–≥—Ä—É–∂–µ–Ω. –ù–∞–∂–º–∏—Ç–µ "–ò–≥—Ä–∞—Ç—å" –¥–ª—è —Å—Ç–∞—Ä—Ç–∞.');
    </script>
</body>
</html>
